<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>fslib</name></assembly>
<members>
<member name="T:Microsoft.FSharp.Collections.CHashSet`1">

</member>
<member name="T:Microsoft.FSharp.Collections.CHashTable`2">

</member>
<member name="M:Microsoft.FSharp.Collections.HashMultiMap`2.Add(``0,``1)">
<summary>
Add a binding for the element to the table
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashMultiMap`2.Clear">
<summary>
Clear all elements from the collection
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashMultiMap`2.Contains(``0)">
<summary>
Test if the collection contains any bindings for the given element
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashMultiMap`2.Copy">
<summary>
Make a shallow copy of the collection
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashMultiMap`2.Create">
<summary>
Create a new empty mutable hash table 
with key hash/equality based on the F# structural "hash" and (=) functions.

This function is always inlined to give compilers the opportunity to optimize the
structural hash/equality functions based on any available compile-time knowledge 
of the key type at the call site.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashMultiMap`2.Create(System.Int32)">
<summary>
Create a new empty mutable hash table with an internal bucket array of the given approximate size
and with key hash/equality based on the F# structural "hash" and (=) functions

This function is always inlined to give compilers the opportunity to optimize the
structural hash/equality functions based on any available compile-time knowledge 
of the key type at the call site.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashMultiMap`2.Create(System.Collections.Generic.IEqualityComparer`1{``0},System.Int32)">
<summary>
Create a new empty mutable hash table with an internal bucket array of the given approximate size
and with the given key hash/equality functions
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashMultiMap`2.Create(System.Collections.Generic.IEqualityComparer`1{``0},Microsoft.FSharp.Collections.HashStats,System.Int32)">
<summary>
Create a new empty mutable hash table with an internal bucket array of the given approximate size
and with the given key hash/equality functions and the given HashStats collector
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashMultiMap`2.Create(System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
 Build a map that contains the bindings of the given IEnumerable
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashMultiMap`2.Find(``0)">

</member>
<member name="M:Microsoft.FSharp.Collections.HashMultiMap`2.FindAll(``0)">
<summary>
Find all bindings for the given element in the table, if any
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashMultiMap`2.Fold``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``2}}})">
<summary>
Apply the given function to each element in the collection threading the accumulating parameter
through the sequence of function applications
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashMultiMap`2.GetLongestChain">
<summary>
Get the longest chain in the hash table as a list.  Use for debugging
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashMultiMap`2.Iterate(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit}})">
<summary>
Apply the given function to each binding in the hash table 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashMultiMap`2.Remove(``0)">
<summary>
Remove the latest binding (if any) for the given element from the table
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashMultiMap`2.Replace(``0,``1)">
<summary>
Replace the latest binding (if any) for the given element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashMultiMap`2.TryFind(``0)">
<summary>
Lookup the given element in the table, returning the result as an Option
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.HashMultiMap`2.Count">

</member>
<member name="P:Microsoft.FSharp.Collections.HashMultiMap`2.Item(``0)">
<summary>
Lookup or set the given element in the table.  Raise Not_found/IndexOutOfRangeException if the element is not found.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.HashMultiMap`2.Item(``0,``1)">
<summary>
Lookup or set the given element in the table.  Raise Not_found/IndexOutOfRangeException if the element is not found.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.HashMultiMap`2">
<summary>
 Hash tables, by default based on F# structural "hash" and (=) functions. 
 This is precisely the same type as that manipulated by 
 the functions in [[Microsoft.FSharp.Compatibility.OCaml.Hashtbl]].
 The table may map a single key to multiple bindings.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashSet`1.Add(``0)">
<summary>
Add an element to the collection
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashSet`1.Clear">
<summary>
Clear all elements from the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashSet`1.Contains(``0)">
<summary>
Test if the set contains the given element
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashSet`1.Copy">
<summary>
Make a shallow copy of the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashSet`1.Create">
<summary>
Create a new empty mutable hash set 
with key hash/equality based on the F# structural "hash" and (=) functions

This function is always inlined to give compilers the opportunity to optimize the
structural hash/equality functions based on any available compile-time knowledge 
of the key type at the call site.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashSet`1.Create(System.Int32)">
<summary>
Create a new empty mutable hash set with an internal bucket array of the given approximate size
and with key hash/equality based on the F# structural "hash" and (=) functions

This function is always inlined to give compilers the opportunity to optimize the
structural hash/equality functions based on any available compile-time knowledge 
of the key type at the call site.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashSet`1.Create(System.Collections.Generic.IEqualityComparer`1{``0},System.Int32)">
<summary>
Create a new empty mutable hash set with an internal bucket array of the given approximate size
and with the given key hash/equality functions 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashSet`1.Create(System.Collections.Generic.IEqualityComparer`1{``0},Microsoft.FSharp.Collections.HashStats,System.Int32)">
<summary>
Create a new empty mutable hash set with an internal bucket array of the given approximate size
and with the given key hash/equality functions and the given HashStats collector
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashSet`1.Create(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
Create a new mutable hash set containing elements drawn from the given sequence
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashSet`1.Fold``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}})">
<summary>
Apply the given function to the set threading the accumulating parameter
through the sequence of function applications
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashSet`1.GetLongestChain">
<summary>
 Use to debug poorly performing hash tables
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashSet`1.Iterate(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit})">
<summary>
Apply the given function to each binding in the hash table 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashSet`1.Remove(``0)">
<summary>
Remove the given element from the set
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.HashSet`1.Count">

</member>
<member name="T:Microsoft.FSharp.Collections.HashSet`1">
<summary>
 Mutable hash sets based by default on F# structural "hash" and (=) functions. Implemented via a hash table and/or Dictionary.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashStats.Create">
<summary>
Create a new HashStats sink.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.HashStats.LongestChainLength">
<summary>
 The longest ever chain length sampled in all tables traced by this sink.
 Chain levels are typically sampled only on resizes.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.HashStats.NumResizes">
<summary>
The total number of resizes of all hash tables traced by this sink.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.HashStats.NumTables">
<summary>
The total number of tables traced by this sink.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.HashStats">
<summary>
 Sinks recording statistical properties of one or more hash tables.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.HashTable`2">

</member>
<member name="T:Microsoft.FSharp.Collections.IHashOps`1">

</member>
<member name="T:Microsoft.FSharp.Collections.LazyList`1">
<summary>
 LazyLists are possibly-infinite, cached sequences.  See also IEnumerable/Seq for
 uncached sequences. Calling "get" on the same lazy list value you will keep 
 getting the same (cached) result.  LazyLists normally involve delayed computations
 without side-effects, and calling "get" may cause these computations to be executed.  The results 
 of these computations are cached - evaluations will be performed 
 only once for each element of the lazy list.  This is different to IEnumerable/Seq where
 recomputation happens each time an enumerator is created and the sequence traversed.

 LazyLists can represent cached potentially-infinite computations.  Because they are cached they may cause 
 memory leaks if some part of your code maintains a live reference to
 the head of an infinite or very large lazy list while iterating it, or if a reference is
 maintained after the list is no longer required.

 Although lazy lists are an abstract type you may pattern match against them using the
 LazyList.Cons and LazyList.Nil active patterns.  These may force the computation of elements
 of the list.

Possibly-infinite lazy lists. See also IEnumerable, which recomputes elements when needed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List`1.Cons(``0,Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 The module 'List' contains additional values and functions related to this type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List`1.Exists(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean})">
<summary>
Test if any element of the collection satisfies the given predicate.

See also List.exists. The module 'List' contains additional values and functions 
related to this type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List`1.Filter(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean})">
<summary>
Return a new collection containing only the elements of the collection
for which the given predicate returns "true"

See also List.filter. The module 'List' contains additional values and functions 
related to this type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List`1.ForAll(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean})">
<summary>
Test if all elements of the collection satisfy the given predicate.

See also List.for_all. The module 'List' contains additional values and functions 
related to this type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List`1.Iterate(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit})">
<summary>
 See List.iter
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List`1.IterateIndexed(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit}})">
<summary>
Apply the given function to each element of the collection. The integer passed to the
function indicates the index of element.

See also List.iteri. The module 'List' contains additional values and functions 
related to this type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List`1.Map``1(Microsoft.FSharp.Core.FastFunc`2{``0,``1})">
<summary>
Build a new list whose elements are the results of applying the given function

See also List.map. The module 'List' contains additional values and functions 
related to this type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List`1.MapIndexed``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,``1}})">
<summary>
Build a new collection whose elements are the results of applying the given function
to each of the elements of the collection. The integer index passed to the
function indicates the index (from 0) of element being transformed.

See also List.map. The module 'List' contains additional values and functions 
related to this type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List`1.Reverse">
<summary>
Return a new list with the elements in reverse order

See also List.rev. The module 'List' contains additional values and functions 
related to this type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.List`1.Head">
<summary>
 The module 'List' contains additional values and functions related to this type,
 e.g. List.fold_left, List.append etc.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.List`1.IsCons">
<summary>
 The module 'List' contains additional values and functions related to this type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.List`1.IsNil">
<summary>
 The module 'List' contains additional values and functions related to this type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.List`1.Length">
<summary>
 The module 'List' contains additional values and functions related to this type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.List`1.Nil">
<summary>
 The module 'List' contains additional values and functions related to this type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.List`1.Tail">
<summary>
 The module 'List' contains additional values and functions related to this type.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.List`1">
 <summary>
 The type of immutable singly-linked lists.  

 Use the constructors [] and '::' (infix) to create values of this type, or
 the notation [1;2;3].   Use the values in the [[List]] module to manipulate 
 values of this type, or pattern match against the values directly.
 </summary>

</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.Add(``0,``1)">
<summary>
 Return a new map with the binding added to the given map.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.ContainsKey(``0)">
<summary>
 Test is an element is in the domain of the map
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.Create">

</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.Create(System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
 Build a map that contains the bindings of the given IEnumerable
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.Empty">
<summary>
 The empty map
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.Equals(System.Object)">

</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.Exists(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}})">
<summary>
Return true if the given predicate returns true for one of the
bindings in the map. Always returns false if the map is empty.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.Filter(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}})">
<summary>
Build a new map containing the bindings for which the given predicate returns 'true'.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.Find(``0)">

</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.First``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Option`1{``2}}})">
<summary>
 Search the map looking for the first element where the given function returns a [[Some]] value
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.Fold``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``2}}})">
<summary>
 Fold over the bindings in the map.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.FoldAndMap``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,Microsoft.FSharp.Core.Tuple`2{``3,``2}}}})">
<summary>
 Fold over the bindings in the map.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.FoldSection``1(``0)">
<summary>
 Given the start and end points of a key range,
 Fold over the bindings in the map that are in the range,
 and the end points are included if present (the range is considered a closed interval).
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.ForAll(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}})">
<summary>
Return true if the given predicate returns true for all of the
bindings in the map. Always returns true if the map is empty.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.FromList(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">

</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.Iterate(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit}})">
<summary>
Apply the given function to each binding in the dictionary
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.Map``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}})">
<summary>
Build a new collection whose elements are the results of applying the given function
to each of the elements of the collection. The index passed to the
function indicates the index of element being transformed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.MapRange``1(Microsoft.FSharp.Core.FastFunc`2{``1,``2})">
<summary>
Build a new collection whose elements are the results of applying the given function
to each of the elements of the collection.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.Partition(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}})">
<summary>
Build two new maps, one containing the bindings for which the given predicate returns 'true',
and the other the remaining bindings.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.Remove(``0)">
<summary>
 Remove an element from the domain of the map.  No exception is raised if the element is not present.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.ToArray">
<summary>
The elements of the set as an array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.ToList">
<summary>
The elements of the set as a list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map`2.TryFind(``0)">
<summary>
 Lookup an element in the map, returning a [[Some]] value if the element is in the domain 
 of the map and [[None]] if not.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Map`2.Count">
<summary>
 The number of bindings in the map
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Map`2.IsEmpty">
<summary>
 Return true if there are no bindings in the map.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Map`2.Item(``0)">
<summary>
 Lookup an element in the map, raising [[Not_found]]/[[IndexOutOfRangeException]] if no binding
 exists in the map.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Map`2">
<summary>
Immutable maps.  Keys are ordered by F# structural comparison, potentially using implementations
of the IComparable interface on key values.

<performance> 
  Maps based on structural comparison are  
  efficient for small keys. They are not a suitable choice if keys are recursive data structures 
  or require non-structural comparison semantics.
</performance>
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Permutation..ctor(System.Int32[]`1)">
<summary>
 Create a permutation by specifying the result of permuting [| 0 .. n-1 |]. For example, 
 Permutation([| 1;2;0 |])  specifies a permutation that rotates all elements left one place.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Permutation..ctor(System.Int32,System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Core.Tuple`2{System.Int32,System.Int32}})">
<summary>
 Create a permutation by specifying (source,destination) index pairs. For example,
 Permutation(3,[ (0,2);(1,0); (2,1) ]) specifies a permutation that rotates 
 all elements left one place. Not all elements need be given, e.g. 
 Permutation(5,[ (1,2);(2,1) |]) specifies a permutation that swaps elements at indexes
 1 and 2.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Permutation.Compose(Microsoft.FSharp.Collections.Permutation,Microsoft.FSharp.Collections.Permutation)">
<summary>
 Return a permutation that, when applied, first applies p1 then applies p2.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Permutation.Identity(System.Int32)">
<summary>
 Return the iddentity permutation
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Permutation.Reverse(System.Int32)">
<summary>
 Return a permutation that, when applied, maps index 0 to N-1, N-1 to 0 etc.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Permutation.Rotate(System.Int32,Microsoft.FSharp.Core.Option`1{System.Int32})">
<summary>
 Return a permutation that rotates right by the given distance. If the distance
 is negative then a left rotation results.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Permutation.Swap(System.Int32,System.Int32,System.Int32)">
<summary>
 Return a swaps the given two elements.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Permutation.Inverse">
<summary>
 Compute the inverse of the permutation
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Permutation.Item(System.Int32)">
<summary>
 Apply the composition to an index within the range 0..Length-1
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Permutation.Length">

</member>
<member name="T:Microsoft.FSharp.Collections.Permutation">

</member>
<member name="T:Microsoft.FSharp.Collections.ReadonlyArray`1">
<summary>
 A type of read-only arrays
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.ResizeArray`1">

</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Add(``0)">
<summary>
 A useful shortcut for Set.add.  Note this operation prodcues a new set
 and does not mutate the original set.  The new set will share many storage
 nodes with the original.  See the Set module for further operations on sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Compare(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Contains(``0)">
<summary>
 A useful shortcut for Set.mem.  See the Set module for further operations on sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Create">

</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Create(System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 Build a set that contains the same elements as the given IEnumerable
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Difference(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Return a new set with the elements of the second set removed from the first.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Empty">
<summary>
 The empty set based on the default structural comparison operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Equality(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Equals(System.Object)">

</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Exists(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean})">
<summary>
Test if any element of the collection satisfies the given predicate.
If the elements are "i0...iN" 
then computes "p i0 or ... or p iN".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Filter(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean})">
<summary>
Return a new collection containing only the elements of the collection
for which the given predicate returns "true"
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Fold``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}})">
<summary>
Apply the given accumulating function to all the elements of the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.ForAll(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean})">
<summary>
Test if all elements of the collection satisfy the given predicate.
If the elements are "i0...iN" and "j0...jN"
then computes "p i0 &amp;&amp; ... &amp;&amp; p iN".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.FromArray(``0[]`1)">
<summary>
 Build a set that contains the same elements as the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.GetNextElement(``0)">
<summary>
 Returns the least element in the set that is greater than the given key 
 according to the ordering being used for the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.GetPreviousElement(``0)">
<summary>
 Returns the greatest element in the set that is less than the given key 
 according to the ordering being used for the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Intersection(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Compute the intersection of the two sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Intersection(System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Collections.Set`1{``0}})">
<summary>
Compute the intersection of N sets. At least one set must be given.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.IsSubsetOf(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Evaluates to "true" if all elements of the second set are in the first
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.IsSupersetOf(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Evaluates to "true" if all elements of the first set are in the second
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Iterate(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit})">
<summary>
Apply the given function to each binding in the collection
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Map``1(Microsoft.FSharp.Core.FastFunc`2{``0,``1})">
<summary>
Return a new collection containing the results of applying the
given function to each element of the input set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Partition(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean})">

</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Remove(``0)">
<summary>
 A useful shortcut for Set.remove.  Note this operation prodcues a new set
 and does not mutate the original set.  The new set will share many storage
 nodes with the original.  See the Set module for further operations on sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Singleton(``0)">
<summary>
 A singleton set based on the default structural comparison operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.ToArray">

</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.ToList">
<summary>
The elements of the set as a list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Union(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Compute the union of the two sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.Union(System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Collections.Set`1{``0}})">
<summary>
Compute the union of multiple sets.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Set`1.CheckBalanceInvariant">

</member>
<member name="P:Microsoft.FSharp.Collections.Set`1.Choose">

</member>
<member name="P:Microsoft.FSharp.Collections.Set`1.Count">
<summary>
 Return the number of elements in the set
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Set`1.IsEmpty">
<summary>
 A useful shortcut for Set.is_empty.  See the Set module for further operations on sets.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Set`1.MaximumElement">
<summary>
Returns the highest element in the set according to the ordering being used for the set
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Set`1.MinimumElement">
<summary>
Returns the lowest element in the set according to the ordering being used for the set
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Set`1.Size">
<summary>
 A useful shortcut for Set.size.  See the Set module for further operations on sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.op_Addition(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Compute the union of the two sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set`1.op_Subtraction(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Return a new set with the elements of the second set removed from the first.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Set`1">
<summary>
 Immutable sets based on binary trees, where comparison is the
 F# structural comparison function, potentially using implementations
 of the IComparable interface on key values.

 See the Set module for further operations on sets.

 These sets can be used with elements of any type, but you should check that
 structural hashing and equality on the element type are correct for your type.  

 Efficiency: Structural comparison is relatively efficient but is not a suitable
 choice in all circumstances, e.g. it may not compare efficiently on 
 non-reference types and deeply-structured types. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.list`1">

</member>
<member name="T:Microsoft.FSharp.Collections.roarray`1">

</member>
<member name="T:Microsoft.FSharp.Collections.seq`1">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.append``1(``0[]`1,``0[]`1)">
<summary>
Build a new array that contains the elements of the first array followed by the elements of the second array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.blit``1(``0[]`1,System.Int32,``0[]`1,System.Int32,System.Int32)">
<summary>
Read a range of elements from the first array and write them into the second.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.choose``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},``0[]`1)">
<summary>
Apply the given function to each element of the array. Return
the array comprised of the results "x" for each element where
the function returns Some(x)
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.combine``2(``0[]`1,``1[]`1)">
<summary>
Combine the two arrays into an array of pairs. The two arrays must have equal lengths.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.concat``1(Microsoft.FSharp.Collections.List`1{``0[]`1})">
<summary>
Build a new array that contains the elements of each of the given list of arrays
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.concat_seq``2(``0)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.copy``1(``0[]`1)">
<summary>
Build a new array that contains the elements of the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.create``1(System.Int32,``0)">
<summary>
 Create an array whose elements are all initially the given value.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.create_matrix``1(System.Int32,System.Int32,``0)">
<summary>
Create a jagged 2 dimensional array.

 This member is primarily provided for compatibility with implementations 
 of ML. F# also supports non-jagged 2D arrays - see the Array2 module and 
 types such as "int[,]".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.exists``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``0[]`1)">
<summary>
Test if any element of the array satisfies the given predicate.
If the elements are "i0...iN" 
then computes "p i0 or ... or p iN".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.fill``1(``0[]`1,System.Int32,System.Int32,``0)">
<summary>
Fill a range of an array with the given element
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.filter``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``0[]`1)">
<summary>
Return a new collection containing only the elements of the collection
for which the given predicate returns "true"
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.find``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``0[]`1)">
<summary>
Return the first element for which the given function returns "true".
Raise Not_found if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.find_index``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.find_indexi``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean}},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.first``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},``0[]`1)">
<summary>
Apply the given function to successive elements, returning the first
result where function returns "Some(x)" for some x.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.fold1_left``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.fold1_right``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.fold_left``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,``1[]`1)">
<summary>
Apply a function to each element of the collection, threading an 'accumulator' argument
through the computation. If the elements are "i0...iN" then computes "f (... (f s i0)...) iN"
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.fold_right``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}},``0[]`1,``1)">
<summary>
Apply a function to each element of the array, threading an 'accumulator' argument
through the computation. If the elements are "i0...iN" then computes "f i0 (...(f iN s))".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.for_all``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``0[]`1)">
<summary>
Test if all elements of the array satisfy the given predicate.
If the elements are "i0...iN" and "j0...jN"
then computes "p i0 &amp;&amp; ... &amp;&amp; p iN".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.get``1(``0[]`1,System.Int32)">
<summary>
 Fetch an element from an array.  You can also use the syntax arr.(idx).
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.get_IEnumerator``1(``0[]`1)">
<summary>
Return an enumerator for performing imperative enumerations over the given
array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.init``1(System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0})">
<summary>
 Create an array given the dimension and a generator function to compute the elements.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.iter``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},``0[]`1)">
<summary>
Apply the given function to each element of the array. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.iter2``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit}},``0[]`1,``1[]`1)">
<summary>
Apply the given function to two arrays simultaneously. The
two arrays must have the same lengths, otherwise an Invalid_argument exception is
raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.iteri``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit}},``0[]`1)">
<summary>
Apply the given function to each element of the array.  The integer passed to the
function indicates the index of element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.length``1(``0[]`1)">
<summary>
 Return the length of an array.  You can also use property arr.Length.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.make``1(System.Int32,``0)">
<summary>
 Create an array whose elements are all initially the given value
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.make_matrix``1(System.Int32,System.Int32,``0)">
<summary>
Create a jagged 2 dimensional array.  Synonym for create.

 This member is primarily provided for compatibility with implementations 
 of ML. F# also supports non-jagged 2D arrays - see the Array2 module and 
 types such as "int[,]".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0[]`1)">
<summary>
Build a new array whose elements are the results of applying the given function
to each of the elements of the array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.map2``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}},``0[]`1,``1[]`1)">
<summary>
Build a new collection whose elements are the results of applying the given function
to the corresponding elements of the two collections pairwise.  The two input
arrays must have the same lengths.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.mapi``2(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,``1}},``0[]`1)">
<summary>
Build a new array whose elements are the results of applying the given function
to each of the elements of the array. The integer index passed to the
function indicates the index of element being transformed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.of_ICollection``2(``0)">
<summary>
Build a new array from any type that supports the .NET ICollection interface
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.of_IEnumerable``2(``0)">
<summary>
Build a new array from the given enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.of_List``1(System.Collections.Generic.List`1{``0})">
<summary>
Build a new array for a .NET list object 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.of_ResizeArray``1(System.Collections.Generic.List`1{``0})">
<summary>
Build a new array for a .NET list object 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.of_list``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Build an array from the given list
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.of_llist``1(Microsoft.FSharp.Collections.LazyList`1{``0})">
<summary>
Build an array from the given lazy list
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.of_seq``2(``0)">
<summary>
Build a new array from the given enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.partition``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``0[]`1)">
<summary>
Split the collection into two collections, containing the 
elements for which the given predicate returns "true" and "false"
respectively 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.permute``1(Microsoft.FSharp.Collections.Permutation,``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.pin``2(``0[]`1,Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.nativeptr`1{``0},``1})">
<summary>
 Pin the given array for the duration of a single call to the given function.  A native pointer to
 the first element in the array is passed to the given function.  Cleanup the GCHandle associated with the 
 pin when the function completes, even if an exception is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.pin_unscoped``1(``0[]`1)">
<summary>
 As for Array.pin, except that the caller is responsible for calling Free on the returned GCHandle in order
 to release the pin.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.rev``1(``0[]`1)">
<summary>
Return a new array with the elements in reverse order
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.scan1_left``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.scan1_right``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.scan_left``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,``1[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.scan_right``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}},``0[]`1,``1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.set``1(``0[]`1,System.Int32,``0)">
<summary>
 Set the value of an element in an array.  You can also use the syntax 'arr.(idx) &lt;- e'.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.sort``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32}},``0[]`1)">
<summary>
Sort the elements of an array, using the given comparison function as the order 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.split``2(Microsoft.FSharp.Core.Tuple`2{``0,``1}[]`1)">
<summary>
Split a list of pairs into two lists
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.sub``1(``0[]`1,System.Int32,System.Int32)">
<summary>
Build a new array that contains the given subrange specified by
starting index and length.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.sumByFloat``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Double},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.sumByFloat32``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Single},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.sumByInt``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.sumByInt64``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Int64},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.to_ICollection``1(``0[]`1)">
<summary>
Return a view of the array as a .NET collection 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.to_IEnumerable``1(``0[]`1)">
<summary>
Return a view of the array as an enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.to_List``1(``0[]`1)">
<summary>
Build a new .NET list object for this array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.to_ResizeArray``1(``0[]`1)">
<summary>
Build a new .NET list object for this array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.to_list``1(``0[]`1)">
<summary>
Build a list from the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.to_llist``1(``0[]`1)">
<summary>
Build a lazy list from the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.to_seq``1(``0[]`1)">
<summary>
Return a view of the array as an enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.tryfind``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``0[]`1)">
<summary>
Return the first element for which the given function returns "true".
Return None if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array.tryfind_index``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.tryfind_indexi``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean}},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array.zero_create``1(System.Int32)">
<summary>
 Create an array where the entries are initially the
 a "default" value. For .NET reference types this will
 be "null".  For other types behaviour is undefined if 
 you access an entry of the array before setting it.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Array">
<summary>
 1-dimensional (generic) arrays.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.base1``1(``0[,]`1)">
<summary>
 Fetch the base-index for the first dimension of the array.

 See notes on the Array2 module re. zero-basing.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.base2``1(``0[,]`1)">
<summary>
 Fetch the base-index for the second dimension of the array.

 See notes on the Array2 module re. zero-basing.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.copy``1(``0[,]`1)">
<summary>
Build a new array whose elements are the same as the input array.

For non-zero-based arrays the basing on an input array will be propogated to the output
array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.create``1(System.Int32,System.Int32,``0)">
<summary>
 Create an array whose elements are all initially the given value
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.create_based``1(System.Int32,System.Int32,System.Int32,System.Int32,``0)">
<summary>
 Create an array where the entries are initially the
 a "default" value. For .NET reference types this will
 be "null".  For other types behaviour is undefined if 
 you access an entry of the array before setting it.

 See notes on the Array2 module re. zero-basing.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.get``1(``0[,]`1,System.Int32,System.Int32)">
<summary>
 Fetch an element from a 2D array.  You can also use the syntax "arr.(idx1,idx2)"
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.geta``1(``0[,]`1,System.Int32,System.Int32)">
<summary>
 Get the address of an element in the array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.init``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0}})">
<summary>
 Create an array given the dimension and a generator function to compute the elements.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.init_based``1(System.Int32,System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0}})">
<summary>
 Initialize a non-zero-based 2D array.

 See notes on the Array2 module re. zero-basing.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.iter``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},``0[,]`1)">
<summary>
Apply the given function to each element of the array. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.iteri``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit}}},``0[,]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array2.length1``1(``0[,]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array2.length2``1(``0[,]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array2.make``1(System.Int32,System.Int32,``0)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array2.map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0[,]`1)">
<summary>
Build a new array whose elements are the results of applying the given function
to each of the elements of the array.

For non-zero-based arrays the basing on an input array will be propogated to the output
array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.mapi``2(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,``1}}},``0[,]`1)">
<summary>
Build a new array whose elements are the results of applying the given function
to each of the elements of the array. The integer indices passed to the
function indicates the element being transformed.

For non-zero-based arrays the basing on an input array will be propogated to the output
array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.pin``2(``0[,]`1,Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.nativeptr`1{``0},``1})">
<summary>
 Pin the given array for the duration of a single call to the given function.  A native pointer to
 the first element in the array is passed to the given function.  Cleanup the GCHandle associated with the 
 pin when the function completes, even if an exception is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.pin_unscoped``1(``0[,]`1)">
<summary>
 As for Array2.pin, except that the caller is responsible for calling Free on the returned GCHandle in order
 to release the pin.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.rebase``1(``0[,]`1)">
<summary>
Build a new array whose elements are the same as the input array but
where a non-zero-based input array generates a corresponding zero-based 
output array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.set``1(``0[,]`1,System.Int32,System.Int32,``0)">
<summary>
 Set the value of an element in an array.  You can also 
 use the syntax "arr.[idx1,idx2] &lt;- e".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.zero_create``1(System.Int32,System.Int32)">
<summary>
 Create an array where the entries are initially the
 a "default" value. For .NET reference types this will
 be "null".  For other types behaviour is undefined if 
 you access an entry of the array before setting it.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array2.zero_create_based``1(System.Int32,System.Int32,System.Int32,System.Int32)">
<summary>
 Create an array where the entries are initially the
 a "default" value. For .NET reference types this will
 be "null".  For other types behaviour is undefined if 
 you access an entry of the array before setting it.

 See notes on the Array2 module re. zero-basing.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Array2">
<summary>
 Basic operations on 2-dimensional arrays. 

 F# and .NET multi-dimensional arrays are typically zero-based. 
 However, .NET multi-dimensional arrays used in conjunction with external
 libraries (e.g. libraries associated with Visual Basic) be 
 non-zero based, using a potentially different base for each dimension.
 The operations in this module will accept such arrays, and
 the basing on an input array will be propogated to a matching output
 array on the [[Array2.map]] and [[Array2.mapi]] operations.
 Non-zero-based arrays can also be created using [[Array2.zero_create_based]], 
 [[Array2.create_based]] and [[Array2.init_based]].

 This module is only available for F# on .NET 2.0.
 If using .NET 1.x then use Microsoft.FSharp.Compatiblity.CompatMatrix instead.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Array3.create``1(System.Int32,System.Int32,System.Int32,``0)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array3.get``1(``0[,,]`1,System.Int32,System.Int32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array3.init``1(System.Int32,System.Int32,System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0}}})">

</member>
<member name="M:Microsoft.FSharp.Collections.Array3.iter``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},``0[,,]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array3.iteri``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit}}}},``0[,,]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array3.length1``1(``0[,,]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array3.length2``1(``0[,,]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array3.length3``1(``0[,,]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array3.make``1(System.Int32,System.Int32,System.Int32,``0)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array3.map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0[,,]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array3.mapi``2(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,``1}}}},``0[,,]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array3.set``1(``0[,,]`1,System.Int32,System.Int32,System.Int32,``0)">

</member>
<member name="M:Microsoft.FSharp.Collections.Array3.zero_create``1(System.Int32,System.Int32,System.Int32)">

</member>
<member name="T:Microsoft.FSharp.Collections.Array3">
<summary>
 Basic operations on 3-dimensional arrays.  Only available for F# on .NET 2.0.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ComparisonIdentity.Custom``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32}})">

</member>
<member name="M:Microsoft.FSharp.Collections.ComparisonIdentity.FromFunction``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32}})">
<summary>
 Compare using the given comparer comparer function
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ComparisonIdentity.Structural``1">
<summary>
 Structural comparison.  Compare using LanguagePrimitives.StructuralComparer.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ComparisonIdentity.ViaIComparable``1">
<summary>
 Compare using any implementation of System.IComparable interfaces. This differs from structural comparison
 because arrays are not compared structurally, and many optimizations are not applied.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.ComparisonIdentity">
<summary>
 Common notions of comparison identity used with sorted data structures.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashIdentity.Custom``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32},Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean}})">

</member>
<member name="M:Microsoft.FSharp.Collections.HashIdentity.FromFunction``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32},Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean}})">
<summary>
 Physical hashing (hash on reference identity of objects, and the contents of value types).  
 Hash using LanguagePrimitives.PhysicalEquality and LanguagePrimitives.PhysicalHash,
 i.e. for value types use GetHashCode and Object.Equals (if no other optimization available),
 and for reference types use System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode and 
 reference equality. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashIdentity.Object``1">
<summary>
 Hash using Object.GetHashCode and Object.Equals(Object)
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashIdentity.Reference``1">
<summary>
 Physical hashing (hash on reference identity of objects, and the contents of value types).  
 Hash using LanguagePrimitives.PhysicalEquality and LanguagePrimitives.PhysicalHash,
 i.e. for value types use GetHashCode and Object.Equals (if no other optimization available),
 and for reference types use System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode and 
 reference equality. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashIdentity.Structural``1">
<summary>
 Structural hashing.  Hash using LanguagePrimitives.StructuralEquality and LanguagePrimitives.StructuralComparer.
 i.e. for value types use GetHashCode and Object.Equals (if no other optimization available),
 and for reference types use the F# cooperative structural term hashing scheme.  Object.GetHashCode(obj)
 is used if no other choice is available.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.HashIdentity.ViaGetHashCode``1">
<summary>
 Hash using Object.GetHashCode and Object.Equals(Object)
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.HashIdentity">
<summary>
 Common notions of value identity used with hash tables.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.append``3(``0,``2)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.choose``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},``2)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.combine``4(``0,``2)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.compare``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32}},``1,``2)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.concat``3(``0)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.delay``2(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.empty``1">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.exists``2(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``1)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.filter``2(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``1)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.find``2(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``1)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.first``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},``2)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.fold``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,``2)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.for_all``2(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``1)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.generate``2(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit})">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.generate_using``2(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}})">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.hd``2(``0)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.init_finite``1(System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.init_infinite``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.iter``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},``1)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.iter2``4(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit}},``2,``3)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.iteri``2(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit}},``1)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.length``2(``0)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.map``3(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``2)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.map2``5(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}},``3,``4)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.map_concat``4(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``3)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.map_to_typed``3(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``2)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.map_with_type``3(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``2)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.mapi``3(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,``1}},``2)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.nonempty``2(``0)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.nth``2(System.Int32,``0)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.of_array``1(``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.of_functions``2(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Core.FastFunc`2{``0,``1})">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.of_list``1(Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.pairwise``2(``0)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.singleton``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.take``2(System.Int32,``0)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.to_array``2(``0)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.to_list``2(``0)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.truncate``2(System.Int32,``0)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.tryfind``2(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``1)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.unfold``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Core.Tuple`2{``1,``0}}},``0)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.untyped_filter``2(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``1)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.untyped_fold``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,``2)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.untyped_iter``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},``1)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.untyped_map``3(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``2)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.untyped_to_list``2(``0)">

</member>
<member name="M:Microsoft.FSharp.Collections.IEnumerable.untyped_to_typed``2(``0)">

</member>
<member name="T:Microsoft.FSharp.Collections.IEnumerable">

</member>
<member name="T:Microsoft.FSharp.Collections.LazyList.llist`1">

</member>
<member name="T:Microsoft.FSharp.Collections.LazyList.t`1">

</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.append``1(Microsoft.FSharp.Collections.LazyList`1{``0},Microsoft.FSharp.Collections.LazyList`1{``0})">
<summary>
Return the stream which contains on demand the elements of the first stream followed
by the elements of the second list
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.combine``2(Microsoft.FSharp.Collections.LazyList`1{``0},Microsoft.FSharp.Collections.LazyList`1{``1})">

</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.concat``1(Microsoft.FSharp.Collections.LazyList`1{Microsoft.FSharp.Collections.LazyList`1{``0}})">

</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.cons``1(``0,Microsoft.FSharp.Collections.LazyList`1{``0})">
<summary>
Return a new stream which contains on demand the given item followed by the
given stream.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.consf``1(``0,Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Collections.LazyList`1{``0}})">
<summary>
Return a new stream which contains on demand the given item followed by the
stream returned by the given computation.  The computation is
not executed until the elements of the stream are consumed.  The
computation is only executed once.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.delayed``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Collections.LazyList`1{``0}})">
<summary>
Return a stream that is in effect the stream returned by the given computation.
The given computation is not executed until the first element on the stream is
consumed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.drop``1(System.Int32,Microsoft.FSharp.Collections.LazyList`1{``0})">
<summary>
Return the stream without the first 'n' elements of the given stream.  Does
not force the evaluation of any cells in the stream.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.empty``1">
<summary>
Evaluates to the stream that contains no items
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.filter``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.LazyList`1{``0})">
<summary>
Return a new collection which on consumption will consist of only the elements of the collection
for which the given predicate returns "true"
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.find``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.LazyList`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.first``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.LazyList`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.folds``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,Microsoft.FSharp.Collections.LazyList`1{``1})">
<summary>
Return a new stream consisting of the results of applying the given accumulating function
to successive elements of the stream
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.get``1(Microsoft.FSharp.Collections.LazyList`1{``0})">
<summary>
Get the first cell of the stream.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.get_IEnumerator``1(Microsoft.FSharp.Collections.LazyList`1{``0})">
<summary>
Return an enumerator for performing imperative enumerations over the given
collection.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.hd``1(Microsoft.FSharp.Collections.LazyList`1{``0})">
<summary>
Return the first element of the stream.  Raise 'Invalid_argument "hd"' if the
stream is empty. Forces the evaluation of
the first cell of the stream if it is not already evaluated.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Collections.LazyList`1{``0})">
<summary>
Build a new collection whose elements are the results of applying the given function
to each of the elements of the collection.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.map2``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}},Microsoft.FSharp.Collections.LazyList`1{``0},Microsoft.FSharp.Collections.LazyList`1{``1})">
<summary>
Build a new collection whose elements are the results of applying the given function
to the corresponding elements of the two collections pairwise.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.nonempty``1(Microsoft.FSharp.Collections.LazyList`1{``0})">
<summary>
Test if a stream contains at least one element.  Forces the evaluation of
the first element of the stream if it is not already evaluated.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.of_ICollection``2(``0)">
<summary>
Build a new collection from any type that supports the .NET ICollection interface
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.of_IEnumerable``2(``0)">
<summary>
Build a new collection from the given enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.of_array``1(``0[]`1)">
<summary>
Build a collection from the given array.
 This function will eagerly evaluate all of the stream (and thus may not terminate). 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.of_list``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Build a collection from the given list.
 This function will eagerly evaluate all of the stream (and thus may not terminate). 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.of_seq``2(``0)">
<summary>
Build a new collection from the given enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.repeat``1(``0)">
<summary>
Return the stream which on consumption will consist of an infinite sequence of the given item
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.take``1(System.Int32,Microsoft.FSharp.Collections.LazyList`1{``0})">
<summary>
Return the stream which on consumption will consist of at most 'n' elements of the given stream.  Does
not force the evaluation of any cells in the stream.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.tl``1(Microsoft.FSharp.Collections.LazyList`1{``0})">
<summary>
Return the stream corresponding to the remaining items in the sequence.  
Raise 'Invalid_argument "tl"' if the
stream is empty. Forces the evaluation of
the first cell of the stream if it is not already evaluated.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.to_ICollection``1(Microsoft.FSharp.Collections.LazyList`1{``0})">
<summary>
Return a view of the collection as a .NET collection 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.to_IEnumerable``1(Microsoft.FSharp.Collections.LazyList`1{``0})">
<summary>
Return a view of the collection as an enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.to_array``1(Microsoft.FSharp.Collections.LazyList`1{``0})">
<summary>
Build an array from the given collection
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.to_list``1(Microsoft.FSharp.Collections.LazyList`1{``0})">
<summary>
Build a list from the given collection
 This function will eagerly evaluate all of the stream (and thus may not terminate). 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.to_seq``1(Microsoft.FSharp.Collections.LazyList`1{``0})">
<summary>
Return a view of the collection as an enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.unfold``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Core.Tuple`2{``1,``0}}},``0)">
<summary>
Return a stream that contains the elements returned by the given computation.
The given computation is not executed until the first element on the stream is
consumed.  The given argument is passed to the computation.  Subsequent elements
 in the stream are generated by again applying the residual 'b to the computation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.LazyList.|Cons|Nil|``1(Microsoft.FSharp.Collections.LazyList`1{``0})">

</member>
<member name="T:Microsoft.FSharp.Collections.LazyList">

</member>
<member name="M:Microsoft.FSharp.Collections.List.append``1(Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Return a new list that contains the elements of the first list
followed by elements of the second
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.assoc``2(``0,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
 Lookup key's data in association list, uses (=) equality.
 Raises [[Not_found]] exception if key not found, in which case you should typically use [[try_assoc]] instead.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.assq``2(``0,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
 See [[assoc]], but uses the physical equality operator (==) for equality tests
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.choose``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Apply the given function to each element of the list. Return
the list comprised of the results "x" for each element where
the function returns Some(x)
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.combine``2(Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``1})">
<summary>
A synonym for List.combine
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.concat``2(``0)">
<summary>
Return a new list that contains the elements of each the lists in order
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.exists``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Test if any element of the collection satisfies the given predicate.
If the elements are "i0...iN" 
then computes "p i0 or ... or p iN".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.exists2``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``1})">
<summary>
Test if any corresponding elements of the collection satisfy the given predicate pairwise.
If the elements are "i0...iN" and "j0...jN"
then computes "p i0 j0 or ... or p iN jN".
Raises [[Invalid_argument]] exception if the lists do not zip (have different lengths).
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.filter``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Return a new collection containing only the elements of the collection
for which the given predicate returns "true"
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.find``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Return the first element for which the given function returns "true".
Raise Not_found if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.find_all``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Return a list containing allthe elements for which the given function returns
 "true".  Same as "filter"
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.find_index``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Raise Not_found if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.find_indexi``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean}},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Raise Not_found if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.first``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Apply the given function to successive elements, returning the first
result where function returns "Some(x)" for some x.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.flatten``2(``0)">
<summary>
Return a new list that contains the elements of each the lists in order.
Same as concat.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.fold1_left``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Apply a function to each element of the collection, threading an 'accumulator' argument
through the computation. Apply the function to the first two elements of the list.
Then feed this result into the function along with the third element and so on.  
Return the final result. 
 If the elements are "i0...iN" then computes "f (... (f i0 i1) i2 ...) iN"
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.fold1_right``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.fold_left``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,Microsoft.FSharp.Collections.List`1{``1})">
<summary>
Apply a function to each element of the collection, threading an 'accumulator' argument
through the computation. Take the second argument, and apply the function to it
and the first element of the list.  Then feed this result into the function along
with the second element and so on.  Return the final result.
If the elements are "i0...iN" then computes "f (... (f s i0) i1 ...) iN"
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.fold_left2``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``0}}},``0,Microsoft.FSharp.Collections.List`1{``1},Microsoft.FSharp.Collections.List`1{``2})">
<summary>
Apply a function to corresponding elements of two collections, threading an 'accumulator' argument
through the computation. The collections must have identical sizes.
If the elements are "i0...iN" and "j0...jN"
then computes "f (... (f s i0 j0)...) iN jN".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.fold_right``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}},Microsoft.FSharp.Collections.List`1{``0},``1)">
<summary>
Apply a function to each element of the collection, threading an 'accumulator' argument
through the computation. If the elements are "i0...iN" then computes "f i0 (...(f iN s))".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.fold_right2``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``2}}},Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``1},``2)">
<summary>
Apply a function to corresponding elements of two collections, threading an 'accumulator' argument
through the computation. The collections must have identical sizes.
If the elements are "i0...iN" and "j0...jN"
then computes "f i0 j0 (...(f iN jN s))".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.for_all``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Test if all elements of the collection satisfy the given predicate.
If the elements are "i0...iN" 
then computes "p i0 &amp;&amp; ... &amp;&amp; p iN".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.for_all2``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``1})">
<summary>
Test if all corresponding elements of the collection satisfy the given predicate pairwise.
If the elements are "i0...iN" and "j0...jN"
then computes "p i0 j0 &amp;&amp; ... &amp;&amp; p iN jN".
Raises [[Invalid_argument]] if the lists do not zip (have different lengths).
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.get_IEnumerator``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Return an enumerator for performing imperative enumerations over the given
collection.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.hd``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Return the first element of the list.  Raise (Invalid_argument "hd") if undefined.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.init``1(System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0})">
<summary>
 Create a list by calling the given generator on each index
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.iter``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Apply the given function to each element of the collection. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.iter2``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``1})">
<summary>
Apply the given function to two collections simultaneously. The
collections must have identical size.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.iteri``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Apply the given function to each element of the collection. The integer passed to the
function indicates the index of element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.iteri2``2(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``1})">
<summary>
Apply the given function to two collections simultaneously. The
collections must have identical size. The integer passed to the
function indicates the index of element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.length``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Return the length of the list
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Build a new collection whose elements are the results of applying the given function
to each of the elements of the collection.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.map2``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}},Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``1})">
<summary>
Build a new collection whose elements are the results of applying the given function
to the corresponding elements of the two collections pairwise.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.map3``4(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``3}}},Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``1},Microsoft.FSharp.Collections.List`1{``2})">
<summary>
Build a new collection whose elements are the results of applying the given function
to the corresponding elements of the three collections simultaneously.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.mapi``2(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,``1}},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Build a new collection whose elements are the results of applying the given function
to each of the elements of the collection. The integer index passed to the
function indicates the index (from 0) of element being transformed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.mapi2``3(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}}},Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``1})">
<summary>
Like mapi, but mapping corresponding elements from two lists of equal length.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.mem``1(``0,Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Is an element in the list, uses (=) equality.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.mem_assoc``2(``0,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
 Does the key have pair in the association list?
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.mem_assq``2(``0,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
 See [[mem_assoc]], but uses the physical equality operator (==) for equality tests.      
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.memq``1(``0,Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 See [[mem]], but uses the physical equality operator (==) for equality tests.        
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.nonempty``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Return true if the list is not empty.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.nth``1(Microsoft.FSharp.Collections.List`1{``0},System.Int32)">
<summary>
Index into the list.  The first element has index 0.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.of_ICollection``2(``0)">
<summary>
Build a new collection from any type that supports the .NET ICollection interface
 Unspecified behaviour if the underlying collection is mutated.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.of_IEnumerable``2(``0)">
<summary>
Build a new collection from the given enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.of_List``1(System.Collections.Generic.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.of_ResizeArray``1(System.Collections.Generic.List`1{``0})">
<summary>
 Convert from the System.Collections.Generic.List type, which in F# is referred to as ResizeArray
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.of_array``1(``0[]`1)">
<summary>
Build a collection from the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.of_llist``1(Microsoft.FSharp.Collections.LazyList`1{``0})">
<summary>
Build a collection from the given lazy list
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.of_seq``2(``0)">
<summary>
Build a new collection from the given enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.partition``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Split the collection into two collections, containing the 
elements for which the given predicate returns "true" and "false"
respectively 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.remove_assoc``2(``0,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
 Remove pair for key from the association list (if it's there).
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.remove_assq``2(``0,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
 See [[remove_assoc]], but uses the physical equality operator (==) for equality tests.        
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.rev``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Return a new list with the elements in reverse order
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.rev_append``1(Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
"rev_append l1 l2" evaluates to "append (rev l1) l2"
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.rev_map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
"rev_map f l1" evaluates to "map f (rev l1)"
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.rev_map2``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}},Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``1})">
<summary>
"rev_map2 f l1 l2" evaluates to "map2 f (rev l1) (rev l2)"
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.scan1_left``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.scan1_right``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.scan_left``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,Microsoft.FSharp.Collections.List`1{``1})">
<summary>
Apply a function to each element of the collection, threading an 'accumulator' argument
through the computation. Take the second argument, and apply the function to it
and the first element of the list.  Then feed this result into the function along
with the second element and so on.  Return the list of intermediate results and the final result.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.scan_right``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}},Microsoft.FSharp.Collections.List`1{``0},``1)">

</member>
<member name="M:Microsoft.FSharp.Collections.List.sort``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32}},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Sort the given list using the given comparison function
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.split``2(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
A synonym for List.unzip
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.stable_sort``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32}},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Sort the given list using the given comparison function, preserving order for equal elements.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.sumByFloat``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Double},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.sumByFloat32``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Single},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.sumByInt``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.sumByInt64``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Int64},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.List.tl``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Return the tail of the list.  Raise (Invalid_argument "tl") if undefined.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.to_ICollection``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Return a view of the collection as a .NET collection. Results in a ReadOnly collection.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.to_IEnumerable``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Return a view of the collection as an enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.to_List``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Convert to/from the System.Collections.Generic.List type 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.to_ResizeArray``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Convert to the System.Collections.Generic.List type, which in F# is referred to as ResizeArray
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.to_array``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Build an array from the given collection
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.to_llist``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Build a lazy list from the given collection
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.to_seq``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Return a view of the collection as an enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.try_assoc``2(``0,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
 Lookup key's data in association list, uses (=) equality,
 returning "Some data" or "None".  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.try_assq``2(``0,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
 See [[try_assoc]], but uses the physical equality operator (==) for equality tests.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.tryfind``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Return the first element for which the given function returns "true".
Return None if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.tryfind_index``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Return None if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.tryfind_indexi``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean}},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Return None if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.unzip``2(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
Split a list of pairs into two lists
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.unzip3``3(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Core.Tuple`3{``0,``1,``2}})">
<summary>
Split a list of triples into three lists
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.zip``2(Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``1})">
<summary>
Combine the two lists into a list of pairs. The two lists must have equal lengths.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.List.zip3``3(Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``1},Microsoft.FSharp.Collections.List`1{``2})">
<summary>
Combine the three lists into a list of triples. The lists must have equal lengths.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.List">
<summary>
 Basic operations on lists.  
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Map.CMapOps`2">

</member>
<member name="T:Microsoft.FSharp.Collections.Map.CMap`2">

</member>
<member name="T:Microsoft.FSharp.Collections.Map.Map`2">

</member>
<member name="T:Microsoft.FSharp.Collections.Map.ProviderUntagged`2">

</member>
<member name="T:Microsoft.FSharp.Collections.Map.Provider`2">

</member>
<member name="T:Microsoft.FSharp.Collections.Map.Provider`3">
<summary>
A collection of operations for creating and using maps based on a particular comparison function.
The 'tag type parameter is used to track information about the comparison function.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Map.t`2">
<summary>
 For use when not opening module, e.g. Map.t.  Used mainly in OCaml-compatible code.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.Make``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32}})">

</member>
<member name="M:Microsoft.FSharp.Collections.Map.MakeTagged``3(``0)">
<summary>
A functor to build a collection of operations for creating and using 
 maps based on the given comparison function. This returns a record that 
 contains the functions you use to create and manipulate maps of
 this kind.  The returned value is much like an ML module. 

 Language restrictions related to polymorphism may mean you
 have to create a new instantiation of for each toplevel
 key/value type pair.

 To use this function you need to define a new named class that implements IComparer and
 pass an instance of that class as the first argument. For example:
      type MyComparer = 
          new() = { }
          interface IComparer&lt;string&gt; with 
            member self.Compare(x,y) = ...

 let MyStringMapProvider : Map.Provider &lt; string,int &gt; = Map.MakeTagged(new MyComparer())
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.add``2(``0,``1,Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Return a new map with the binding added to the given map.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.empty``2">
<summary>
 The empty map
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.exists``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
Return true if the given predicate returns true for one of the
bindings in the map.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.filter``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
Build a new map containing only the bindings for which the given predicate returns 'true'
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.find``2(``0,Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Lookup an element in the map, raising [[Not_found]]/[[IndexOutOfRangeException]] if no binding
 exists in the map.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.find_index``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.Map`2{``0,``1})">

</member>
<member name="M:Microsoft.FSharp.Collections.Map.first``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Option`1{``2}}},Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Search the map looking for the first element where the given function returns a [[Some]] value
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.fold``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``2}}},Microsoft.FSharp.Collections.Map`2{``0,``1},``2)">
<summary>
 Fold over the bindings in the map 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.for_all``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
Return true if the given predicate returns true for all of the
bindings in the map.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.is_empty``2(Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Is the map empty?
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.iter``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
Apply the given function to each binding in the dictionary
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.map``3(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Collections.Map`2{``2,``0})">
<summary>
Build a new collection whose elements are the results of applying the given function
to each of the elements of the collection.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.mapi``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}},Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
Build a new collection whose elements are the results of applying the given function
to each of the elements of the collection. The integer index passed to the
function indicates the index of element being transformed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.mem``2(``0,Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Test is an element is in the domain of the map
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.of_IEnumerable``3(``0)">
<summary>
 Return a new map made from the given bindings
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.of_array``2(Microsoft.FSharp.Core.Tuple`2{``0,``1}[]`1)">
<summary>
 Return a new map made from the given bindings
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.of_list``2(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
 Return a new map made from the given bindings
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.of_seq``3(``0)">
<summary>
 Return a new map made from the given bindings
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.partition``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
Build two new maps, one containing the bindings for which the given predicate returns 'true',
and the other the remaining bindings.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.remove``2(``0,Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Remove an element from the domain of the map.  No exception is raised if the element is not present.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.to_array``2(Microsoft.FSharp.Collections.Map`2{``0,``1})">

</member>
<member name="M:Microsoft.FSharp.Collections.Map.to_list``2(Microsoft.FSharp.Collections.Map`2{``0,``1})">

</member>
<member name="M:Microsoft.FSharp.Collections.Map.to_seq``2(Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 View the collection as an enumerable sequence. This collection
 type is also directly compatible with 'seq&lt;KeyValuePair&lt;_,_&gt; &gt;'.

 Note this function returns a sequence of tuples, whereas the collection
 itself is compatible with the logically equivalent sequence of KeyValuePairs.
 Using sequences of tuples tends to be more convenient in F#, however the
 collection itself must enumerate KeyValuePairs to conform to the .NET
 design guidelines and the IDictionary interface.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.tryfind``2(``0,Microsoft.FSharp.Collections.Map`2{``0,``1})">
<summary>
 Lookup an element in the map, returning a [[Some]] value if the element is in the domain 
 of the map and [[None]] if not.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Map.tryfind_index``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},Microsoft.FSharp.Collections.Map`2{``0,``1})">

</member>
<member name="T:Microsoft.FSharp.Collections.Map">
 <summary>
   Immutable maps using structural comparison
 </summary>

 <performance> Maps based on structural comparison are  
 efficient. They are not a suitable choice if keys are recursive data structures 
 or require non-structural comparison semantics.</performance>
</member>
<member name="T:Microsoft.FSharp.Collections.ReadonlyArray.t`1">

</member>
<member name="M:Microsoft.FSharp.Collections.ReadonlyArray.append``1(Microsoft.FSharp.Collections.ReadonlyArray`1{``0},Microsoft.FSharp.Collections.ReadonlyArray`1{``0})">
<summary>
 "append a1 a2" is equivalent to "[|a1.(0);...;a1.(n-1);a2.(0);...;a2.(m-1)|]"
 where "n" is the length of "a1" and "m" is the length of "a2".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ReadonlyArray.concat``1(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Collections.ReadonlyArray`1{``0}})">
<summary>
 "concat" is similar to [append] but conjoins a list of read-only array.  Only
 one new roarray is allocated.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ReadonlyArray.fold_left``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,Microsoft.FSharp.Collections.ReadonlyArray`1{``1})">
<summary>
Apply a function to each element of the collection, threading an 'accumulator' argument
through the computation. If the elements are "i0...iN" then computes "f (... (f s i0)...) iN"
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ReadonlyArray.fold_right``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}},Microsoft.FSharp.Collections.ReadonlyArray`1{``0},``1)">
<summary>
Apply a function to each element of the collection, threading an 'accumulator' argument
through the computation. If the elements are "i0...iN" then computes "f i0 (...(f iN s))".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ReadonlyArray.get``1(Microsoft.FSharp.Collections.ReadonlyArray`1{``0},System.Int32)">
<summary>
Get an element from a read-only array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ReadonlyArray.get_IEnumerator``1(Microsoft.FSharp.Collections.ReadonlyArray`1{``0})">
<summary>
Return an enumerator for performing imperative enumerations over the given
collection.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ReadonlyArray.init``1(System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0})">
<summary>
 Create a read-only array by index
 "init n f" creates the roarray "[| f 0; ...; f (n-1) |]".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ReadonlyArray.iter``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.ReadonlyArray`1{``0})">
<summary>
Apply the given function to each element of the collection. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ReadonlyArray.iteri``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.ReadonlyArray`1{``0})">
<summary>
Apply the given function to each element of the collection. The integer passed to the
function indicates the index of element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ReadonlyArray.length``1(Microsoft.FSharp.Collections.ReadonlyArray`1{``0})">
<summary>
Get the length of a read-only array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ReadonlyArray.map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Collections.ReadonlyArray`1{``0})">
<summary>
Build a new collection whose elements are the results of applying the given function
to each of the elements of the collection.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ReadonlyArray.mapi``2(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,``1}},Microsoft.FSharp.Collections.ReadonlyArray`1{``0})">
<summary>
Build a new collection whose elements are the results of applying the given function
to each of the elements of the collection. The integer index passed to the
function indicates the index of element being transformed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ReadonlyArray.of_ICollection``2(``0)">
<summary>
Build a new collection from any type that supports the .NET ICollection interface
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ReadonlyArray.of_IEnumerable``2(``0)">
<summary>
Build a new collection from the given enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ReadonlyArray.of_List``1(System.Collections.Generic.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.ReadonlyArray.of_ResizeArray``1(System.Collections.Generic.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.ReadonlyArray.of_list``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Build a collection from the given list
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ReadonlyArray.of_llist``1(Microsoft.FSharp.Collections.LazyList`1{``0})">
<summary>
Build a collection from the given lazy list
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ReadonlyArray.of_seq``2(``0)">
<summary>
Build a new collection from the given enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ReadonlyArray.sub``1(Microsoft.FSharp.Collections.ReadonlyArray`1{``0},System.Int32,System.Int32)">
<summary>
 "sub a n m" is equivalent to "[| a.(n); ...; a.(n+m) |]".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ReadonlyArray.to_ICollection``1(Microsoft.FSharp.Collections.ReadonlyArray`1{``0})">
<summary>
Return a view of the collection as a .NET collection 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ReadonlyArray.to_IEnumerable``1(Microsoft.FSharp.Collections.ReadonlyArray`1{``0})">
<summary>
Return a view of the collection as an enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ReadonlyArray.to_List``1(Microsoft.FSharp.Collections.ReadonlyArray`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.ReadonlyArray.to_ResizeArray``1(Microsoft.FSharp.Collections.ReadonlyArray`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Collections.ReadonlyArray.to_list``1(Microsoft.FSharp.Collections.ReadonlyArray`1{``0})">
<summary>
Build a list from the given collection
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ReadonlyArray.to_llist``1(Microsoft.FSharp.Collections.ReadonlyArray`1{``0})">
<summary>
Build a lazy list from the given collection
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ReadonlyArray.to_seq``1(Microsoft.FSharp.Collections.ReadonlyArray`1{``0})">
<summary>
Return a view of the collection as an enumerable object
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.ReadonlyArray">

</member>
<member name="T:Microsoft.FSharp.Collections.ResizeArray.t`1">

</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.append``1(System.Collections.Generic.List`1{``0},System.Collections.Generic.List`1{``0})">
<summary>
Build a new array that contains the elements of the first array followed by the elements of the second array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.blit``1(System.Collections.Generic.List`1{``0},System.Int32,System.Collections.Generic.List`1{``0},System.Int32,System.Int32)">
<summary>
Read a range of elements from the first array and write them into the second.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.choose``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},System.Collections.Generic.List`1{``0})">
<summary>
Apply the given function to each element of the array. Return
the array comprised of the results "x" for each element where
the function returns Some(x)
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.combine``2(System.Collections.Generic.List`1{``0},System.Collections.Generic.List`1{``1})">
<summary>
Combine the two arrays into an array of pairs. The two arrays must have equal lengths.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.concat``1(Microsoft.FSharp.Collections.List`1{System.Collections.Generic.List`1{``0}})">
<summary>
Build a new array that contains the elements of each of the given list of arrays
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.copy``1(System.Collections.Generic.List`1{``0})">
<summary>
Build a new array that contains the elements of the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.create``1(System.Int32,``0)">
<summary>
 Create an array whose elements are all initially the given value.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.exists``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.List`1{``0})">
<summary>
Test if any element of the array satisfies the given predicate.
If the elements are "i0...iN" 
then computes "p i0 or ... or p iN".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.fill``1(System.Collections.Generic.List`1{``0},System.Int32,System.Int32,``0)">
<summary>
Fill a range of the collection with the given element
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.filter``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.List`1{``0})">
<summary>
Return a new collection containing only the elements of the collection
for which the given predicate returns "true"
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.find``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.List`1{``0})">
<summary>
Return the first element for which the given function returns "true".
Raise Not_found if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.first``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},System.Collections.Generic.List`1{``0})">
<summary>
Apply the given function to successive elements, returning the first
result where function returns "Some(x)" for some x.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.fold_left``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,System.Collections.Generic.List`1{``1})">
<summary>
Apply a function to each element of the collection, threading an 'accumulator' argument
through the computation. If the elements are "i0...iN" then computes "f (... (f s i0)...) iN"
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.fold_right``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}},System.Collections.Generic.List`1{``0},``1)">
<summary>
Apply a function to each element of the array, threading an 'accumulator' argument
through the computation. If the elements are "i0...iN" then computes "f i0 (...(f iN s))".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.for_all``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.List`1{``0})">
<summary>
Test if all elements of the array satisfy the given predicate.
If the elements are "i0...iN" and "j0...jN"
then computes "p i0 &amp;&amp; ... &amp;&amp; p iN".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.get``1(System.Collections.Generic.List`1{``0},System.Int32)">
<summary>
 Fetch an element from the collection.  You can also use the syntax arr.(idx).
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.init``1(System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0})">
<summary>
 Create an array by calling the given generator on each index.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.iter``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},System.Collections.Generic.List`1{``0})">
<summary>
Apply the given function to each element of the array. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.iter2``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.List`1{``0},System.Collections.Generic.List`1{``1})">
<summary>
Apply the given function to two arrays simultaneously. The
two arrays must have the same lengths, otherwise an Invalid_argument exception is
raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.iteri``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.List`1{``0})">
<summary>
Apply the given function to each element of the array.  The integer passed to the
function indicates the index of element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.length``1(System.Collections.Generic.List`1{``0})">
<summary>
 Return the length of the collection.  You can also use property arr.Length.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},System.Collections.Generic.List`1{``0})">
<summary>
Build a new array whose elements are the results of applying the given function
to each of the elements of the array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.map2``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}},System.Collections.Generic.List`1{``0},System.Collections.Generic.List`1{``1})">
<summary>
Build a new collection whose elements are the results of applying the given function
to the corresponding elements of the two collections pairwise.  The two input
arrays must have the same lengths.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.mapi``2(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,``1}},System.Collections.Generic.List`1{``0})">
<summary>
Build a new array whose elements are the results of applying the given function
to each of the elements of the array. The integer index passed to the
function indicates the index of element being transformed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.of_list``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Build an array from the given list
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.partition``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.List`1{``0})">
<summary>
Split the collection into two collections, containing the 
elements for which the given predicate returns "true" and "false"
respectively 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.rev``1(System.Collections.Generic.List`1{``0})">
<summary>
Return a new array with the elements in reverse order
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.set``1(System.Collections.Generic.List`1{``0},System.Int32,``0)">
<summary>
 Set the value of an element in the collection.  You can also use the syntax 'arr.(idx) &lt;- e'.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.split``2(System.Collections.Generic.List`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
Split a list of pairs into two lists
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.sub``1(System.Collections.Generic.List`1{``0},System.Int32,System.Int32)">
<summary>
Build a new array that contains the given subrange specified by
starting index and length.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.to_list``1(System.Collections.Generic.List`1{``0})">
<summary>
Build a list from the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.ResizeArray.tryfind``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},System.Collections.Generic.List`1{``0})">
<summary>
Return the first element for which the given function returns "true".
Return None if no such element exists.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.ResizeArray">
<summary>
 1-dimensional (generic) arrays.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.append``3(``0,``2)">
<summary>
Wrap the two given enumeration-of-enumerations as a single concatenated
enumeration.

The returned IEnumerable may be passed between threads safely. However, 
individual IEnumerator values generated from the returned IEnumerable should not be accessed from
multiple threads simultaneously.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.cache_all``2(``0)">
<summary>
 The sequence returned by this function caches the computation of the input
 sequence. Enumerators for the returned sequence fill a lookaside table
 of entries computed so far.  This table is consulted whenever an entry is required
 up to the limit of the computed portion of the table. The lookaside table 
 is associated with the returned sequence and is used by all enumerators
 for the returned sequence. 

 Enumerators of the returned sequence initially generate elements by each using
 an enumerator for the underlying sequence. This happens even if some lookaside elements
 are available, e.g. from partial or incomplete enumerations of the returned seqeuence. 
 However once at least one enumerator manages to reach completion (i.e. IEnumerator.MoveNext returns
 false) then all the future enumerators of the returned sequence will will 
 simply return the results contained in the lookaside table.

 The sequence must be stable, i.e. each enumerator for the sequence must return 
 identical results.

 Generated IEnumerator values may be used simultaneously from different threads (accesses to 
 the internal lookaside table are thread safe). Each individual IEnumerator
 is not thread safe and should not be accessed from multiple threads simultaneously.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.choose``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},``2)">
<summary>
Apply the given function to each element of the list. Return
the list comprised of the results "x" for each element where
the function returns Some(x)

The returned IEnumerable may be passed between threads safely. However, 
individual IEnumerator values generated from the returned IEnumerable should not be accessed from
multiple threads simultaneously.

Remember IEnumerable is lazy, effects are delayed until it is enumerated.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.combine``4(``0,``2)">
<summary>
A synonym for Seq.zip
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.compare``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32}},``1,``2)">
<summary>
 Compare two IEnumerable's using the given comparison function.  Both
 input IEnumerables are assumed to be in a canonical order (i.e. sorted)
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.concat``3(``0)">
<summary>
Wrap the given enumeration-of-enumerations as a single concatenated
enumeration.

The returned IEnumerable may be passed between threads safely. However, 
individual IEnumerator values generated from the returned IEnumerable should not be accessed from
multiple threads simultaneously.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.cons``2(``0,``1)">
<summary>
Return an IEnumerable that when iterated yields
the given item followed by the items in the given sequence
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.countBy``3(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``2)">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.delay``2(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``0})">
<summary>
Return an IEnumerable that is built from the given delayed specification of an
IEnumerable. The input function is evaluated each time an IEnumerator for the IEnumerable 
is requested.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.do_finally``2(``0,Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Call the given function every time an enumerator for the returned sequence is disposed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.empty``1">
<summary>
 Create an empty IEnumerable 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.exists``2(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``1)">
<summary>
Test if any element of the collection satisfies the given predicate.
If the elements are "i0...iN" 
then computes "p i0 or ... or p iN".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.filter``2(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``1)">
<summary>
Return a new collection containing only the elements of the collection
for which the given predicate returns "true"

The returned IEnumerable may be passed between threads safely. However, 
individual IEnumerator values generated from the returned IEnumerable should not be accessed from
multiple threads simultaneously.

Remember IEnumerable is lazy, effects are delayed until it is enumerated.      
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.find``2(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``1)">
<summary>
Return the first element for which the given function returns "true".
Raise Not_found if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.find_index``3(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``1)">
<summary>
Raise Not_found if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.find_indexi``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},``2)">
<summary>
Raise Not_found if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.first``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},``2)">
<summary>
Apply the given function to successive elements, returning the first
result where function returns "Some(x)" for some x.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.fold``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,``2)">
<summary>
Apply a function to each element of the collection, threading an 'accumulator' argument
through the computation. If the elements are "i0...iN" then computes "f (... (f s i0)...) iN"
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.fold1``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},``1)">
<summary>
Apply a function to each element of the sequence, threading an 'accumulator' argument
through the computation. Begin by applying the function to the first two elements.
Then feed this result into the function along with the third element and so on.  
Return the final result. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.for_all``2(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``1)">
<summary>
Test if all elements of the collection satisfy the given predicate.
If the elements are "i0...iN" 
then computes "p i0 &amp;&amp; ... &amp;&amp; p iN".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.generate``2(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit})">
<summary>
 Imperative generation of an IEnumerable from a cursor handle (e.g. from a file handle
 or database connection).

 A cursor is created by calling the 'open' function, which will typically
 open a file, a database connection or some other resource.

 One cursor is created each time an IEnumerator is generated for the IEnumerable, hence
 you can use this funciton to create IEnumerables for a logical structure (e.g. a file) that has
 multiple active independent readers (e.g. open file handles).  Individual elements are
 read from the file using the element generator. The element generator is executed on demand 
 as an enumeration proceeds over the IEnumerator, until a None value is returned by the element generator.

 The 'close' function is called when the None condition is reached or when the IEnumerator object
 is explicitly disposed.  The close function is called at most once per active 
 enumeration (i.e. once per IEnumerator object created for this IEnumerable). The close function 
 is not called during finalization, since the enumerator is not itself the immediate owner of
 any resources.

 Note a fresh call to 'opener' will be used and the stream will be recomputed each time 
 an IEnumerator is requested for the IEnumerable.  

 The returned IEnumerable may be passed between threads safely.  However, 
 individual IEnumerator values generated from it should not be accessed from
 multiple threads simultaneously. The 'close' function may also be called from the finalization thread.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.generate_using``2(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}})">
<summary>
Similar to generate, except the 'close' function is implicit from the IDisposable
interface implemented by the state value

Equivalent to "generate opener generator (fun s -> s.Dispose())"
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.generated``2(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,System.Boolean},``0)">
<summary>
 Generate a sequence by repeatedly calling the given function and
 concatenating the results (similar to a while loop)
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.groupBy``3(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``2)">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.hd``2(``0)">
<summary>
Return the first element of the IEnumerable.  Raise (Invalid_argument "hd") if undefined.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.init_finite``1(System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0})">
<summary>
Generate a new IEnumerable which, when iterated, will return successive
elements by calling the given function, up to the given count.  The results of calling the function
will not be saved, i.e. the function will be reapplied as necessary to
regenerate the elements.  The function is passed the index of the item being
generated.

The returned IEnumerable may be passed between threads safely. However, 
individual IEnumerator values generated from the returned IEnumerable should not be accessed from
multiple threads simultaneously.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.init_infinite``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0})">
<summary>
Generate a new IEnumerable which, when iterated, will return successive
elements by calling the given function.  The results of calling the function
will not be saved, i.e. the function will be reapplied as necessary to
regenerate the elements.  The function is passed the index of the item being
generated

The returned IEnumerable may be passed between threads safely. However, 
individual IEnumerator values generated from the returned IEnumerable should not be accessed from
multiple threads simultaneously.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.iter``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},``1)">
<summary>
Apply the given function to each element of the collection. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.iter2``4(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit}},``2,``3)">
<summary>
Apply the given function to two collections simultaneously. The
collections must have identical size.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.iteri``2(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit}},``1)">
<summary>
Apply the given function to each element of the collection. The integer passed to the
function indicates the index of element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.length``2(``0)">
<summary>
Return the length of the IEnumerable
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.map``3(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``2)">
<summary>
Build a new collection whose elements are the results of applying the given function
to each of the elements of the collection.  The function will be applied
as elements are demanded using the 'Current' property on iterators retrieved from the
object.  Generating multiple iterators or calling the 'Current' property multiple
times may result in the function being called multiple times.

The returned IEnumerable may be passed between threads safely. However, 
individual IEnumerator values generated from the returned IEnumerable should not be accessed from
multiple threads simultaneously.

Remember IEnumerable is lazy, effects are delayed until it is enumerated.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.map2``5(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}},``3,``4)">
<summary>
Build a new collection whose elements are the results of applying the given function
to the corresponding elements of the two collections pairwise.

Remember IEnumerable is lazy, effects are delayed until it is enumerated.        
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.map_concat``4(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``3)">
<summary>
For each element of the enumeration apply the given function and concatenate all the results.

Remember IEnumerable is lazy, effects are delayed until it is enumerated.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.map_to_typed``3(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``2)">
<summary>
Transform a loosely-typed System.Collections IEnumerable
to a new collection whose elements are the results of applying the given function
to each of the elements of the collection.

The use of this function usually requires a type annotation.
An incorrect type annotation may result in runtime type
errors.

The returned IEnumerable may be passed between threads safely. However, 
individual IEnumerator values generated from the returned IEnumerable should not be accessed from
multiple threads simultaneously.

Remember IEnumerable is lazy, effects are delayed until it is enumerated.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.map_with_type``3(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``2)">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.mapi``3(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,``1}},``2)">
<summary>
Build a new collection whose elements are the results of applying the given function
to each of the elements of the collection. The integer index passed to the
function indicates the index (from 0) of element being transformed.

Remember IEnumerable is lazy, effects are delayed until it is enumerated.            
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.nonempty``2(``0)">
<summary>
Return true if the IEnumerable is not empty.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.nth``2(System.Int32,``0)">
<summary>
Compute the nth element in the collection.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.of_array``1(``0[]`1)">
<summary>
Build a collection from the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.of_functions``2(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Core.FastFunc`2{``0,``1})">
<summary>
 Generate an IEnumerable based on a function that generates an arbitrarily typed enumerator,
 two functions that are effectively the same as IEnumerator.MoveNext and IEnumerator.Current
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.of_list``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Build a collection from the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.orderBy``3(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``2)">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.pairwise``2(``0)">
<summary>
Return a sequence of each element in the input sequence and its predecessor, with the
exception of the first element which is only returned as the predecessor of the second element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.readonly``2(``0)">
<summary>
 Build a new sequence object that delegates to the
 given sequence object. This ensures the original sequence can't be 
 rediscovered and mutated by a type cast. For example, if given an 
 array the returned sequence will return the elements of the array, but
 you can't cast the returned sequence object to an array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.scan``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,``2)">
<summary>
Like fold, but compute on-demand and return the sequence of intermediary and final results
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.scan1``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},``1)">
<summary>
Like fold1, but compute on-demand and return the sequence of intermediary and final results
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.singleton``1(``0)">
<summary>
Return an IEnumerable that yields one item only.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.sumByFloat``2(Microsoft.FSharp.Core.FastFunc`2{``0,System.Double},``1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.sumByFloat32``2(Microsoft.FSharp.Core.FastFunc`2{``0,System.Single},``1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.sumByInt``2(Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32},``1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.sumByInt64``2(Microsoft.FSharp.Core.FastFunc`2{``0,System.Int64},``1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Seq.tail_cons``2(``0,``1)">
<summary>
Return an IEnumerable that when iterated yields
the items in the given sequence followed by the given item
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.take``2(System.Int32,``0)">
<summary>
Return the first N elements of the IEnumerable.  Raise (Invalid_argument "take") if undefined.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.to_array``2(``0)">
<summary>
Build an array from the given collection
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.to_list``2(``0)">
<summary>
Build a list from the given collection
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.truncate``2(System.Int32,``0)">
<summary>
Return an IEnumerable that when enumerated returns at most N elements.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.tryfind``2(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``1)">
<summary>
Return the first element for which the given function returns "true".
Return None if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.tryfind_index``3(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``1)">
<summary>
Return None if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.tryfind_indexi``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}},``2)">
<summary>
Return None if no such element exists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.unfold``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Core.Tuple`2{``1,``0}}},``0)">
<summary>
Return an IEnumerable that contains the elements generated by the given computation.
The given initial 'state' argument is passed to the element generator.
For each IEnumerator elements in the stream are generated on-demand by applying the element
generator, until a None value is returned by the element generator. Each call to the element
generator returns a new residual 'state'.

Note the stream will be recomputed each time an IEnumerator is requested and iterated for the IEnumerable.

The returned IEnumerable may be passed between threads safely. However, 
individual IEnumerator values generated from the returned IEnumerable should not be accessed from
multiple threads simultaneously.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.untyped_filter``2(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``1)">
<summary>
Return a new collection containing only the elements of the collection
for which the given predicate returns "true"

The use of this function usually requires a type annotation.
An incorrect type annotation may result in runtime type
errors.

Remember IEnumerable is lazy, effects are delayed until it is enumerated.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.untyped_fold``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,``2)">
<summary>
Apply a function to each element of the collection, threading an 'accumulator' argument
through the computation. If the elements are "i0...iN" then computes "f (... (f s i0)...) iN"

The use of this function usually requires a type annotation.
An incorrect type annotation may result in runtime type
errors.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.untyped_iter``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},``1)">
<summary>
Apply the given function to each element of the collection. 

The use of this function usually requires a type annotation.
An incorrect type annotation may result in runtime type
errors.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.untyped_map``3(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``2)">
<summary>
Build a new collection whose elements are the results of applying the given function
to each of the elements of the collection.

The use of this function usually requires a type annotation.
An incorrect type annotation may result in runtime type
errors.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.untyped_to_list``2(``0)">
<summary>
Transform a loosely-typed System.Collections IEnumerable to a strongly typed F# list.

The use of this function usually requires a type annotation.
An incorrect type annotation may result in runtime type
errors.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.untyped_to_typed``2(``0)">
<summary>
Wrap a loosely-typed System.Collections IEnumerable as a typed 
System.Collections.Generic.IEnumerable.

The use of this function usually requires a type annotation.
An incorrect type annotation may result in runtime type
errors.

Individual IEnumerator values generated from the returned IEnumerable should not be accessed from
multiple threads simultaneously.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.using``3(``0,Microsoft.FSharp.Core.FastFunc`2{``0,``1})">
<summary>
 Use the given function to create a resource, then passs the resource
 to the second function. An instance of the resource will be created each
 time an IEnumerator for the sequence is created, and disposed when the IEnumerator 
 is disposed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Seq.zip``4(``0,``2)">
<summary>
Combine the two sequences into a list of pairs. The two sequences need not have equal lengths:
when one sequence is exhausted any remaining elements in the other
sequence are ignored.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Seq">

</member>
<member name="T:Microsoft.FSharp.Collections.Set.CSetOps`1">

</member>
<member name="T:Microsoft.FSharp.Collections.Set.CSet`1">
<summary>
 Sets with a user-defined comparison function.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Set.ProviderUntagged`1">

</member>
<member name="T:Microsoft.FSharp.Collections.Set.Provider`1">

</member>
<member name="T:Microsoft.FSharp.Collections.Set.Provider`2">
<summary>
A collection of operations for creating and using sets based on a particular comparison function.
The 'tag' type parameter is used to track information about the comparison function.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Set.Set`1">

</member>
<member name="T:Microsoft.FSharp.Collections.Set.t`1">
<summary>
 For use when not opening the Set module, e.g. Set.t
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.Make``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32}})">
<summary>
 Build a collection of operations for creating and using 
 maps based on a single consistent comparison function. This returns a record
 that contains the functions you use to create and manipulate maps all of which 
 use this comparison function.  The returned value is much like an ML module. 

 Use MakeTagged if you want additional type safety that guarantees that two sets
 based on different comparison functions can never be combined in inconsistent ways.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.MakeTagged``2(``0)">
<summary>
A functor to build a collection of operations for creating and using 
 sets based on the given comparison function. This returns a record that 
 contains the functions you use to create and manipulate maps of
 this kind.  The returned value is much like an ML module. 

 To use this function you need to define a new named class that implements IComparer and
 pass an instance of that class as the first argument. For example:
      type MyComparer() = 
          interface IComparer&lt;string&gt; with 
            member self.Compare(x,y) = ...

 let MyStringSetProvider = Set.MakeTagged(new MyComparer())
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.add``1(``0,Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Return a new set with an element added to the set.  No exception is raised if
the set already contains the given element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.cardinal``1(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Return the number of elements in the set.  Same as "size"
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.choose``1(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Choose an arbitrary element from a set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.compare``1(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Compare two sets. Places sets into a total order. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.diff``1(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Return a new set with the elements of the second set
removed from the first.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.elements``1(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
The elements of the set as a list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.empty``1">
<summary>
The empty set.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.equal``1(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Test if two sets are equal
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.exists``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Test if any element of the collection satisfies the given predicate.
If the elements are "i0...iN" 
then computes "p i0 or ... or p iN".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.filter``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Return a new collection containing only the elements of the collection
for which the given predicate returns "true"
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.fold``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}},Microsoft.FSharp.Collections.Set`1{``0},``1)">
<summary>
Apply the given accumulating function to all the elements of the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.for_all``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Test if all elements of the collection satisfy the given predicate.
If the elements are "i0...iN" and "j0...jN"
then computes "p i0 &amp;&amp; ... &amp;&amp; p iN".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.get_IEnumerator``1(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Return an enumerator for performing imperative enumerations over the given
 collection.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.inter``1(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Compute the intersection of the two sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.is_empty``1(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Return "true" if the set is empty
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.iter``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Apply the given function to each element of the set, in order according
to the comparison function
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Return a new collection containing the results of applying the
given function to each element of the input set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.max_elt``1(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Returns the highest element in the set according to the ordering being used for the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.mem``1(``0,Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Evaluates to "true" if the given element is in the given set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.min_elt``1(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Returns the lowest element in the set according to the ordering being used for the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.of_ICollection``2(``0)">
<summary>
 Build a new collection from any type that supports the .NET ICollection interface
 Unspecified behaviour if the underlying collection is mutated.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.of_IEnumerable``2(``0)">
<summary>
 Build a new collection from the given enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.of_array``1(``0[]`1)">
<summary>
 Build a set that contains the same elements as the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.of_list``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Build a set that contains the same elements as the given list
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.of_llist``1(Microsoft.FSharp.Collections.LazyList`1{``0})">
<summary>
 Build a set that contains the same elements as the given stream. The stream must be finite.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.of_seq``2(``0)">
<summary>
 Build a new collection from the given enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.partition``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Split the set into two sets containing the elements for which the given predicate
returns true and false respectively
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.remove``1(``0,Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Return a new set with the given element removed.  No exception is raised in 
the set doesn't contain the given element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.singleton``1(``0)">
<summary>
The set containing the given one element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.size``1(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Return the number of elements in the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.subset``1(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Evaluates to "true" if all elements of the first set are in the second
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.to_ICollection``1(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Return a view of the collection as a .NET collection. Results in a ReadOnly collection
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.to_IEnumerable``1(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Return a view of the collection as an enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.to_array``1(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Build an array that contains the elements of the set in order
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.to_list``1(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Build a list that contains the elements of the set in order
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.to_llist``1(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Build a lazy list that contains the elements of the set in order
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.to_seq``1(Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
 Return a view of the collection as an enumerable object
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Set.union``1(Microsoft.FSharp.Collections.Set`1{``0},Microsoft.FSharp.Collections.Set`1{``0})">
<summary>
Compute the union of the two sets.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Set">

</member>
<member name="T:Microsoft.FSharp.Collections.Tagged.HashMultiMapUntagged`2">

</member>
<member name="T:Microsoft.FSharp.Collections.Tagged.HashMultiMap`2">

</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3.Add(``0,``1)">
<summary>
Add a binding for the element to the table
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3.Clear">
<summary>
Clear all elements from the collection
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3.Contains(``0)">
<summary>
Test if the collection contains any bindings for the given element
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3.Copy">
<summary>
Make a shallow copy of the collection
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3.Create(``2,System.Int32)">
<summary>
Create a new empty mutable hash table with an internal bucket array of the given approximate size
and with the given key hash/equality functions
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3.Create(``2,Microsoft.FSharp.Collections.HashStats,System.Int32)">
<summary>
Create a new empty mutable hash table with an internal bucket array of the given approximate size
and with the given key hash/equality functions
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3.Find(``0)">

</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3.FindAll(``0)">
<summary>
Find all bindings for the given element in the table, if any
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3.Fold``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``3,``3}}})">
<summary>
Apply the given function to each element in the collection threading the accumulating parameter
through the sequence of function applications
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3.GetLongestChain">
<summary>
Get the longest chain in the hash table as a list.  Use for debugging
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3.Iterate(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit}})">
<summary>
Apply the given function to each binding in the hash table 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3.Remove(``0)">
<summary>
Remove the latest binding (if any) for the given element from the table
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3.Replace(``0,``1)">
<summary>
Replace the latest binding (if any) for the given element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3.TryFind(``0)">
<summary>
Lookup the given element in the table, returning the result as an Option
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3.Count">

</member>
<member name="P:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3.Item(``0)">
<summary>
Lookup or set the given element in the table.  Raise Not_found/IndexOutOfRangeException if the element is not found.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3.Item(``0,``1)">
<summary>
Lookup or set the given element in the table.  Raise Not_found/IndexOutOfRangeException if the element is not found.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Tagged.HashMultiMap`3">
<summary>
 HashMultiMap, but where a constraint tag tracks information about the hash/equality functions used
 for the hashing. When the tag is Tags.StructuralHash this is identical to HashMultiMap.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Tagged.HashSetUntagged`1">

</member>
<member name="T:Microsoft.FSharp.Collections.Tagged.HashSet`1">
<summary>
 Mutable hash sets based on F# structural "hash" and (=) functions. Implemented via a hash table and/or Dictionary.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashSet`2.Add(``0)">
<summary>
Add an element to the collection
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashSet`2.Clear">
<summary>
Clear all elements from the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashSet`2.Contains(``0)">
<summary>
Test if the set contains the given element
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashSet`2.Copy">
<summary>
Make a shallow copy of the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashSet`2.Create(``1,System.Int32)">
<summary>
Create a new empty mutable hash set with an internal bucket array of the given approximate size
and with the given key hash/equality functions 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashSet`2.Create(``1,Microsoft.FSharp.Collections.HashStats,System.Int32)">
<summary>
Create a new empty mutable hash set with an internal bucket array of the given approximate size
and with the given key hash/equality functions and the given HashStats collector
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashSet`2.Fold``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``2,``2}})">
<summary>
Apply the given function to the set threading the accumulating parameter
through the sequence of function applications
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashSet`2.GetLongestChain">
<summary>
 Use to debug poorly performing hash tables
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashSet`2.Iterate(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit})">
<summary>
Apply the given function to each binding in the hash table 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.HashSet`2.Remove(``0)">
<summary>
Remove the given element from the set
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Tagged.HashSet`2.Count">

</member>
<member name="T:Microsoft.FSharp.Collections.Tagged.HashSet`2">
<summary>
 Mutable hash sets where a constraint tag tracks information about the hash/equality functions used
 for the hashing. When the tag is Tags.StructuralHash this is identical to HashSet.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Tagged.MapUntagged`2">

</member>
<member name="T:Microsoft.FSharp.Collections.Tagged.Map`2">
<summary>
Immutable maps.  Keys are ordered by construction function specified
when creating empty maps or by F# structural comparison if no
construction function is specified.

<performance> 
  Maps based on structural comparison are  
  efficient for small keys. They are not a suitable choice if keys are recursive data structures 
  or require non-structural comparison semantics.
</performance>
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.Add(``0,``1)">
<summary>
 Return a new map with the binding added to the given map.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.ContainsKey(``0)">
<summary>
 Test is an element is in the domain of the map
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.Create(``2,System.Collections.Generic.IEnumerable`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
 Build a map that contains the bindings of the given IEnumerable
 and where comparison of elements is based on the given comparison function
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.Empty(``2)">
<summary>
 The empty map, and use the given comparer comparison function for all operations associated
 with any maps built from this map.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.Equals(System.Object)">

</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.Exists(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}})">
<summary>
Return true if the given predicate returns true for one of the
bindings in the map. Always returns false if the map is empty.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.Filter(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}})">
<summary>
Build a new map containing the bindings for which the given predicate returns 'true'.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.Find(``0)">

</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.First``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Option`1{``3}}})">
<summary>
 Search the map looking for the first element where the given function returns a [[Some]] value
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.Fold``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``3,``3}}})">
<summary>
 Fold over the bindings in the map.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.FoldAndMap``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``3,Microsoft.FSharp.Core.Tuple`2{``4,``3}}}})">
<summary>
 Fold over the bindings in the map.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.FoldSection``1(``0)">
<summary>
 Given the start and end points of a key range,
 Fold over the bindings in the map that are in the range,
 and the end points are included if present (the range is considered a closed interval).
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.ForAll(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}})">
<summary>
Return true if the given predicate returns true for all of the
bindings in the map. Always returns true if the map is empty.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.FromList(``2,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">

</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.Iterate(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit}})">
<summary>
Apply the given function to each binding in the dictionary
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.Map``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``3}})">
<summary>
Build a new collection whose elements are the results of applying the given function
to each of the elements of the collection. The index passed to the
function indicates the index of element being transformed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.MapRange``1(Microsoft.FSharp.Core.FastFunc`2{``1,``3})">
<summary>
Build a new collection whose elements are the results of applying the given function
to each of the elements of the collection.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.Partition(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,System.Boolean}})">
<summary>
Build two new maps, one containing the bindings for which the given predicate returns 'true',
and the other the remaining bindings.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.Remove(``0)">
<summary>
 Remove an element from the domain of the map.  No exception is raised if the element is not present.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.ToArray">
<summary>
The elements of the set as an array
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.ToList">
<summary>
The elements of the set as a list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Map`3.TryFind(``0)">
<summary>
 Lookup an element in the map, returning a [[Some]] value if the element is in the domain 
 of the map and [[None]] if not.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Tagged.Map`3.Count">
<summary>
 The number of bindings in the map
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Tagged.Map`3.IsEmpty">
<summary>
 Return true if there are no bindings in the map.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Tagged.Map`3.Item(``0)">
<summary>
 Lookup an element in the map, raising [[Not_found]]/[[IndexOutOfRangeException]] if no binding
 exists in the map.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Tagged.Map`3">
<summary>
 Immutable maps.  A constraint tag carries information about the key-comparer 
 being used.  If 'comparerTag is Tags.StructuralComparer then 
 this type is the same as Set (the tag can be ignored).
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Tagged.SetUntagged`1">

</member>
<member name="T:Microsoft.FSharp.Collections.Tagged.Set`1">
<summary>
 Immutable sets based on binary trees, where comparison is the
 F# structural comparison function.

 See the Set module for further operations on sets.

 These sets can be used with elements of any type, but you should check that
 structural hashing and equality on the element type are correct for your type.  

 Efficiency: Structural comparison is relatively efficient but is not a suitable
 choice in all circumstances, e.g. it may not compare efficiently on 
 non-reference types and deeply-structured types. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Add(``0)">
<summary>
 A useful shortcut for Set.add.  Note this operation prodcues a new set
 and does not mutate the original set.  The new set will share many storage
 nodes with the original.  See the Set module for further operations on sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Compare(Microsoft.FSharp.Collections.Tagged.Set`2{``0,``1},Microsoft.FSharp.Collections.Tagged.Set`2{``0,``1})">

</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Contains(``0)">
<summary>
 A useful shortcut for Set.mem.  See the Set module for further operations on sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Create(``1,System.Collections.Generic.IEnumerable`1{``0})">
<summary>
 The empty set based on the given comparer
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Difference(Microsoft.FSharp.Collections.Tagged.Set`2{``0,``1},Microsoft.FSharp.Collections.Tagged.Set`2{``0,``1})">
<summary>
Return a new set with the elements of the second set removed from the first.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Empty(``1)">

</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Equality(Microsoft.FSharp.Collections.Tagged.Set`2{``0,``1},Microsoft.FSharp.Collections.Tagged.Set`2{``0,``1})">

</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Equals(System.Object)">

</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Exists(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean})">
<summary>
Test if any element of the collection satisfies the given predicate.
If the elements are "i0...iN" 
then computes "p i0 or ... or p iN".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Filter(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean})">
<summary>
Return a new collection containing only the elements of the collection
for which the given predicate returns "true"
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Fold``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``2,``2}})">
<summary>
Apply the given accumulating function to all the elements of the set
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.ForAll(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean})">
<summary>
Test if all elements of the collection satisfy the given predicate.
If the elements are "i0...iN" and "j0...jN"
then computes "p i0 &amp;&amp; ... &amp;&amp; p iN".
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Intersection(Microsoft.FSharp.Collections.Tagged.Set`2{``0,``1},Microsoft.FSharp.Collections.Tagged.Set`2{``0,``1})">
<summary>
Compute the intersection of the two sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.IsSubsetOf(Microsoft.FSharp.Collections.Tagged.Set`2{``0,``1})">
<summary>
Evaluates to "true" if all elements of the second set are in the first
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.IsSupersetOf(Microsoft.FSharp.Collections.Tagged.Set`2{``0,``1})">
<summary>
Evaluates to "true" if all elements of the first set are in the second
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Iterate(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit})">
<summary>
Apply the given function to each binding in the collection
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Partition(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean})">

</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Remove(``0)">
<summary>
 A useful shortcut for Set.remove.  Note this operation prodcues a new set
 and does not mutate the original set.  The new set will share many storage
 nodes with the original.  See the Set module for further operations on sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Singleton(``1,``0)">
<summary>
 A singleton set based on the given comparison operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.ToArray">

</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.ToList">
<summary>
The elements of the set as a list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.Union(Microsoft.FSharp.Collections.Tagged.Set`2{``0,``1},Microsoft.FSharp.Collections.Tagged.Set`2{``0,``1})">
<summary>
Compute the union of the two sets.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Tagged.Set`2.CheckBalanceInvariant">

</member>
<member name="P:Microsoft.FSharp.Collections.Tagged.Set`2.Choose">

</member>
<member name="P:Microsoft.FSharp.Collections.Tagged.Set`2.Count">
<summary>
 Return the number of elements in the set
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Tagged.Set`2.IsEmpty">
<summary>
 A useful shortcut for Set.is_empty.  See the Set module for further operations on sets.
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Tagged.Set`2.MaximumElement">
<summary>
Returns the highest element in the set according to the ordering being used for the set
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Tagged.Set`2.MinimumElement">
<summary>
Returns the lowest element in the set according to the ordering being used for the set
</summary>
</member>
<member name="P:Microsoft.FSharp.Collections.Tagged.Set`2.Size">
<summary>
 A useful shortcut for Set.size.  See the Set module for further operations on sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.op_Addition(Microsoft.FSharp.Collections.Tagged.Set`2{``0,``1},Microsoft.FSharp.Collections.Tagged.Set`2{``0,``1})">
<summary>
Compute the union of the two sets.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tagged.Set`2.op_Subtraction(Microsoft.FSharp.Collections.Tagged.Set`2{``0,``1},Microsoft.FSharp.Collections.Tagged.Set`2{``0,``1})">
<summary>
Return a new set with the elements of the second set removed from the first.
</summary>
</member>
<member name="T:Microsoft.FSharp.Collections.Tagged.Set`2">
<summary>
 Immutable sets where a constraint tag carries information about the key-comparer 
 being used.  If 'comparerTag is Tags.StructuralComparer then 
 this type is the same as Set (the tag can be ignored).
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tags.ReferenceHash`1..ctor">

</member>
<member name="T:Microsoft.FSharp.Collections.Tags.ReferenceHash`1">
<summary>
 This tag indicates the collection uses physical hashing (hash on reference 
 identity of objects, and the contents of value types).  
 i.e. for value types use GetHashCode and Object.Equals (if no other optimization available),
 and for reference types use System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode and 
 reference equality. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tags.StructuralComparer`1..ctor">

</member>
<member name="T:Microsoft.FSharp.Collections.Tags.StructuralComparer`1">
<summary>
 This tag indicates the collection uses structural comparison on keys, except where the structural comparison
 semantics has been altered for particular types through re-implementations of the IComparer interface.
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tags.StructuralHash`1..ctor">

</member>
<member name="T:Microsoft.FSharp.Collections.Tags.StructuralHash`1">
<summary>
 This tag indicates the collection uses structural hashing on keys, except where the structural hashing
 semantics has been altered through re-implementations of the IStructuralHash interface
</summary>
</member>
<member name="M:Microsoft.FSharp.Collections.Tags.Optimizations.StructuralComparerInt..ctor">

</member>
<member name="T:Microsoft.FSharp.Collections.Tags.Optimizations.StructuralComparerInt">

</member>
<member name="M:Microsoft.FSharp.Collections.Tags.Optimizations.StructuralHashInt..ctor">

</member>
<member name="T:Microsoft.FSharp.Collections.Tags.Optimizations.StructuralHashInt">

</member>
<member name="T:Microsoft.FSharp.Collections.Tags.Optimizations">

</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatArray.append``1(``0[]`1,``0[]`1)">
<summary>
Build a new array that contains the elements of the first array followed by the elements of the second array
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatArray.blit``1(``0[]`1,System.Int32,``0[]`1,System.Int32,System.Int32)">
<summary>
Read a range of elements from the first array and write them into the second.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatArray.concat``1(Microsoft.FSharp.Collections.List`1{``0[]`1})">
<summary>
Build a new array that contains the elements of each of the given list of arrays
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatArray.copy``1(``0[]`1)">
<summary>
Build a new array that contains the elements of the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatArray.create``1(System.Int32,``0)">
<summary>
Create a new array of the given length, each entry of which holds the given element
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatArray.fill``1(``0[]`1,System.Int32,System.Int32,``0)">
<summary>
Fill a range of an array with the given element
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatArray.fold_left``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,``1[]`1)">
<summary>
Apply a function to each element of the collection, threading an 'accumulator' argument
through the computation. If the elements are "i0...iN" then computes "f (... (f s i0)...) iN"
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatArray.fold_right``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}},``0[]`1,``1)">
<summary>
Compute f (get arr n) (...(f (get arr n) s))
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatArray.get``1(``0[]`1,System.Int32)">
<summary>
Fetch the given element of the array, indexed by 0
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatArray.init``1(System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0})">
<summary>
Build a new array whose elements are f 0, ... f N
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatArray.iter``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},``0[]`1)">
<summary>
Execute the given function for each element of the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatArray.iteri``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit}},``0[]`1)">
<summary>
Execute the given function for each element of the given array.  The integer
index indicates the index of the element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatArray.length``1(``0[]`1)">
<summary>
The length of the array
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatArray.make``1(System.Int32,``0)">
<summary>
Build a new array of the given length, each entry of which holds the given element.
Same as create.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatArray.map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0[]`1)">
<summary>
Build a new array whose elements are the results of applying the given function
to each of the elements of the array.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatArray.mapi``2(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,``1}},``0[]`1)">
<summary>
Build a new array whose elements are the results of applying the given function
to each of the elements of the array. The integer
index passed to the funciton indicates the index of the element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatArray.of_array``1(``0[]`1)">
<summary>
Build a .NET compatible array from the F# array.  Note that F# arrays and .NET
compatible arrays are only different types when using .NET 1.0 or 1.1
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatArray.of_list``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Convert the given list to a .NET compatible array suitable for passing to .NET functions
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatArray.set``1(``0[]`1,System.Int32,``0)">
<summary>
Set the given element of the array
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatArray.sub``1(``0[]`1,System.Int32,System.Int32)">
<summary>
Build a new .NET compatible array that contains the given subrange specified by
starting index and length 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatArray.to_array``1(``0[]`1)">
<summary>
Build an F# array from the given .NET compatible array.  Note that F# arrays and .NET
compatible arrays are only different types when using .NET 1.0 or 1.1
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatArray.to_list``1(``0[]`1)">
<summary>
Convert the given .NET compatible array to a list
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatArray.zero_create``1(System.Int32)">
<summary>
Create a new array filled with zero (null or default) values.  Warning: Use of this
function may result in subsequent exceptions if the elements of the array
are accessed before initialized.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.CompatArray">
<summary>
 Operations to manipulate .NET-compatible arrays, only really necessary
 use when using .NET 1.x.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatMatrix.create``1(System.Int32,System.Int32,``0)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatMatrix.get``1(``0[,]`1,System.Int32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatMatrix.init``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0}})">

</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatMatrix.iter``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},``0[,]`1)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatMatrix.iteri``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit}}},``0[,]`1)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatMatrix.length1``1(``0[,]`1)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatMatrix.length2``1(``0[,]`1)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatMatrix.make``1(System.Int32,System.Int32,``0)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatMatrix.map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0[,]`1)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatMatrix.mapi``2(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,``1}}},``0[,]`1)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatMatrix.set``1(``0[,]`1,System.Int32,System.Int32,``0)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.CompatMatrix.zero_create``1(System.Int32,System.Int32)">

</member>
<member name="T:Microsoft.FSharp.Compatibility.CompatMatrix">
<summary>
 Pseudo-polymorphic 2-dimensional arrays.  Only really used when working with .NET 1.x.

 For any particular 'a , the "'a[,]" type is type-compatible with 
 the corresponding C# 2-dimensional array type. The module contains
 operations to manipulate these values.  The operations may be used 
 on any version of the .NET CLR.  See the 'Advanced' section of 
 the manual for when 'Compatibility' array operations are needed to write
 code that will function on any version of the CLR.

 <example>
 See the sample fsharp/Automation/Excel for an example of passing one of
 these values to fill in the cells of an Excel spreadsheet.
 </example>
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.MATLAB.diagn``1(Microsoft.FSharp.Math.Vector`1{``0},System.Int32)">
<summary>
 Create a matrix containing the given vector along the nth diagonal.
 The 0th index is the main diagonal, and higher indexes are further to the upper-right of the matrix.
 The element type of the matrix must have an associated instance of INumeric&lt;'a&gt; (see [[GlobalAssociations]]) (else InvalidArgumentException).
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.MATLAB.tril``1(Microsoft.FSharp.Math.Matrix`1{``0})">
<summary>
 The lower triangular part of a matrix including the main diagonal
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.MATLAB.triln``1(Microsoft.FSharp.Math.Matrix`1{``0},System.Int32)">
<summary>
 The lower triangular part of a matrix.  Positive offsets indicate further into upper
 upper-right triangular region.  The 0th index inculdes the main diagonal.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.MATLAB.triu``1(Microsoft.FSharp.Math.Matrix`1{``0})">
<summary>
 The upper triangular part of a matrix including the main diagonal
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.MATLAB.triun``1(Microsoft.FSharp.Math.Matrix`1{``0},System.Int32)">
<summary>
 The upper triangular part of a matrix.  Positive offsets indicate further into upper
 upper-right triangular region.  The 0th index inculdes the main diagonal.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.MATLAB">
<summary>
 Functions to make F# math-related code look a bit like MATLAB (TM) code.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.AsyncGroup..ctor">

</member>
<member name="M:Microsoft.FSharp.Control.AsyncGroup.TriggerCancel(Microsoft.FSharp.Core.Option`1{System.String})">
<summary>
 Raise the cancellation condition for this group of computationes
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.AsyncGroup">

</member>
<member name="M:Microsoft.FSharp.Control.AsyncWorker`1..ctor(Microsoft.FSharp.Control.Async`1{``0},Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Control.AsyncGroup})">

</member>
<member name="M:Microsoft.FSharp.Control.AsyncWorker`1.CancelAsync(Microsoft.FSharp.Core.Option`1{System.String})">

</member>
<member name="M:Microsoft.FSharp.Control.AsyncWorker`1.ReportProgress(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Control.AsyncWorker`1.RunAsync">

</member>
<member name="P:Microsoft.FSharp.Control.AsyncWorker`1.Canceled">

</member>
<member name="P:Microsoft.FSharp.Control.AsyncWorker`1.Completed">

</member>
<member name="P:Microsoft.FSharp.Control.AsyncWorker`1.Error">

</member>
<member name="P:Microsoft.FSharp.Control.AsyncWorker`1.ProgressChanged">

</member>
<member name="T:Microsoft.FSharp.Control.AsyncWorker`1">

</member>
<member name="M:Microsoft.FSharp.Control.Async`1.Bind``2(Microsoft.FSharp.Control.Async`1{``1})">
<summary>
 Bind p f generates an asynchronous computation that, when run, runs 'p', and when p generates a result 'res', runs 'f res'.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async`1.CancelCheck">
<summary>
 "CancelCheck" generates an asynchronous computation that checks if the cancellation condition for the AsyncGroup to which this
 Async computation belongs has been set
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async`1.CancelDefaultGroup(Microsoft.FSharp.Core.Option`1{System.String})">
<summary>
 Raise the cancellation condition for the most recent set of Async computations started without any specific AsyncGroup.
 Replace the global group with a new global group for any async computations created after this point without 
 any specific AsyncGroup.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async`1.Catch``1(Microsoft.FSharp.Control.Async`1{``1})">
<summary>
 "Catch(p)" generates an asynchronous computation that, when run, runs the asynchronous computation given as an argument and returns its result
 as a Choice2_1 value. If an exception happens the exception is returned as a Choice2_2(exn) value.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async`1.Delay``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Control.Async`1{``1}})">
<summary>
 "Delay f" generates an asynchronous computation that, when run, runs the asynchronous computation "f x"
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async`1.Future``1(Microsoft.FSharp.Control.Async`1{``1},Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Control.AsyncGroup})">
<summary>
 Start the asynchronous computation in the .NET thread pool, initially as a CPU-intensive worker item. 
 Return a handle to the computation as an Future.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async`1.Generate``1(System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Control.Async`1{``1}},Microsoft.FSharp.Core.Option`1{System.Int32})">
<summary>
 Generate asynchronous computations for indexes 0..N-1. Do so in the indicated number of parallel groups, which 
 defaults to the physical processor count on the machine. If any raise an exception attempt to cancel the others.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async`1.Ignore``1(Microsoft.FSharp.Control.Async`1{``1})">

</member>
<member name="M:Microsoft.FSharp.Control.Async`1.OnCancel``1(Microsoft.FSharp.Core.FastFunc`2{System.String,Microsoft.FSharp.Core.Unit})">
<summary>
 "OnCancel f p" generates an asynchronous computation where, if a cancellation happens any time during the execution of 'p'
 then action 'f' is executed on the thread that is performing the cancellation. You can use
 this to arrange for your own computation to be asynchronously notified that a cancellation has occurred, e.g.
 by setting a flag, or deregistering a pending I/O action.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async`1.Parallel``2(``1)">
<summary>
 Execute all the asynchronous computations in the thread pool, without blocking the current thread.
 If any raise an exception then the overall computation will raise an exception, and attempt to cancel the others.
 All the sub-computations belong to an AsyncGroup that is a subsidiary of the AsyncGroup of the outer computations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async`1.Primitive``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Tuple`2{Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FastFunc`2{System.Exception,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.Unit})">

</member>
<member name="M:Microsoft.FSharp.Control.Async`1.Raise``2(``1)">
<summary>
 "Raise exn" generates an asynchronous computation that, when run terminates by raising the given exception, i.e. the given exception
 is passed to the exception continuation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async`1.Return``1(``1)">
<summary>
 "Return x" generates an asynchronous computation that, when run, yields the value "x" immediately
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async`1.Run``1(Microsoft.FSharp.Control.Async`1{``1},Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Control.AsyncGroup})">
<summary>
 Run the asynchronous computation and await its result.

 If an exception occurs in the asynchronous computation then an exception is raised by calling this
 function.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async`1.Spawn(Microsoft.FSharp.Control.Async`1{Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Control.AsyncGroup})">
<summary>
 Start the asynchronous computation in the thread pool. Do not await its result.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async`1.SpawnChild(Microsoft.FSharp.Control.Async`1{Microsoft.FSharp.Core.Unit})">
<summary>
 Start the asynchronous computation in the thread pool, and add it to the AsyncGroup of 
 of the asynchronous computation. Do not await its result. Exceptions in the asynchronous 
 computation are currently ignored.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async`1.SpawnThenPostBack``1(Microsoft.FSharp.Control.Async`1{``1},Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Control.AsyncGroup})">
<summary>
 Start the asynchronous computation in the thread pool. When the result is available 
 execute the given postBack in the synchronization context of the thread that originally called Run.
 This will frequently be the GUI thread, and in that case the postBack will be executed by sending a 'BeginInvoke' to the
 GUI message loop. 

 If an exception occurs in the asynchronous computation then it is posted as a 
 function that raises an exception in the synchronization context of the thread that originally called RunThenPostBack. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async`1.SwitchToNewThread">
<summary>
 'SwitchToNewThread' create an asynchronous computation that, when run, creates a brand new thread and runs
 its continutation in that thread
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async`1.SwitchToThreadPool">
<summary>
 'SwitchToThreadPool p' create an asynchronous computation that, when run, queues a CPU-intensive work item that runs
 its continutation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async`1.TryFinally``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 "TryFinally f p" generates an asynchronous computation that runs the asynchronous computation 'p'. The action 'f' is executed as the asynchronous computation yields its result
 or if the asynchronous computation exits by an exception or by cancellation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async`1.UnblockedPrimitive``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``1})">
<summary>
 Run a primitive blocking operation on a brand new thread. Execute the continuation as a worker
 item in the thread pool.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Async`1.Using``2(``1)">
<summary>
 "Using r p" runs the asynchronous computation p(r). The action 'r.Dispose()' is executed as the asynchronous computation yields its result
 or if the asynchronous computation exits by an exception or by cancellation.
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.Async`1.Done">
<summary>
 "Done" generates an asynchronous computation that, when run, yields the value 'unit' immediately
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.Async`1">
<summary>
 A computation, which, when run, will eventually produce a value of the given type, or else
 raise an exception. The value and/or exception is not returned to the caller immediately, but
 is rather passed to a continuation or exception continuation.

 Async computations can be specified using the F# 'workflow' syntax for building computations.

 Operationally, async computations typically run partly in the .NET Thread Pool via ThreadPool.QueueUserWorkItem, 
 and, when waiting for asynchronous I/O, they are suspended as thunks using ThreadPool.RegisterWaitForSingleObject,
 waiting for the I/O completion. 

 Some primitive asynchronous computations necessarily end up executing blocking operations:
 these should be run on a pool of threads specifically dedicated to resolving blocking conditions,
 via UnblockedPrimitive. For example, FileOpen on Windows is, by design, a blocking operation.
 However frequently it is important to code as if this is asynchronous. This can be done by running the
 blocking operation via UnblockedPrimitive.

 When run, async computations belong to an AsyncGroup. This can usually be specified when the async computation
 is started. The only action on an AsyncGroup is to raise a cancellation condition for the AsyncGroup.
 Async values check the cancellation condition for their AsyncGroup regularly, though synchronous computations
 within an asynchronous computation will not automatically check this condition. This gives a user-level
 cooperative cancellation protocol.
 If no AsyncGroup is specified when starting the 
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.Future`1.AsIAsyncResult">

</member>
<member name="P:Microsoft.FSharp.Control.Future`1.Value">

</member>
<member name="T:Microsoft.FSharp.Control.Future`1">

</member>
<member name="M:Microsoft.FSharp.Control.Handler`1.Invoke(System.Object,``0)">

</member>
<member name="T:Microsoft.FSharp.Control.Handler`1">
<summary>
 Fresh .NET-compatible events declared in F# are typically 
 values of type IHandlerEvent&lt;'a&gt;. These 
 hold event handlers of type Handler&lt;'a&gt;. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.IChannel`1.Post(``0)">

</member>
<member name="T:Microsoft.FSharp.Control.IChannel`1">

</member>
<member name="T:Microsoft.FSharp.Control.ICompatEvent`1">

</member>
<member name="T:Microsoft.FSharp.Control.IDelegateEvent`2">
<summary>
 .NET events are revealed to F# code as instances of the type IDelegateEvent,
 which is a subtype of the type [IEvent]. The delegate type parameter and 
 arguments are determined by the F# type checker based on information stored
 for the .NET event.

 F# code may also declare .NET events over any .NET delegate type.
 For example, DelegateEvent&lt;PaintEventHandler,PaintEventArgs&gt; 
 can be used for an event whose callbacks are of type PaintEventHandler.  The delegate
 and argument types must match.

</summary>
</member>
<member name="M:Microsoft.FSharp.Control.IEvent`1.Add(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit})">
<summary>
 Connect a listener function to the event. The listener will
 be invoked when the event is fired.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.IEvent`1">
<summary>
 First-class listening points (i.e. objects that permit you to register a 'callback'
 activated when the event is triggered). See the module <tt>IEvent</tt>
 for functions to create events, and the type <tt>IDelegateEvent</tt>
 which extends this type.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.IHandlerEvent`1">
<summary>
 Any instance property that has type ICompatEvent will be published as a standard 
 .NET event using standard .NET delegates and metadata, and will 
 be recognized as an event by any language that supports the 
 CLI Common Language Specification. The event will accept 
 handlers of type Handler*lt;'a&gt;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.IPrimitiveDelegateEvent`1.AddHandler(``0)">
<summary>
 Connect a handler delegate object to the event.  A handler can
 be later removed using RemoveHandler.  The listener will
 be invoked when the event is fired.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.IPrimitiveDelegateEvent`1.RemoveHandler(``0)">
<summary>
 Remove a listener delegate from an event listener store
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.IPrimitiveDelegateEvent`1">
<summary>
 F# gives special status to non-virtual instance member properties compatible with type IPrimitiveDelegateEvent, 
 generating approriate .NET metadata to make the member appear to other .NET languages as a
 .NET event.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Lazy`1.Create(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 The module 'Lazy' contains additional values and functions related to this type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Lazy`1.Force">
<summary>
 Force the execution of this value and return its result. Same as Value.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Lazy`1.SynchronizedForce">
<summary>
 Force the execution of this value and return its result, using mutual exclusion to 
 prevent other threads also computing the value.
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.Lazy`1.IsDelayed">
<summary>
 The module 'Lazy' contains additional values and functions related to this type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.Lazy`1.IsException">
<summary>
 The module 'Lazy' contains additional values and functions related to this type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.Lazy`1.IsForced">
<summary>
 The module 'Lazy' contains additional values and functions related to this type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.Lazy`1.Value">
<summary>
 Force the execution of this value and return its result. Same as Value.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.Lazy`1">
<summary>
 The type of delayed computations.
 
 Use the values in the [[Lazy]] module to manipulate 
 values of this type, and the notation 'lazy expr' to create values
 of this type.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.lazy`1">

</member>
<member name="T:Microsoft.FSharp.Control.UndefinedException">

</member>
<member name="M:Microsoft.FSharp.Control.Async.AsyncBuilder.Bind``2(Microsoft.FSharp.Control.Async`1{``0},Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Control.Async`1{``1}})">

</member>
<member name="M:Microsoft.FSharp.Control.Async.AsyncBuilder.BindUsing``2(Microsoft.FSharp.Control.Async`1{``0},Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Control.Async`1{``1}})">

</member>
<member name="M:Microsoft.FSharp.Control.Async.AsyncBuilder.Combine``1(Microsoft.FSharp.Control.Async`1{Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Control.Async`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Control.Async.AsyncBuilder.Delay``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Control.Async`1{``0}})">

</member>
<member name="M:Microsoft.FSharp.Control.Async.AsyncBuilder.For``2(``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Control.Async`1{Microsoft.FSharp.Core.Unit}})">

</member>
<member name="M:Microsoft.FSharp.Control.Async.AsyncBuilder.Let``2(``0,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Control.Async`1{``1}})">

</member>
<member name="M:Microsoft.FSharp.Control.Async.AsyncBuilder.Return``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Control.Async.AsyncBuilder.TryFinally``1(Microsoft.FSharp.Control.Async`1{``0},Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">

</member>
<member name="M:Microsoft.FSharp.Control.Async.AsyncBuilder.Using``2(``0,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Control.Async`1{``1}})">

</member>
<member name="M:Microsoft.FSharp.Control.Async.AsyncBuilder.While(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,System.Boolean},Microsoft.FSharp.Control.Async`1{Microsoft.FSharp.Core.Unit})">

</member>
<member name="M:Microsoft.FSharp.Control.Async.AsyncBuilder.Zero">

</member>
<member name="T:Microsoft.FSharp.Control.Async.AsyncBuilder">

</member>
<member name="P:Microsoft.FSharp.Control.Async.async">

</member>
<member name="T:Microsoft.FSharp.Control.Async">

</member>
<member name="T:Microsoft.FSharp.Control.CommonExtensions">

</member>
<member name="M:Microsoft.FSharp.Control.IEvent.choose``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},``2)">
<summary>
Return a new event which fires on a selection of messages from the original event.
The selection function takes an original message to an optional new message.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.IEvent.create``1">
<summary>
 Create an IEvent with no initial listeners. Two items are returned: 
 a function to invoke (trigger) the event, and the event that clients 
 can plug listeners into.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.IEvent.create1``1">
<summary>
 Create an IEvent with no initial listeners and at most one active listener. Adding extra
 listeners causes subsequent listeners to be dropped. Two items are returned: 
 a function to invoke (trigger) the event, and the event that clients 
 can plug listeners into.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.IEvent.createCompat``1">

</member>
<member name="M:Microsoft.FSharp.Control.IEvent.create_DelegateEvent``1">
<summary>
 Create an event that is to be published as standard .NET event using .NET
 delegates and metadata, and which will be recognized as an event by 
 any language that supports the CLI Common Language Specification. Two items
 are returned: a function to invoke (trigger) the event, and the event itself.
 The event value should be published as a public instance property in order for it to be 
 published as a standard .NET event.

 This function creates event of any .NET EventHandler type (inherited from System.Delegate)
 and will be exported as event of that type. Function used to invoke the event accepts
 arguments as a list of objects and the event is invoked dynamically. When possible
 use 'create_HandlerEvent'. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.IEvent.create_HandlerEvent``2">
<summary>
 Create an event that is to be published as a standard .NET event using  .NET
 delegates and metadata, and which will be recognized as an event by 
 any language that supports the CLI Common Language Specification. Two items
 are returned: a function to invoke (trigger) the event, and the event itself.
 The event value should be published as a public instance property in order for it to be 
 published as a standard .NET event.

 When firing the event the "sender" of the event must be specified, e.g. the form
 or control firing the event. This parameter is not normally of use for F# events,
 but is used by some other .NET event consumers. The sender is passed to 
 the handler implementation as type 'object'
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.IEvent.create_public``2">

</member>
<member name="M:Microsoft.FSharp.Control.IEvent.filter``2(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``1)">
<summary>
Return a new event that listens to the original event and triggers the resulting
event only when the argument to the event passes the given function
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.IEvent.fold``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,``2)">
<summary>
Return a new event consisting of the results of applying the given accumulating function
to successive values triggered on the input event.  An item of internal state
records the current value of the state parameter.  The internal state is not locked during the
execution of the accumulation function, so care should be taken that the 
input IEvent not triggered by multiple threads simultaneously.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.IEvent.fold_and_emit``4(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Tuple`2{``0,``2}}},``0,``3)">
<summary>
Return a new event consisting of the observed results of applying the given accumulating function
to successive values triggered on the input event.  The observed results are the
second items in the pairs returned.  An item of internal state
records the current value of the state parameter.  The internal state is not locked during the
execution of the accumulation function, so care should be taken that the 
input IEvent not triggered by multiple threads simultaneously.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.IEvent.listen``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},``1)">
<summary>
Run the given function each time the given event is triggered.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.IEvent.map``3(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``2)">
<summary>
Return a new event that passes values transformed by the given function
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.IEvent.merge``3(``0,``2)">
<summary>
Fire the output event when either of the input events fire
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.IEvent.pairwise``2(``0)">
<summary>
Return a new event that triggers on the second and subsequent triggerings of the input event.
The Nth triggering of the input event passes the arguments from the N-1th and Nth triggering as
a pair. The argument passed to the N-1th triggering is held in hidden internal state until the 
Nth triggering occurs.

You should ensure that the contents of the values being sent down the event are
not mutable. Note that many EventArgs types are mutable, e.g. MouseEventArgs, and
each firing of an event using this argument type may reuse the same physical 
argument obejct with different values. In this case you should extract the necessary
information from the argument before using this combinator.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.IEvent.partition``2(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},``1)">
<summary>
Return a new event that listens to the original event and triggers the 
first resulting event if the application of the predicate to the event arguments
returned true, and the second event if it returned false
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.IEvent.split``4(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Choice`2{``1,``2}},``3)">
<summary>
Return a new event that listens to the original event and triggers the 
first resulting event if the application of the function to the event arguments
returned a Choice2_1, and the second event if it returns a Choice2_2
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.IEvent">
<summary>
 Basic operations on IEvents.  
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.Lazy.t`1">

</member>
<member name="M:Microsoft.FSharp.Control.Lazy.force``1(Microsoft.FSharp.Control.Lazy`1{``0})">
<summary>
Force the computation of the given lazy value if not already forced.
Raises an exception if the computation raises (or previously raised) an exception.
Raises Undefined if executingg the computation recursively forces the
evaluation of the computation.
Concurrency: This function does not take a lock while forcing execution
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Lazy.force_val``1(Microsoft.FSharp.Control.Lazy`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Control.Lazy.force_with_lock``1(Microsoft.FSharp.Control.Lazy`1{``0})">
<summary>
Like force, but this function uses the thunks itselfs as a lock while forcing execution
If you have multiple threads and your lazy values can be 
accessed via multiple threads then you should 
consider using force_with_lock.  If you do not the lazy computations 
may be executed multiple times, and the values produced by some of the 
computations will be discarded. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Lazy.force_without_lock``1(Microsoft.FSharp.Control.Lazy`1{``0})">
<summary>
Equivalent to force
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Lazy.lazy_from_fun``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``0})">
<summary>
Build a lazy (delayed) value from the given computation
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Lazy.lazy_from_val``1(``0)">
<summary>
Build a lazy (delayed) value from the given pre-computed value.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Lazy.lazy_is_val``1(Microsoft.FSharp.Control.Lazy`1{``0})">
<summary>
Check if a lazy (delayed) value has already been computed
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Lazy.|Lazy|``1(Microsoft.FSharp.Control.Lazy`1{``0})">

</member>
<member name="T:Microsoft.FSharp.Control.Lazy.UndefinedException">

</member>
<member name="T:Microsoft.FSharp.Control.Lazy">
<summary>
 Delayed computations.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.LazyStatus.LazyStatus`1">
<summary>
 This exception is raised when a lazy or other recursively referential value
 is used during the execution of its initialization code 
 The status of a lazy computation.  A future relases of F# may hid this type and thus it should not be used
 directly.
</summary>
</member>
<member name="T:Microsoft.FSharp.Control.LazyStatus">

</member>
<member name="M:Microsoft.FSharp.Control.Mailboxes.MailboxProcessor`1.Create(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Control.Mailboxes.MailboxProcessor`1{``0},Microsoft.FSharp.Control.Async`1{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Control.AsyncGroup})">

</member>
<member name="M:Microsoft.FSharp.Control.Mailboxes.MailboxProcessor`1.Post(``0)">

</member>
<member name="M:Microsoft.FSharp.Control.Mailboxes.MailboxProcessor`1.PostSync``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Control.IChannel`1{``1},``0},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Boolean})">

</member>
<member name="M:Microsoft.FSharp.Control.Mailboxes.MailboxProcessor`1.Receive(Microsoft.FSharp.Core.Option`1{System.Int32})">
<summary>
 Return an asynchronous computation which will 
 consume the first message in arrival order. No thread
 is blocked while waiting for further messages. Raise a TimeoutException
 if the timeout is exceeded.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Mailboxes.MailboxProcessor`1.Scan``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Control.Async`1{``1}}},Microsoft.FSharp.Core.Option`1{System.Int32})">
<summary>
 Return an asynchronous computation which will 
 look through messages in arrival order until 'scanner' returns a Some value. No thread
 is blocked while waiting for further messages. Raise a TimeoutException
 if the timeout is exceeded.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Mailboxes.MailboxProcessor`1.Start(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Control.Mailboxes.MailboxProcessor`1{``0},Microsoft.FSharp.Control.Async`1{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Control.AsyncGroup})">

</member>
<member name="M:Microsoft.FSharp.Control.Mailboxes.MailboxProcessor`1.Start">
<summary>
 Start the MailboxProcessor
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Mailboxes.MailboxProcessor`1.TryReceive(Microsoft.FSharp.Core.Option`1{System.Int32})">
<summary>
 Return an asynchronous computation which will 
 consume the first message in arrival order. No thread
 is blocked while waiting for further messages. Return None
 if the timeout is exceeded.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.Mailboxes.MailboxProcessor`1.TryScan``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Control.Async`1{``1}}},Microsoft.FSharp.Core.Option`1{System.Int32})">
<summary>
 Return an asynchronous computation which will 
 look through messages in arrival order until 'scanner' returns a Some value. No thread
 is blocked while waiting for further messages. Return None
 if the timeout is exceeded.
</summary>
</member>
<member name="P:Microsoft.FSharp.Control.Mailboxes.MailboxProcessor`1.DefaultTimeout">

</member>
<member name="P:Microsoft.FSharp.Control.Mailboxes.MailboxProcessor`1.UnsafeMessageQueueContents">

</member>
<member name="P:Microsoft.FSharp.Control.Mailboxes.MailboxProcessor`1.DefaultTimeout(System.Int32)">

</member>
<member name="T:Microsoft.FSharp.Control.Mailboxes.MailboxProcessor`1">
<summary>
 A MailboxProcessor is an asynchronous computation that includes the ability to read from a single dedicated
 channel (i.e. a single dedicated message queue). Anyone can send messages to a MailboxProcessor by using the Post method.
 A MailboxProcessor enters a state where it waits for the next message by calling its own Receive or TryReceive method.

 A MailboxProcessor can scan through all available messages using its own Scan or TryScan method, 
 by using a function that selects an asynchronous computation to 
 run based on a scan of the message queue. 

 A MailboxProcessor is usually declared as a recursive object because it generally needs to use one or more of its 
 own Receive, TryReceive, Scan or TryScan methods. It also often has to publish the ability for other asynchronous 
 computations to send messages back to the MailboxProcessor.
</summary>
</member>
<member name="M:Microsoft.FSharp.Control.SharedMemory.Helpers.readLock``1(System.Threading.ReaderWriterLock,Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``0})">

</member>
<member name="M:Microsoft.FSharp.Control.SharedMemory.Helpers.writeLock``1(System.Threading.ReaderWriterLock,Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``0})">

</member>
<member name="T:Microsoft.FSharp.Control.SharedMemory.Helpers">

</member>
<member name="T:Microsoft.FSharp.Core.Choice`2">

</member>
<member name="T:Microsoft.FSharp.Core.Choice`3">

</member>
<member name="T:Microsoft.FSharp.Core.Choice`4">

</member>
<member name="T:Microsoft.FSharp.Core.Choice`5">

</member>
<member name="T:Microsoft.FSharp.Core.Choice`6">

</member>
<member name="T:Microsoft.FSharp.Core.Choice`7">

</member>
<member name="M:Microsoft.FSharp.Core.ClassAttribute..ctor">

</member>
<member name="T:Microsoft.FSharp.Core.ClassAttribute">
<summary>
 Adding this attribute to a type causes it to be represented using a .NET class.
 This may only be used under very limited conditions.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilationMappingAttribute..ctor(Microsoft.FSharp.Core.SourceLevelConstruct)">

</member>
<member name="M:Microsoft.FSharp.Core.CompilationMappingAttribute..ctor(Microsoft.FSharp.Core.SourceLevelConstruct,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.CompilationMappingAttribute..ctor(Microsoft.FSharp.Core.SourceLevelConstruct,System.Int32,System.Int32)">

</member>
<member name="P:Microsoft.FSharp.Core.CompilationMappingAttribute.SequenceNumber">

</member>
<member name="P:Microsoft.FSharp.Core.CompilationMappingAttribute.SourceConstruct">

</member>
<member name="P:Microsoft.FSharp.Core.CompilationMappingAttribute.VariantNumber">

</member>
<member name="T:Microsoft.FSharp.Core.CompilationMappingAttribute">
<summary>
 This attribute is used to tag generated types and methods in the 
 compiled .NET code with flags indicating the correspondence with
 original source constructs.  It is used by the functions in the
 Microsoft.FSharp.Reflection library to reverse-map compiled constructs
 to their original forms.  It is not intended for use from use code.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.CompilationRepresentationAttribute..ctor(Microsoft.FSharp.Core.CompilationRepresentationFlags)">

</member>
<member name="P:Microsoft.FSharp.Core.CompilationRepresentationAttribute.Flags">

</member>
<member name="T:Microsoft.FSharp.Core.CompilationRepresentationAttribute">
<summary>
 This attribute is used to tag types that the 'null' representation
 may be used for the type.  This affects how some constructs are compiled.
 You may need to add this attribute to some of your types if F# indicates
 that null may be used as a valid representation for some values your type
 and you have made the type abstract in a signature. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.CompilationRepresentationFlags">

</member>
<member name="M:Microsoft.FSharp.Core.DefaultAugmentationAttribute..ctor(System.Boolean)">

</member>
<member name="P:Microsoft.FSharp.Core.DefaultAugmentationAttribute.v">

</member>
<member name="T:Microsoft.FSharp.Core.DefaultAugmentationAttribute">
<summary>
 Adding this attribute to a discriminated union with value false
 turns off the generation of standard helper member tester, constructor 
 and accessor members for the generated .NET class for that type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ExperimentalAttribute..ctor(System.String)">

</member>
<member name="P:Microsoft.FSharp.Core.ExperimentalAttribute.Message">

</member>
<member name="T:Microsoft.FSharp.Core.ExperimentalAttribute">
<summary>
 This attribute is used to tag values that are part of an experimental library
 feature
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute..ctor(System.Int32,System.Int32,System.Int32)">

</member>
<member name="P:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute.v1">

</member>
<member name="P:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute.v2">

</member>
<member name="P:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute.v3">

</member>
<member name="T:Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute">
<summary>
 This attribute is added to generated assemblies to indicate the 
 version of the data schema used to encode additional F#
 specific information in the resource attached to compiled F# libraries.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FastFunc`2..ctor">

</member>
<member name="M:Microsoft.FSharp.Core.FastFunc`2.Invoke(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.FastFunc`2.InvokeFast2``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``2}},``0,``1)">

</member>
<member name="M:Microsoft.FSharp.Core.FastFunc`2.InvokeFast3``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``3}}},``0,``1,``2)">

</member>
<member name="M:Microsoft.FSharp.Core.FastFunc`2.InvokeFast4``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,Microsoft.FSharp.Core.FastFunc`2{``3,``4}}}},``0,``1,``2,``3)">

</member>
<member name="M:Microsoft.FSharp.Core.FastFunc`2.InvokeFast5``4(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,Microsoft.FSharp.Core.FastFunc`2{``3,Microsoft.FSharp.Core.FastFunc`2{``4,``5}}}}},``0,``1,``2,``3,``4)">

</member>
<member name="M:Microsoft.FSharp.Core.FastFunc`2.op_Implicit(Microsoft.FSharp.Core.FastFunc`2{``0,``1})">

</member>
<member name="M:Microsoft.FSharp.Core.FastFunc`2.op_Implicit(System.Converter`2{``0,``1})">

</member>
<member name="T:Microsoft.FSharp.Core.FastFunc`2">
<summary>
 The .NET type used to represent F# function values.  This type is not
 typically used directly from F# code, though may be used from other .NET languages.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FuncFromTupled``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1})">

</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FuncFromTupled``3(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Tuple`2{``0,``1},``2})">

</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FuncFromTupled``4(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Tuple`3{``0,``1,``2},``3})">

</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FuncFromTupled``5(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Tuple`4{``0,``1,``2,``3},``4})">

</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.FuncFromTupled``6(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Tuple`5{``0,``1,``2,``3,``4},``5})">

</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.ToFastFunc``1(System.Action`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.ToFastFunc``2(System.Converter`2{``0,``1})">

</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.ToFastFunc``2(System.Action`2{``0,``1})">

</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.ToFastFunc``3(System.Converter`3{``0,``1,``2})">

</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.ToFastFunc``3(System.Action`3{``0,``1,``2})">

</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.ToFastFunc``4(System.Converter`4{``0,``1,``2,``3})">

</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.ToTupledFastFunc``2(System.Action`2{``0,``1})">

</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.ToTupledFastFunc``3(System.Converter`3{``0,``1,``2})">

</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.ToTupledFastFunc``3(System.Action`3{``0,``1,``2})">

</member>
<member name="M:Microsoft.FSharp.Core.FuncConvert.ToTupledFastFunc``4(System.Converter`4{``0,``1,``2,``3})">

</member>
<member name="T:Microsoft.FSharp.Core.FuncConvert">

</member>
<member name="P:Microsoft.FSharp.Core.IRange`1.Finish">

</member>
<member name="P:Microsoft.FSharp.Core.IRange`1.Start">

</member>
<member name="P:Microsoft.FSharp.Core.IRange`1.Step">

</member>
<member name="T:Microsoft.FSharp.Core.IRange`1">

</member>
<member name="M:Microsoft.FSharp.Core.IStructuralHash.GetStructuralHashCode(Microsoft.FSharp.Core.byref`1{System.Int32})">

</member>
<member name="T:Microsoft.FSharp.Core.IStructuralHash">
<summary>
 F# structural types such as tuples, records and discriminated unions
 support a form of cooperative structural hashing, via implementations
 of interface IStructuralHash. Implmentations of this interface are added
 to concrete types (records, discriminated unions and classes) automatically,
 though types can also define their own implementations of this interface, 
 thus altering the hashing semantics of the type.  

 The byref argument points to a count of the
 number of significant nodes remaining to be hashed in the cooperative hash.
 Substructures and leaf nodes (such as integers) should be hashed by calling 
 Microsoft.FSharp.Core.LanguagePrimitives.StructuralHashParam, but only if the hash count
 is non-zero.  If the hash count is zero StructuralHashParam must not be called.

 Structural comparison is supported via a similar scheme, using implementations
 of the System.IComparable interface.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.InterfaceAttribute..ctor">

</member>
<member name="T:Microsoft.FSharp.Core.InterfaceAttribute">
<summary>
 Adding this attribute to a type causes it to be represented using a .NET interface.
 This may only be used under very limited conditions.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OCamlCompatibilityAttribute..ctor">

</member>
<member name="M:Microsoft.FSharp.Core.OCamlCompatibilityAttribute..ctor(System.String)">

</member>
<member name="T:Microsoft.FSharp.Core.OCamlCompatibilityAttribute">
<summary>
 This attribute is used to tag values, modules and types that are only
 present in F# to permit a degree of code-compatibility and cross-compilation
 with other implementations of ML-familty languages, in particular OCaml. The
 use of the construct will give a warning unless the --ml-compatibility flag
 is specified.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Option`1.Some(``0)">
<summary>
 Create an option value that is a 'Some' value.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Option`1.IsNone">
<summary>
 Return 'true' if the option is a 'None' value.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Option`1.IsSome">
<summary>
 Return 'true' if the option is a 'Some' value.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Option`1.Item">

</member>
<member name="P:Microsoft.FSharp.Core.Option`1.None">

</member>
<member name="P:Microsoft.FSharp.Core.Option`1.Value">
<summary>
 Get the value of a 'Some' option. A NullReferenceException is raised if the option is 'None'.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Option`1">
 <summary>
 The type of optional values.  When used from other .NET languages the
 empty option is the 'null' value.  

 Use the constructors [[Some]] and [[None]] to create values of this type.
 Use the values in the [[Option]] module to manipulate values of this type,
 or pattern match against the values directly.
 </summary>

 <note>'None' values will appear as the value 'null' to other .NET languages.
 Instance methods on this type will appear as static methods to other .NET languages
 due to the use of 'null' as a value representation.
 </note>
</member>
<member name="M:Microsoft.FSharp.Core.OptionalArgumentAttribute..ctor">

</member>
<member name="T:Microsoft.FSharp.Core.OptionalArgumentAttribute">
<summary>
 This attribute is added automatically for all optional arguments
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OverloadIDAttribute..ctor(System.String)">

</member>
<member name="P:Microsoft.FSharp.Core.OverloadIDAttribute.v">

</member>
<member name="T:Microsoft.FSharp.Core.OverloadIDAttribute">
<summary>
 Adding the OverloadID attribute to a member permits it to
 be part of a group overloaded by the same name and arity.  The string
 must be a unique name amongst those in the overload set.  Overrides
 of this method, if permitted, must be given the same OverloadID,
 and the OverloadID must be specified in both signature and implementation
 files if signature files are used.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Ref`1.Pin``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.nativeptr`1{``0},``1})">
<summary>
 For native interop. Pin the given object for the duration of a single call to the given function.  A native pointer to
 the (0,0) element in the underlying array is passed to the given function.  Resources associated with the 
 pin are released when the function completes, even if an exception is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Ref`1.PinHandle">
<summary>
 For native interop. Pin the given object, but the caller is responsible for freeing the GCHandle
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Ref`1.Value">
<summary>
 The current value of the reference cell
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Ref`1.Value(``0)">
<summary>
 The current value of the reference cell
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Ref`1">
<summary>
 The type of mutable references.  Use the functions [:=] and [!] to get and
 set values of this type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.ReflectedDefinitionAttribute..ctor">

</member>
<member name="T:Microsoft.FSharp.Core.ReflectedDefinitionAttribute">
<summary>
 Adding this attribute to the let-binding for the definition of a top-level 
 value makes the quotation expression that implements the value available
 for use at runtime.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.ReifiedType`1">
<summary>
 The result of an F# typeof operation
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.SourceLevelConstruct">

</member>
<member name="M:Microsoft.FSharp.Core.StructAttribute..ctor">

</member>
<member name="T:Microsoft.FSharp.Core.StructAttribute">
<summary>
 Adding this attribute to a type causes it to be represented using a .NET struct.
 This may only be used under very limited conditions.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Tuple`2">
<summary>
 Compiled versions of F# tuple types.  These are not used directly from F# code, though
 these compiled forms are seen by other .NET languages.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Tuple`3">
<summary>
 Compiled versions of F# tuple types.  These are not used directly from F# code, though
 these compiled forms are seen by other .NET languages.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Tuple`4">
<summary>
 Compiled versions of F# tuple types.  These are not used directly from F# code, though
 these compiled forms are seen by other .NET languages.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Tuple`5">
<summary>
 Compiled versions of F# tuple types.  These are not used directly from F# code, though
 these compiled forms are seen by other .NET languages.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Tuple`6">
<summary>
 Compiled versions of F# tuple types.  These are not used directly from F# code, though
 these compiled forms are seen by other .NET languages.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Tuple`7">
<summary>
 Compiled versions of F# tuple types.  These are not used directly from F# code, though
 these compiled forms are seen by other .NET languages.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.TypeFunc..ctor">

</member>
<member name="M:Microsoft.FSharp.Core.TypeFunc.Specialize``1">

</member>
<member name="T:Microsoft.FSharp.Core.TypeFunc">
<summary>
 The .NET type used to represent F# first-class type function values.  This type is not
 typically used directly from F# code.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Unit">
<summary>
 The type 'unit', which has only one value "()".
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.UnverifiableAttribute..ctor">

</member>
<member name="T:Microsoft.FSharp.Core.UnverifiableAttribute">
<summary>
 This attribute is used to tag values whose use will result in the generation
 of unverifiable code. These values are inevitably marked 'inline' to ensure that
 the unverifiable constructs are not present in the actual code for the F# library,
 but are rather copied to the source code of the caller.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.[,,,]`1">
<summary>
 Four dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.[,,]`1">
<summary>
 Three dimensional arrays, typically zero-based. Non-zero-based arrays
 can be created using methods on the System.Array type.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.[,]`1">
<summary>
 Two dimensional arrays, typically zero-based. 

 Use the values in the [[Array2]] module
 to manipulate values of this type, or the notation 'arr.[x,y]' to get/set array
 values.   When using .NET 1.x use the values in the [[CompatArray2]]
 module.

 Non-zero-based arrays can be created using methods on the System.Array type.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.[]`1">
<summary>
 Single dimensional, zero-based arrays, written 'int[]', 'string[]' etc.
 Use the values in the [[Array]] module to manipulate values 
 of this type, or the notation 'arr.[x]' to get/set array
 values.   When using .NET 1.x use the values in the [[CompatArray]]
 module.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.array`1">

</member>
<member name="T:Microsoft.FSharp.Core.bigint">

</member>
<member name="T:Microsoft.FSharp.Core.bignum">

</member>
<member name="T:Microsoft.FSharp.Core.bool">

</member>
<member name="T:Microsoft.FSharp.Core.byref`1">
<summary>
 The type for by-reference, stack-allocated argument passing.  It is used
 by .NET assemblies and by the type [[IStructuralHash]] to
 pass the hash-node-count around.  Use of this type in F# code may result in
 unverifiable code being generated.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.byte">

</member>
<member name="T:Microsoft.FSharp.Core.char">

</member>
<member name="T:Microsoft.FSharp.Core.double">

</member>
<member name="T:Microsoft.FSharp.Core.exn">

</member>
<member name="T:Microsoft.FSharp.Core.float">

</member>
<member name="T:Microsoft.FSharp.Core.float32">

</member>
<member name="T:Microsoft.FSharp.Core.ilsigptr`1">
<summary>
 This type is for internal use by the F# code generator
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.int">

</member>
<member name="T:Microsoft.FSharp.Core.int16">

</member>
<member name="T:Microsoft.FSharp.Core.int32">

</member>
<member name="T:Microsoft.FSharp.Core.int64">

</member>
<member name="T:Microsoft.FSharp.Core.int8">

</member>
<member name="T:Microsoft.FSharp.Core.matrix">
<summary>
 The type of floating-point matrices.  See Microsoft.FSharp.Math
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.nativeint">

</member>
<member name="T:Microsoft.FSharp.Core.nativeptr`1">
<summary>
 The type of machine pointers assumed to be pointing to 
 unmanaged or pinned memory containing values or an array of
 values of the given type.

 This type should only be used when writing F# code that interoperates
 with C code.  Use of this type in F# code may result in
 unverifiable code being generated.  Conversions to and from the 
 [[nativeint]] type may be required. Values of this type can be generated
 by the functions in the NativeInterop.NativePtr module.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.obj">

</member>
<member name="T:Microsoft.FSharp.Core.option`1">

</member>
<member name="T:Microsoft.FSharp.Core.ref`1">

</member>
<member name="T:Microsoft.FSharp.Core.rowvec">
<summary>
 The type of floating-point row vectors.  See Microsoft.FSharp.Math
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.sbyte">

</member>
<member name="T:Microsoft.FSharp.Core.seq`1">

</member>
<member name="T:Microsoft.FSharp.Core.single">

</member>
<member name="T:Microsoft.FSharp.Core.string">

</member>
<member name="T:Microsoft.FSharp.Core.uint16">

</member>
<member name="T:Microsoft.FSharp.Core.uint32">

</member>
<member name="T:Microsoft.FSharp.Core.uint64">

</member>
<member name="T:Microsoft.FSharp.Core.uint8">

</member>
<member name="T:Microsoft.FSharp.Core.unativeint">

</member>
<member name="T:Microsoft.FSharp.Core.unit">

</member>
<member name="T:Microsoft.FSharp.Core.vector">
<summary>
 The type of floating-point vectors.  See Microsoft.FSharp.Math
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.AssertionFailureException">
<summary>
 'assert' is used to check conditions and raise AssertionFailure if necessary
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.FailureException">
<summary>
 This exception is precisely the same as the exception 'Failure' in F# code.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.InvalidArgumentException">
<summary>
 This exception is precisely the same as the exception 'Invalid_argument' in F# code.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.MatchFailureException">
<summary>
 Non-exhaustive match failures will raise Match failures
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Byte.add(System.Byte,System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.Byte.compare(System.Byte,System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.Byte.div(System.Byte,System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.Byte.logand(System.Byte,System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.Byte.lognot(System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.Byte.logor(System.Byte,System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.Byte.logxor(System.Byte,System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.Byte.mul(System.Byte,System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.Byte.of_char(System.Char)">

</member>
<member name="M:Microsoft.FSharp.Core.Byte.of_int(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Byte.of_int32(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Byte.of_string(System.String)">

</member>
<member name="M:Microsoft.FSharp.Core.Byte.of_uint16(System.UInt16)">

</member>
<member name="M:Microsoft.FSharp.Core.Byte.of_uint32(System.UInt32)">

</member>
<member name="P:Microsoft.FSharp.Core.Byte.one">

</member>
<member name="M:Microsoft.FSharp.Core.Byte.pred(System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.Byte.rem(System.Byte,System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.Byte.shift_left(System.Byte,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Byte.shift_right(System.Byte,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Byte.sub(System.Byte,System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.Byte.succ(System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.Byte.to_char(System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.Byte.to_int(System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.Byte.to_int32(System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.Byte.to_string(System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.Byte.to_uint16(System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.Byte.to_uint32(System.Byte)">

</member>
<member name="P:Microsoft.FSharp.Core.Byte.zero">

</member>
<member name="T:Microsoft.FSharp.Core.Byte">
<summary>
 Byte (8-bit) operations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Char.chr(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Char.code(System.Char)">

</member>
<member name="M:Microsoft.FSharp.Core.Char.compare(System.Char,System.Char)">

</member>
<member name="M:Microsoft.FSharp.Core.Char.lowercase(System.Char)">

</member>
<member name="M:Microsoft.FSharp.Core.Char.uppercase(System.Char)">

</member>
<member name="T:Microsoft.FSharp.Core.Char">
<summary>
 Unicode characters, i.e. the [[System.Char]] type.  see also the operations
 in [[System.Char]] and the [[System.Text.Encoding]] interfaces if necessary.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Enum.combine``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Combine enum values using 'logical or'. The relevant enumeration type is inferred from context.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Enum.of_int``1(System.Int32)">
<summary>
Convert an integer to an enumeration value.  The result type is inferred from context.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Enum.test``1(``0,``0)">
<summary>
Test if an enumeration value has a particular flag set, using 'logical and'. 
The relevant enumeration type is inferred from context.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Enum.to_int``1(``0)">
<summary>
Convert an enumeration value to an integer.  The argument type is inferred from context.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Enum">
<summary>
 Simple operations to convert between .NET enuemration types and integers
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Float.add(System.Double,System.Double)">

</member>
<member name="M:Microsoft.FSharp.Core.Float.compare(System.Double,System.Double)">

</member>
<member name="M:Microsoft.FSharp.Core.Float.div(System.Double,System.Double)">

</member>
<member name="M:Microsoft.FSharp.Core.Float.mul(System.Double,System.Double)">

</member>
<member name="M:Microsoft.FSharp.Core.Float.neg(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Core.Float.of_bits(System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Core.Float.of_float32(System.Single)">

</member>
<member name="M:Microsoft.FSharp.Core.Float.of_int(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Float.of_int32(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Float.of_int64(System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Core.Float.of_string(System.String)">

</member>
<member name="M:Microsoft.FSharp.Core.Float.sub(System.Double,System.Double)">

</member>
<member name="M:Microsoft.FSharp.Core.Float.to_bits(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Core.Float.to_float32(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Core.Float.to_int(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Core.Float.to_int32(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Core.Float.to_int64(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Core.Float.to_string(System.Double)">

</member>
<member name="T:Microsoft.FSharp.Core.Float">
<summary>
 ML-like operations on 64-bit System.Double floating point numbers.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Float32.add(System.Single,System.Single)">

</member>
<member name="M:Microsoft.FSharp.Core.Float32.compare(System.Single,System.Single)">

</member>
<member name="M:Microsoft.FSharp.Core.Float32.div(System.Single,System.Single)">

</member>
<member name="M:Microsoft.FSharp.Core.Float32.mul(System.Single,System.Single)">

</member>
<member name="M:Microsoft.FSharp.Core.Float32.neg(System.Single)">

</member>
<member name="M:Microsoft.FSharp.Core.Float32.of_bits(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Float32.of_float(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Core.Float32.of_int(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Float32.of_int32(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Float32.of_int64(System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Core.Float32.of_string(System.String)">

</member>
<member name="M:Microsoft.FSharp.Core.Float32.sub(System.Single,System.Single)">

</member>
<member name="M:Microsoft.FSharp.Core.Float32.to_bits(System.Single)">

</member>
<member name="M:Microsoft.FSharp.Core.Float32.to_float(System.Single)">

</member>
<member name="M:Microsoft.FSharp.Core.Float32.to_int(System.Single)">

</member>
<member name="M:Microsoft.FSharp.Core.Float32.to_int32(System.Single)">

</member>
<member name="M:Microsoft.FSharp.Core.Float32.to_int64(System.Single)">

</member>
<member name="M:Microsoft.FSharp.Core.Float32.to_string(System.Single)">

</member>
<member name="T:Microsoft.FSharp.Core.Float32">
<summary>
 ML-like operations on 32-bit System.Single floating point numbers.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Func.apply``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Func.compose``3(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Core.FastFunc`2{``1,``2})">

</member>
<member name="M:Microsoft.FSharp.Core.Func.foldUntil``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``0}},``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Func.repeatN``1(System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,``0},``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Func.repeatUntil(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,System.Boolean})">

</member>
<member name="T:Microsoft.FSharp.Core.Func">

</member>
<member name="M:Microsoft.FSharp.Core.Int16.abs(System.Int16)">

</member>
<member name="M:Microsoft.FSharp.Core.Int16.add(System.Int16,System.Int16)">

</member>
<member name="M:Microsoft.FSharp.Core.Int16.compare(System.Int16,System.Int16)">

</member>
<member name="M:Microsoft.FSharp.Core.Int16.div(System.Int16,System.Int16)">

</member>
<member name="M:Microsoft.FSharp.Core.Int16.logand(System.Int16,System.Int16)">

</member>
<member name="M:Microsoft.FSharp.Core.Int16.lognot(System.Int16)">

</member>
<member name="M:Microsoft.FSharp.Core.Int16.logor(System.Int16,System.Int16)">

</member>
<member name="M:Microsoft.FSharp.Core.Int16.logxor(System.Int16,System.Int16)">

</member>
<member name="P:Microsoft.FSharp.Core.Int16.max_int">

</member>
<member name="P:Microsoft.FSharp.Core.Int16.min_int">

</member>
<member name="P:Microsoft.FSharp.Core.Int16.minus_one">

</member>
<member name="M:Microsoft.FSharp.Core.Int16.mul(System.Int16,System.Int16)">

</member>
<member name="M:Microsoft.FSharp.Core.Int16.neg(System.Int16)">

</member>
<member name="M:Microsoft.FSharp.Core.Int16.of_int(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int16.of_int32(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int16.of_int8(System.SByte)">

</member>
<member name="P:Microsoft.FSharp.Core.Int16.one">

</member>
<member name="M:Microsoft.FSharp.Core.Int16.pred(System.Int16)">

</member>
<member name="M:Microsoft.FSharp.Core.Int16.rem(System.Int16,System.Int16)">

</member>
<member name="M:Microsoft.FSharp.Core.Int16.shift_left(System.Int16,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int16.shift_right(System.Int16,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int16.sub(System.Int16,System.Int16)">

</member>
<member name="M:Microsoft.FSharp.Core.Int16.succ(System.Int16)">

</member>
<member name="M:Microsoft.FSharp.Core.Int16.to_int(System.Int16)">

</member>
<member name="M:Microsoft.FSharp.Core.Int16.to_int32(System.Int16)">

</member>
<member name="M:Microsoft.FSharp.Core.Int16.to_int8(System.Int16)">

</member>
<member name="P:Microsoft.FSharp.Core.Int16.zero">

</member>
<member name="T:Microsoft.FSharp.Core.Int16">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.abs(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.add(System.Int32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.bits_of_float(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.bits_of_float32(System.Single)">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.compare(System.Int32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.div(System.Int32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.float32_of_bits(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.float_of_bits(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.logand(System.Int32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.lognot(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.logor(System.Int32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.logxor(System.Int32,System.Int32)">

</member>
<member name="P:Microsoft.FSharp.Core.Int32.max_int">

</member>
<member name="P:Microsoft.FSharp.Core.Int32.min_int">

</member>
<member name="P:Microsoft.FSharp.Core.Int32.minus_one">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.mul(System.Int32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.neg(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.of_float(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.of_float32(System.Single)">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.of_int(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.of_int64(System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.of_nativeint(System.IntPtr)">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.of_string(System.String)">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.of_uint32(System.UInt32)">

</member>
<member name="P:Microsoft.FSharp.Core.Int32.one">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.pred(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.rem(System.Int32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.shift_left(System.Int32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.shift_right(System.Int32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.shift_right_logical(System.Int32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.sub(System.Int32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.succ(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.to_float(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.to_float32(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.to_int(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.to_int64(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.to_nativeint(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.to_string(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int32.to_uint32(System.Int32)">

</member>
<member name="P:Microsoft.FSharp.Core.Int32.zero">

</member>
<member name="T:Microsoft.FSharp.Core.Int32">
<summary>
 Basic operations on 32-bit integers. The type int32 is identical to [[System.Int64]]. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Int64.abs(System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Core.Int64.add(System.Int64,System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Core.Int64.bits_of_float(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Core.Int64.compare(System.Int64,System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Core.Int64.div(System.Int64,System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Core.Int64.float_of_bits(System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Core.Int64.logand(System.Int64,System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Core.Int64.lognot(System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Core.Int64.logor(System.Int64,System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Core.Int64.logxor(System.Int64,System.Int64)">

</member>
<member name="P:Microsoft.FSharp.Core.Int64.max_int">

</member>
<member name="P:Microsoft.FSharp.Core.Int64.min_int">

</member>
<member name="P:Microsoft.FSharp.Core.Int64.minus_one">

</member>
<member name="M:Microsoft.FSharp.Core.Int64.mul(System.Int64,System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Core.Int64.neg(System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Core.Int64.of_float(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Core.Int64.of_float32(System.Single)">

</member>
<member name="M:Microsoft.FSharp.Core.Int64.of_int(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int64.of_int32(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int64.of_nativeint(System.IntPtr)">

</member>
<member name="M:Microsoft.FSharp.Core.Int64.of_string(System.String)">

</member>
<member name="M:Microsoft.FSharp.Core.Int64.of_uint64(System.UInt64)">

</member>
<member name="P:Microsoft.FSharp.Core.Int64.one">

</member>
<member name="M:Microsoft.FSharp.Core.Int64.pred(System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Core.Int64.rem(System.Int64,System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Core.Int64.shift_left(System.Int64,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int64.shift_right(System.Int64,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int64.shift_right_logical(System.Int64,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int64.sub(System.Int64,System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Core.Int64.succ(System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Core.Int64.to_float(System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Core.Int64.to_float32(System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Core.Int64.to_int(System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Core.Int64.to_int32(System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Core.Int64.to_nativeint(System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Core.Int64.to_string(System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Core.Int64.to_uint64(System.Int64)">

</member>
<member name="P:Microsoft.FSharp.Core.Int64.zero">

</member>
<member name="T:Microsoft.FSharp.Core.Int64">
<summary>
 Basic operations on 64-bit integers. The type int64 is identical to [[System.Int64]]. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Int8.int8">

</member>
<member name="M:Microsoft.FSharp.Core.Int8.abs(System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.Int8.add(System.SByte,System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.Int8.compare(System.SByte,System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.Int8.div(System.SByte,System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.Int8.logand(System.SByte,System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.Int8.lognot(System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.Int8.logor(System.SByte,System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.Int8.logxor(System.SByte,System.SByte)">

</member>
<member name="P:Microsoft.FSharp.Core.Int8.max_int">

</member>
<member name="P:Microsoft.FSharp.Core.Int8.min_int">

</member>
<member name="P:Microsoft.FSharp.Core.Int8.minus_one">

</member>
<member name="M:Microsoft.FSharp.Core.Int8.mul(System.SByte,System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.Int8.neg(System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.Int8.of_byte(System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.Int8.of_int(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int8.of_int16(System.Int16)">

</member>
<member name="M:Microsoft.FSharp.Core.Int8.of_int32(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int8.of_uint8(System.Byte)">

</member>
<member name="P:Microsoft.FSharp.Core.Int8.one">

</member>
<member name="M:Microsoft.FSharp.Core.Int8.pred(System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.Int8.rem(System.SByte,System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.Int8.shift_left(System.SByte,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int8.shift_right(System.SByte,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Int8.sub(System.SByte,System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.Int8.succ(System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.Int8.to_byte(System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.Int8.to_int(System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.Int8.to_int16(System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.Int8.to_int32(System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.Int8.to_uint8(System.SByte)">

</member>
<member name="P:Microsoft.FSharp.Core.Int8.zero">

</member>
<member name="T:Microsoft.FSharp.Core.Int8">
<summary>
 Simple operations on signed bytes
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.ArrayGet``1(``0[]`1,System.Int32)">
<summary>
 Primitive used by pattern match compilation 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.CreateInstance``1">
<summary>
 This function implements calls to default constructors
 acccessed by 'new' constraints.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.PhysicalEquality``1(``0,``0)">
<summary>
Reference/physical equality. 
True if boxed versions of the inputs are reference-equal, OR if
both are value types and the implementation of Object.Equals for the type
of the first argument returns true on the boxed versions of the inputs.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.PhysicalHash``1(``0)">
<summary>
 The physical hash.  Hashes on the object identity, except for value types,
 where we hash on the contents.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.StructuralComparison``1(``0,``0)">
<summary>
 Compare two values structurally
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.StructuralEquality``1(``0,``0)">
<summary>
 Compare two values for structural equality
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.StructuralGreaterThan``1(``0,``0)">
<summary>
 Compare two values structurally.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.StructuralGreaterThanOrEqual``1(``0,``0)">
<summary>
 Compare two values structurally.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.StructuralHash``1(``0)">
<summary>
 See the IStructuralHash interface.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.StructuralHashParam``1(``0,Microsoft.FSharp.Core.byref`1{System.Int32})">
<summary>
 Hash a value according to its structure.  See the IStructuralHash interface.
 Implementations of IStructuralHash for aggregate structured data structures
 should call this function to hash sub-structures.

 The byref argument points to a count of the
 number of significant nodes remaining to be hashed in the cooperative hash.
 Substructures and leaf nodes (such as integers) should be hashed by calling 
 Microsoft.FSharp.Core.LanguagePrimitives.StructuralHashParam, but only if the hash count
 is non-zero.  If the hash count is zero StructuralHashParam must not be called.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.StructuralInequality``1(``0,``0)">
<summary>
 Compare two values for structural in-equality
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.StructuralLessThan``1(``0,``0)">
<summary>
 Compare two values structurally.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.StructuralLessThanOrEqual``1(``0,``0)">
<summary>
 Compare two values structurally.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.StructuralMaximum``1(``0,``0)">
<summary>
 Take the maximum of two values structurally according to the order given by StructuralComparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.StructuralMinimum``1(``0,``0)">
<summary>
 Take the minimum of two values structurally according to the order given by StructuralComparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.op_Amp(System.Boolean,System.Boolean)">
<summary>
 Binary 'and'.  When used as a binary operator the right hand value is evaluated only on demand
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.op_AmpAmp(System.Boolean,System.Boolean)">
<summary>
 Binary 'and'.  When used as a binary operator the right hand value is evaluated only on demand
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.op_BarBar(System.Boolean,System.Boolean)">
<summary>
 Binary 'or'.  When used as a binary operator the right hand value is evaluated only on demand
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.op_TwiddleAmp``1(``0)">
<summary>
 Address-of. Uses of this value may result in the generation of unverifiable code.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.op_TwiddleAmpAmp``1(``0)">
<summary>
 Address-of. Uses of this value may result in the generation of unverifiable code.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.op_UnaryNegation``1(``0)">
<summary>
 Overloaded unary negation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.or(System.Boolean,System.Boolean)">
<summary>
 Binary 'or'.  When used as a binary operator the right hand value is evaluated only on demand
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.PhysicalEqualityGeneric``1(``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.PhysicalHashGeneric``1(``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.StructuralComparisonGeneric``1(``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.StructuralEqualityGeneric``1(``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.StructuralGreaterThanGeneric``1(``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.StructuralGreaterThanOrEqualGeneric``1(``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.StructuralHashParamGeneric``1(``0,Microsoft.FSharp.Core.byref`1{System.Int32})">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.StructuralLessThanGeneric``1(``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare.StructuralLessThanOrEqualGeneric``1(``0,``0)">
<summary>
 A primitive entry point used by the F# compiler for optimization purposes. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.LanguagePrimitives.HashCompare">

</member>
<member name="T:Microsoft.FSharp.Core.LanguagePrimitives">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.GetSlice``4(``0,Microsoft.FSharp.Core.Option`1{``1},Microsoft.FSharp.Core.Option`1{``1})">
<summary>
 The standard overloaded 1D-slice operator, generally used on strings, arrays and vectors. 
 The source collection type must support a GetSlice member. The resulting collection type must support 
 an Item property index.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.GetSlice2D``4(``0,Microsoft.FSharp.Core.Option`1{``1},Microsoft.FSharp.Core.Option`1{``1},Microsoft.FSharp.Core.Option`1{``2},Microsoft.FSharp.Core.Option`1{``2})">
<summary>
 The standard overloaded 2D-slice operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.abs``1(``0)">
<summary>
Absolute value of the given integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.acos``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.asin``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.atan``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.atan2``1(``0,``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.box``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.byte``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.ceil``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.compare``1(``0,``0)">
<summary>
Generic comparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.cos``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.cosh``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.defaultArg``1(Microsoft.FSharp.Core.Option`1{``0},``0)">
<summary>
 Used to specify a default value for an optional argument in the implementation of a function
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.double``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.exp``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.failwith``1(System.String)">
<summary>
 Throw a 'FailureException' exception
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.float``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.float32``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.floor``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.fst``2(``0,``1)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.hash``1(``0)">
<summary>
The "hash" function is a structural hash function.  It is 
designed to return equal hash values for items that are 
equal according to the polymorphic equality 
function Pervasives.(=) (i.e. the standard "=" operator). The exact
behaviour of the function can be adjusted on a type-by-type
basis by implementing the IStructuralHash interface for each type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.hashq``1(``0)">
<summary>
The "hashq" function is designed to return equal hash values
for reference types that are equal according 
to the physical equality '==' (see also Obj.eq). For .NET value types
the implementation of Object.GetHashCode is used on a boxed version of
the input.  For efficiency reasons this should not typically
be used on .NET value types.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.ignore``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.int``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.int16``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.int32``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.int64``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.invalid_arg``1(System.String)">
<summary>
 Throw an 'InvalidArgumentException' exception
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.invalid_op``1(System.String)">
<summary>
 Throw an 'InvalidOperationException' exception
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.lock``2(``0,Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``1})">
<summary>
 Execute the function as a mutual-exlcusion region using the input value as a lock. Use as:
   lock (x) (fun () -> ...)
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.log``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.log10``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.max``1(``0,``0)">
<summary>
Maximum based on generic comparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.min``1(``0,``0)">
<summary>
Minimum based on generic comparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.nativeint``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.not(System.Boolean)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.not_found``1">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Addition``3">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_AdditionAssignment``2(``0,``1)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ArrayAssign``1(``0[]`1,System.Int32,``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ArrayAssign2``1(``0[,]`1,System.Int32,System.Int32,``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ArrayAssign3``1(``0[,,]`1,System.Int32,System.Int32,System.Int32,``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ArrayLookup``1(``0[]`1,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ArrayLookup2``1(``0[,]`1,System.Int32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ArrayLookup3``1(``0[,,]`1,System.Int32,System.Int32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_BitwiseAnd``1(``0,``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_BitwiseOr``1(``0,``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ColonEquals``1(Microsoft.FSharp.Core.Ref`1{``0},``0)">
<summary>
Assign to a mutable reference cell
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ComposeLeft``3(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Core.FastFunc`2{``2,``0})">
<summary>
 Compose two functions, the function on the right being applied first
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ComposeRight``3(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Core.FastFunc`2{``1,``2})">
<summary>
 Compose two functions, the function on the left being applied first
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Dereference``1(Microsoft.FSharp.Core.Ref`1{``0})">
<summary>
Dereference a mutable reference cell
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Division``3">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_DivisionAssignment``2(``0,``1)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_DollarMultiply``2(``0,``1)">
<summary>
Associate other operator values with their corresponding
 The left-oriented scalar multiplication operator, when the scalar is on the left side.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_DollarMultiplyDollar``3(``0,``1)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_DotDivide``2(``0,``1)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_DotDivideEquals``2(``0,``1)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_DotHat``2(``0,``1)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_DotHatEquals``2(``0,``1)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_DotMultiply``2(``0,``1)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_DotMultiplyEquals``2(``0,``1)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_DotPercent``2(``0,``1)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_DotPercentEquals``2(``0,``1)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_DotPlus``2(``0,``1)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_DotPlusEquals``2(``0,``1)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Equals``1(``0,``0)">
<summary>
Structural equality
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_ExclusiveOr``1(``0,``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_GreaterThan``1(``0,``0)">
<summary>
Structural greater-than
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_GreaterThanOrEqual``1(``0,``0)">
<summary>
Structural greater-than-or-equal
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_IndexedAssign``3(``0,``1,``2)">
<summary>
 The standard overloaded associative (indexed) mutation operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_IndexedAssign2``4(``0,``1,``2,``3)">
<summary>
 The standard overloaded associative (2-indexed) mutation operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_IndexedAssign3``5(``0,``1,``2,``3,``4)">
<summary>
 The standard overloaded associative (3-indexed) mutation operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_IndexedLookup``3(``0,``1)">
<summary>
 The standard overloaded associative (indexed) lookup operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_IndexedLookup2``4(``0,``1,``2)">
<summary>
 The standard overloaded associative (2-indexed) lookup operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_IndexedLookup3``5(``0,``1,``2,``3)">
<summary>
 The standard overloaded associative (3-indexed) lookup operator
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LeftShift``1(``0,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LessGreater``1(``0,``0)">
<summary>
Structural inequality
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LessThan``1(``0,``0)">
<summary>
Structural less-than comparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LessThanOrEqual``1(``0,``0)">
<summary>
Structural less-than-or-equal comparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_LogicalNot``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Modulus``3(``0,``1)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Multiply``3">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_MultiplyAssignment``2(``0,``1)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_MultiplyDollar``2(``0,``1)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_MultiplyDollarEquals``2(``0,``1)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_MultiplyMultiply``1(``0,``0)">
<summary>
 Overloaded power operator.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_MultiplyPercent``2(``0,``1)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_MultiplyPercentEquals``2(``0,``1)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_OverloadedLogicalRightShift``1(``0,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PercentMultiply``2(``0,``1)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PercentMultiplyEquals``2(``0,``1)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PercentMultiplyPercent``3(``0,``1)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PipeLeft``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0)">
<summary>
 Apply a function to a value, the value being on the right, the function on the left
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_PipeRight``2(``0,Microsoft.FSharp.Core.FastFunc`2{``0,``1})">
<summary>
 Apply a function to a value, the value being on the left, the function on the right
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Range``1(``0,``0)">
<summary>
 The standard overloaded range operator, e.g. '[n..m]' for lists, '{n..m}' for sequences
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_RangeStep``1(``0,``0,``0)">
<summary>
 The standard overloaded skip range operator, e.g. '[n..m]' for lists, '{n..m}' for sequences
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_RightShift``1(``0,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_Subtraction``3">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_SubtractionAssignment``2(``0,``1)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.op_UnaryPlus``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.raise``2(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.ref``1(``0)">
<summary>
Create a mutable reference cell
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.rethrow``1">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.sbyte``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.sin``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.single``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.sinh``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.sizeof``1">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.snd``2(``0,``1)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.sqrt``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.tan``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.tanh``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.typeof``1">
<summary>
 Generate a 'typ' value containing a System.Type runtime represenation of an F# type.
 The static type is still maintained on the value returned.

 The syntax '(type ...)' can now be used as a replacement for the 
 use of this operator when a System.Type object is required.
 Note parentheses are required when using '(type ...)'.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.uint16``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.uint32``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.uint64``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.unativeint``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.unbox``1(System.Object)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.using``2(``0,Microsoft.FSharp.Core.FastFunc`2{``0,``1})">
<summary>
 Clean up resources associated with the input object after the completion of the given function.
 Cleanup occurs even when an exception is raised by the protected
 code. Use as:
   using (myResource) (fun () -> ... )
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.byte``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.int``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.int16``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.int32``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.int64``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.nativeint``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.op_Addition``3">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.op_Multiply``3">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.op_Subtraction``3">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.sbyte``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.uint16``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.uint32``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.uint64``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.Checked.unativeint``1(``0)">

</member>
<member name="T:Microsoft.FSharp.Core.Operators.Checked">

</member>
<member name="M:Microsoft.FSharp.Core.Operators.StandardRanges.byte(System.Byte,System.Byte,System.Byte)">
<summary>
 Generate a range of byte values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.StandardRanges.char(System.Char,System.Char)">
<summary>
 Generate a range of char values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.StandardRanges.float(System.Double,System.Double,System.Double)">
<summary>
 Generate a range of float values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.StandardRanges.float32(System.Single,System.Single,System.Single)">
<summary>
 Generate a range of float32 values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.StandardRanges.generate``1(``0,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},``0,``0,``0)">
<summary>
 Generate a range of values using the given zero, add, start, step and stop values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.StandardRanges.int(System.Int32,System.Int32,System.Int32)">
<summary>
 Generate a range of integers  
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.StandardRanges.int16(System.Int16,System.Int16,System.Int16)">
<summary>
 Generate a range of int16 values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.StandardRanges.int64(System.Int64,System.Int64,System.Int64)">
<summary>
 Generate a range of int64 values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.StandardRanges.nativeint(System.IntPtr,System.IntPtr,System.IntPtr)">
<summary>
 Generate a range of nativeint values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.StandardRanges.sbyte(System.SByte,System.SByte,System.SByte)">
<summary>
 Generate a range of sbyte values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.StandardRanges.uint16(System.UInt16,System.UInt16,System.UInt16)">
<summary>
 Generate a range of uint16 values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.StandardRanges.uint32(System.UInt32,System.UInt32,System.UInt32)">
<summary>
 Generate a range of uint32 values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.StandardRanges.uint64(System.UInt64,System.UInt64,System.UInt64)">
<summary>
 Generate a range of uint64 values
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Operators.StandardRanges.unativeint(System.UIntPtr,System.UIntPtr,System.UIntPtr)">
<summary>
 Generate a range of unativeint values
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Operators.StandardRanges">

</member>
<member name="T:Microsoft.FSharp.Core.Operators">

</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FastFunc2`3..ctor">

</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FastFunc2`3.Invoke(``0,``1)">

</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures.FastFunc2`3">
<summary>
 The .NET type used to represent F# function values that accept
 two iterated (curried) arguments without intervening execution.  This type should not
 typically used directly from either F# code or from other .NET languages.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FastFunc3`4..ctor">

</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FastFunc3`4.Invoke(``0,``1,``2)">

</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures.FastFunc3`4">
<summary>
 The .NET type used to represent F# function values that accept
 three iterated (curried) arguments without intervening execution.  This type should not
 typically used directly from either F# code or from other .NET languages.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FastFunc4`5..ctor">

</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FastFunc4`5.Invoke(``0,``1,``2,``3)">

</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures.FastFunc4`5">
<summary>
 The .NET type used to represent F# function values that accept
 four iterated (curried) arguments without intervening execution.  This type should not
 typically used directly from either F# code or from other .NET languages.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FastFunc5`6..ctor">

</member>
<member name="M:Microsoft.FSharp.Core.OptimizedClosures.FastFunc5`6.Invoke(``0,``1,``2,``3,``4)">

</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures.FastFunc5`6">
<summary>
 The .NET type used to represent F# function values that accept
 five iterated (curried) arguments without intervening execution.  This type should not
 typically used directly from either F# code or from other .NET languages.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.OptimizedClosures">
<summary>
 An implementation module used to hold some private implementations of function
 value invocation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Option.bind``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Option`1{``1}},Microsoft.FSharp.Core.Option`1{``0})">
<summary>
"bind f inp" evaluates to "match inp with None -> None | Some x -> f x"
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Option.exists``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Core.Option`1{``0})">
<summary>
"exists p inp" evaluates to "match inp with None -> false | Some x -> p x"
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Option.filter``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Core.Option`1{``0})">
<summary>
"filter p inp" evaluates to "match inp with None -> None | Some x -> if p x then inp else None"
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Option.fold_left``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,Microsoft.FSharp.Core.Option`1{``1})">
<summary>
"fold_left f s inp " evaluates to "match inp with None -> s | Some x -> f s x"
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Option.fold_right``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}},Microsoft.FSharp.Core.Option`1{``0},``1)">
<summary>
"fold_right f inp s" evaluates to "match inp with None -> s | Some x -> f x s"
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Option.for_all``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Core.Option`1{``0})">
<summary>
"forall p inp" evaluates to "match inp with None -> true | Some x -> p x"
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Option.get``1(Microsoft.FSharp.Core.Option`1{``0})">
<summary>
Gets the value associated with the option.  If the option is None then
raises Invalid_argument "Option.get"
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Option.is_none``1(Microsoft.FSharp.Core.Option`1{``0})">
<summary>
Returns true if the option is None
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Option.is_some``1(Microsoft.FSharp.Core.Option`1{``0})">
<summary>
Returns true if the option is not None
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Option.iter``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.Option`1{``0})">
<summary>
"iter f inp" executes "match inp with None -> () | Some x -> f x"
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Option.length``1(Microsoft.FSharp.Core.Option`1{``0})">
<summary>
"length inp" evaluates to "match inp with None -> 0 | Some _ -> 1"
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Option.map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Core.Option`1{``0})">
<summary>
"map f inp" evaluates to "match inp with None -> None | Some x -> Some (f x)"
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Option.partition``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Core.Option`1{``0})">
<summary>
"partition p inp" evaluates to 
"match inp with None -> None,None | Some x -> if p x then inp,None else None,inp"
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Option.to_array``1(Microsoft.FSharp.Core.Option`1{``0})">
<summary>
Convert the option to an array of length 0 or 1
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Option.to_list``1(Microsoft.FSharp.Core.Option`1{``0})">
<summary>
Convert the option to a list of length 0 or 1
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Option">
<summary>
 Basic operations on options.  
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.Pervasives.FormatOptions">
<summary>
 A record of options to control structural formatting.
 For F# Interactive properties matching those of this value can be accessed via the 'fsi'
 value.
 
 Floating Point format given in the same format accepted by System.Double.ToString,
 e.g. f6 or g15.

 If ShowProperties is set the printing process will evaluate properties of the values being
 displayed.  This may cause additional computation.  

 The ShowIEnumerable is set the printing process will force the evalution of IEnumerable objects
 to a small, finite depth, as determined by the printing parameters.
 This may lead to additional computation being performed during printing.

 <example>
 From F# Interactive the default settings can be adjusted using, for example, 
 <pre>
   open Microsoft.FSharp.Compiler.Interactive.Settings;;
   setPrintWidth 120;;
 </pre>
 </example>
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.any_to_layout``1(Microsoft.FSharp.Text.StructuredFormat.FormatOptions,``0)">
<summary>
 Convert any value to a layout using the given formatting options.  The
 layout can then be processed using formatting display engines such as
 those in the LayoutOps module.  any_to_string and output_any are
 built using any_to_layout with default format options.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.any_to_string``1(``0)">
<summary>
 Convert any value to a string using a standard formatter
 Data is typically formatted in a structured format, e.g.
 lists are formatted using the "[1;2]" notation.
 The details of the format are not specified and may change
 from version to version and according to the flags given
 to the F# compiler.  The format is intended to be human-readable,
 not machine readable.  If alternative generic formats are required
 you should develop your own formatter, using the code in the
 implementation of this file as a starting point.

 Data from other .NET languages is formatted using a virtual
 call to Object.ToString() on the boxed version of the input.
</summary>
</member>
<member name="P:Microsoft.FSharp.Core.Pervasives.async">

</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.complex(System.Double,System.Double)">

</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.decr(Microsoft.FSharp.Core.Ref`1{System.Int32})">
<summary>
Decrement a mutable reference cell containing an integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.dict``3(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.eprintf``1(Microsoft.FSharp.Text.Format`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
Print to stderr using the given format
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.eprintfn``1(Microsoft.FSharp.Text.Format`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
Print to stderr using the given format, and add a newline
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.exit``1(System.Int32)">
<summary>
Exit the current hardware isolated process, if security settings permit,
otherwise raise an exception.  Calls System.Environment.Exit.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.failwithf``2(Microsoft.FSharp.Text.Format`4{``0,Microsoft.FSharp.Core.Unit,System.String,``1})">
<summary>
 Print to a string buffer and raise an exception with the given
 result.   Helper printers must return strings.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.fprintf``1(System.IO.TextWriter,Microsoft.FSharp.Text.Format`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
Print to a file using the given format
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.fprintfn``1(System.IO.TextWriter,Microsoft.FSharp.Text.Format`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
Print to a file using the given format, and add a newline
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.incr(Microsoft.FSharp.Core.Ref`1{System.Int32})">
<summary>
Increment a mutable reference cell containing an integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.layout_as_string``1(Microsoft.FSharp.Text.StructuredFormat.FormatOptions,``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.layout_to_string(Microsoft.FSharp.Text.StructuredFormat.FormatOptions,Microsoft.FSharp.Text.StructuredFormat.Layout)">

</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.matrix``2(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.op_Append``1(Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Concatenate two lists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.op_Concatenate(System.String,System.String)">
<summary>
 Concatenate two strings.  The overlaoded operator '+' may also be used.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.output_any``2(``0,``1)">
<summary>
 Ouput any value to a channel using the same set of formatting rules
 as any_to_string
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.output_layout``1(Microsoft.FSharp.Text.StructuredFormat.FormatOptions,``0,Microsoft.FSharp.Text.StructuredFormat.Layout)">

</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.prerr_any``1(``0)">
<summary>
Print any value to stderr using any_to_string. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.print_any``1(``0)">
<summary>
Print any value to stdin using any_to_string. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.printf``1(Microsoft.FSharp.Text.Format`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
Print to stdout using the given format
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.printfn``1(Microsoft.FSharp.Text.Format`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
Print to stdout using the given format, and add a newline
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.rowvec``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.seq``2(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.set``2(``0)">

</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.sprintf``1(Microsoft.FSharp.Text.Format`4{``0,Microsoft.FSharp.Core.Unit,System.String,System.String})">
<summary>
Print to a string using the given format
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.squash_layout(Microsoft.FSharp.Text.StructuredFormat.FormatOptions,Microsoft.FSharp.Text.StructuredFormat.Layout)">

</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.truncate(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Core.Pervasives.vector``1(``0)">

</member>
<member name="T:Microsoft.FSharp.Core.Pervasives">
<summary>
Pervasives: Additional bindings available at the top level 
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.SByte.abs(System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.SByte.add(System.SByte,System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.SByte.compare(System.SByte,System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.SByte.div(System.SByte,System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.SByte.logand(System.SByte,System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.SByte.lognot(System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.SByte.logor(System.SByte,System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.SByte.logxor(System.SByte,System.SByte)">

</member>
<member name="P:Microsoft.FSharp.Core.SByte.max_int">

</member>
<member name="P:Microsoft.FSharp.Core.SByte.min_int">

</member>
<member name="P:Microsoft.FSharp.Core.SByte.minus_one">

</member>
<member name="M:Microsoft.FSharp.Core.SByte.mul(System.SByte,System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.SByte.neg(System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.SByte.of_byte(System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.SByte.of_int(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.SByte.of_int16(System.Int16)">

</member>
<member name="M:Microsoft.FSharp.Core.SByte.of_int32(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.SByte.of_uint8(System.Byte)">

</member>
<member name="P:Microsoft.FSharp.Core.SByte.one">

</member>
<member name="M:Microsoft.FSharp.Core.SByte.pred(System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.SByte.rem(System.SByte,System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.SByte.shift_left(System.SByte,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.SByte.shift_right(System.SByte,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.SByte.sub(System.SByte,System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.SByte.succ(System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.SByte.to_byte(System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.SByte.to_int(System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.SByte.to_int16(System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.SByte.to_int32(System.SByte)">

</member>
<member name="M:Microsoft.FSharp.Core.SByte.to_uint8(System.SByte)">

</member>
<member name="P:Microsoft.FSharp.Core.SByte.zero">

</member>
<member name="T:Microsoft.FSharp.Core.SByte">
<summary>
 Simple operations on signed bytes
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.capitalize(System.String)">
<summary>
 Return a string with the first character converted to uppercase.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.compare(System.String,System.String)">
<summary>
 Compare the given strings using ordinal comparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.concat(System.String,Microsoft.FSharp.Collections.List`1{System.String})">
<summary>
 Return a new string made by concatenating the given strings
 with separator 'sep', i.e. 'a1 + sep + ... + sep + aN'
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.contains(System.String,System.Char)">
<summary>
 Return true is the given string contains the given character
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.contains_between(System.String,System.Int32,System.Int32,System.Char)">
<summary>
 Return true is the given string contains the given character in the
 range specified by the given start index and the given length
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.contains_from(System.String,System.Int32,System.Char)">
<summary>
 Return true is the given string contains the given character in the
 range from the given start index to the end of the string.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.exists(Microsoft.FSharp.Core.FastFunc`2{System.Char,System.Boolean},System.String)">
<summary>
Test if any character of the string satisfies the given predicate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.for_all(Microsoft.FSharp.Core.FastFunc`2{System.Char,System.Boolean},System.String)">
<summary>
Test if all characters in the string satisfy the given predicate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.get(System.String,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.String.index(System.String,System.Char)">
<summary>
 Return the first index of the given character in the
 string.  Raise IndexOutOfRangeException (Not_found) if
 the string does not contain the given character.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.index_from(System.String,System.Int32,System.Char)">
<summary>
 Return the first index of the given character in the
 range from the given start position to the end of the string.  
 Raise IndexOutOfRangeException (Not_found) if
 the string does not contain the given character.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.iter(Microsoft.FSharp.Core.FastFunc`2{System.Char,Microsoft.FSharp.Core.Unit},System.String)">
<summary>
Apply the given function to each character in the string
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.length(System.String)">
<summary>
 Return the length of the string.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.lowercase(System.String)">
<summary>
 Return a new string with all characters converted to lowercase
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.make(System.Int32,System.Char)">
<summary>
 Return a string of the given length containing repetitions of the given character
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.map(Microsoft.FSharp.Core.FastFunc`2{System.Char,System.Char},System.String)">
<summary>
Build a new string whose characters are the results of applying the given function
to each of the characters of the input string.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.map_concat(Microsoft.FSharp.Core.FastFunc`2{System.Char,System.String},System.String)">
<summary>
Build a new string whose characters are the results of applying the given function
to each of the characters of the input string and concatenating the resulting
strings.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.of_char(System.Char)">
<summary>
 Return s string of length 1 contianing the given character
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.rcontains_from(System.String,System.Int32,System.Char)">
<summary>
 Return true if the string contains the given character prior to the given index
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.rindex(System.String,System.Char)">
<summary>
 Return the index of the first occurrence of the given character 
 from the end of the string proceeding backwards
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.rindex_from(System.String,System.Int32,System.Char)">
<summary>
 Return the index of the first occurrence of the given character 
 starting from the given index proceeding backwards.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.split(Microsoft.FSharp.Collections.List`1{System.Char})">
<summary>
 Split the string using the given list of separator characters.
 Trimming is also performed at both ends of the string and any empty
 strings that result from the split are discarded.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.sub(System.String,System.Int32,System.Int32)">
<summary>
 Return a substring of length 'length' starting index 'start'.
 Raise IndexOutOfRangeException (Not_found) if the start index
 is out of range or start+length is greatere than the length of the string
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.trim(Microsoft.FSharp.Collections.List`1{System.Char})">
<summary>
 Split the string using the given list of separator characters.
 Trimming is also performed at both ends of the string and any empty
 strings that result from the split are discarded.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.uncapitalize(System.String)">
<summary>
 Return a string with the first character converted to lowercase.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.String.uppercase(System.String)">
<summary>
 Return a string with all characters converted to uppercase.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.String">
<summary>
 Compatibility module for ML string processing.  Richer string operations
 are available via the member functions on strings and other functionality in
  <a href="http://msdn2.microsoft.com/en-us/library/system.string.aspx">System.String</a> 
 and <a href="http://msdn2.microsoft.com/library/system.text.regularexpressions.aspx">System.Text.RegularExpressions</a> types.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.UInt16.add(System.UInt16,System.UInt16)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt16.compare(System.UInt16,System.UInt16)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt16.div(System.UInt16,System.UInt16)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt16.logand(System.UInt16,System.UInt16)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt16.lognot(System.UInt16)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt16.logor(System.UInt16,System.UInt16)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt16.logxor(System.UInt16,System.UInt16)">

</member>
<member name="P:Microsoft.FSharp.Core.UInt16.max_int">

</member>
<member name="P:Microsoft.FSharp.Core.UInt16.min_int">

</member>
<member name="M:Microsoft.FSharp.Core.UInt16.mul(System.UInt16,System.UInt16)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt16.of_int(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt16.of_int16(System.Int16)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt16.of_int32(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt16.of_uint32(System.UInt32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt16.of_uint8(System.Byte)">

</member>
<member name="P:Microsoft.FSharp.Core.UInt16.one">

</member>
<member name="M:Microsoft.FSharp.Core.UInt16.pred(System.UInt16)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt16.rem(System.UInt16,System.UInt16)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt16.shift_left(System.UInt16,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt16.shift_right(System.UInt16,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt16.sub(System.UInt16,System.UInt16)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt16.succ(System.UInt16)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt16.to_int(System.UInt16)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt16.to_int16(System.UInt16)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt16.to_int32(System.UInt16)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt16.to_uint32(System.UInt16)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt16.to_uint8(System.UInt16)">

</member>
<member name="P:Microsoft.FSharp.Core.UInt16.zero">

</member>
<member name="T:Microsoft.FSharp.Core.UInt16">

</member>
<member name="M:Microsoft.FSharp.Core.UInt32.add(System.UInt32,System.UInt32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt32.bits_of_float(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt32.bits_of_float32(System.Single)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt32.compare(System.UInt32,System.UInt32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt32.div(System.UInt32,System.UInt32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt32.float32_of_bits(System.UInt32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt32.float_of_bits(System.UInt32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt32.logand(System.UInt32,System.UInt32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt32.lognot(System.UInt32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt32.logor(System.UInt32,System.UInt32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt32.logxor(System.UInt32,System.UInt32)">

</member>
<member name="P:Microsoft.FSharp.Core.UInt32.max_int">

</member>
<member name="P:Microsoft.FSharp.Core.UInt32.min_int">

</member>
<member name="M:Microsoft.FSharp.Core.UInt32.mul(System.UInt32,System.UInt32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt32.of_float(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt32.of_float32(System.Single)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt32.of_int(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt32.of_int32(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt32.of_string(System.String)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt32.of_uint64(System.UInt64)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt32.of_unativeint(System.UIntPtr)">

</member>
<member name="P:Microsoft.FSharp.Core.UInt32.one">

</member>
<member name="M:Microsoft.FSharp.Core.UInt32.pred(System.UInt32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt32.rem(System.UInt32,System.UInt32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt32.shift_left(System.UInt32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt32.shift_right(System.UInt32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt32.sub(System.UInt32,System.UInt32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt32.succ(System.UInt32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt32.to_float(System.UInt32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt32.to_float32(System.UInt32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt32.to_int(System.UInt32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt32.to_int32(System.UInt32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt32.to_string(System.UInt32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt32.to_uint64(System.UInt32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt32.to_unativeint(System.UInt32)">

</member>
<member name="P:Microsoft.FSharp.Core.UInt32.zero">

</member>
<member name="T:Microsoft.FSharp.Core.UInt32">
<summary>
 UInt32: ML-like operations on 32-bit System.UInt32 numbers.
</summary>
</member>
<member name="M:Microsoft.FSharp.Core.UInt64.add(System.UInt64,System.UInt64)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt64.bits_of_float(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt64.compare(System.UInt64,System.UInt64)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt64.div(System.UInt64,System.UInt64)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt64.float_of_bits(System.UInt64)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt64.logand(System.UInt64,System.UInt64)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt64.lognot(System.UInt64)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt64.logor(System.UInt64,System.UInt64)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt64.logxor(System.UInt64,System.UInt64)">

</member>
<member name="P:Microsoft.FSharp.Core.UInt64.max_int">

</member>
<member name="P:Microsoft.FSharp.Core.UInt64.min_int">

</member>
<member name="M:Microsoft.FSharp.Core.UInt64.mul(System.UInt64,System.UInt64)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt64.of_float(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt64.of_float32(System.Single)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt64.of_int(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt64.of_int64(System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt64.of_string(System.String)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt64.of_uint32(System.UInt32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt64.of_unativeint(System.UIntPtr)">

</member>
<member name="P:Microsoft.FSharp.Core.UInt64.one">

</member>
<member name="M:Microsoft.FSharp.Core.UInt64.pred(System.UInt64)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt64.rem(System.UInt64,System.UInt64)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt64.shift_left(System.UInt64,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt64.shift_right(System.UInt64,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt64.sub(System.UInt64,System.UInt64)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt64.succ(System.UInt64)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt64.to_float(System.UInt64)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt64.to_float32(System.UInt64)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt64.to_int(System.UInt64)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt64.to_int64(System.UInt64)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt64.to_string(System.UInt64)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt64.to_uint32(System.UInt64)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt64.to_unativeint(System.UInt64)">

</member>
<member name="P:Microsoft.FSharp.Core.UInt64.zero">

</member>
<member name="T:Microsoft.FSharp.Core.UInt64">
<summary>
 UInt64: basic operations on 64-bit System.UInt64 numbers.
</summary>
</member>
<member name="T:Microsoft.FSharp.Core.UInt8.uint8">

</member>
<member name="M:Microsoft.FSharp.Core.UInt8.add(System.Byte,System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt8.compare(System.Byte,System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt8.div(System.Byte,System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt8.logand(System.Byte,System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt8.lognot(System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt8.logor(System.Byte,System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt8.logxor(System.Byte,System.Byte)">

</member>
<member name="P:Microsoft.FSharp.Core.UInt8.max_int">

</member>
<member name="P:Microsoft.FSharp.Core.UInt8.min_int">

</member>
<member name="M:Microsoft.FSharp.Core.UInt8.mul(System.Byte,System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt8.of_byte(System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt8.of_int(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt8.of_int32(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt8.of_uint16(System.UInt16)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt8.of_uint32(System.UInt32)">

</member>
<member name="P:Microsoft.FSharp.Core.UInt8.one">

</member>
<member name="M:Microsoft.FSharp.Core.UInt8.pred(System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt8.rem(System.Byte,System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt8.shift_left(System.Byte,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt8.shift_right(System.Byte,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt8.sub(System.Byte,System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt8.succ(System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt8.to_byte(System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt8.to_int(System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt8.to_int32(System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt8.to_uint16(System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Core.UInt8.to_uint32(System.Byte)">

</member>
<member name="P:Microsoft.FSharp.Core.UInt8.zero">

</member>
<member name="T:Microsoft.FSharp.Core.UInt8">
<summary>
 Simple operations on unsigned bytes
</summary>
</member>
<member name="M:Microsoft.FSharp.Idioms.EventListeners`1..ctor">
<summary>
 Build a new store of listeneres for an event
</summary>
</member>
<member name="M:Microsoft.FSharp.Idioms.EventListeners`1.Fire(``0)">
<summary>
 Fire the event associated with this EventListeners store
</summary>
</member>
<member name="P:Microsoft.FSharp.Idioms.EventListeners`1.Event">
<summary>
 Return the IEvent object that mediates access to this store.
</summary>
</member>
<member name="T:Microsoft.FSharp.Idioms.EventListeners`1">

</member>
<member name="T:Microsoft.FSharp.Idioms.Handler`1">
<summary>
 Fresh events declared in F# are typically values of type Idioms.ICompatEvent&lt;'a&gt;. These 
 hold event handlers of type Idioms.Handler&lt;'a&gt;. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Idioms.IDelegateEvent`2">
<summary>
 See Microsoft.FSharp.IDelegateEvent
</summary>
</member>
<member name="T:Microsoft.FSharp.Idioms.IEvent`1">
<summary>
 See Microsoft.FSharp.Control.IEvent
</summary>
</member>
<member name="T:Microsoft.FSharp.Idioms.IHandlerEvent`1">

</member>
<member name="T:Microsoft.FSharp.Idioms.sizeof`1">

</member>
<member name="T:Microsoft.FSharp.Idioms.typ`1">

</member>
<member name="M:Microsoft.FSharp.Idioms.CombineEnumFlags``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
Combine enum values using 'logical or'. The relevant enumeration type is inferred from context.
</summary>
</member>
<member name="M:Microsoft.FSharp.Idioms.EnumToInt``1(``0)">
<summary>
Convert an enumeration value to an integer. The argument type is inferred from context.
</summary>
</member>
<member name="M:Microsoft.FSharp.Idioms.IntToEnum``1(System.Int32)">
<summary>
Convert an integer to an enumeration value. The result type is inferred from context.
</summary>
</member>
<member name="M:Microsoft.FSharp.Idioms.ParamArray``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Use when calling a method from another .NET language that expects a variable number of
 arguments.
</summary>
</member>
<member name="M:Microsoft.FSharp.Idioms.TestEnumFlag``1(``0,``0)">
<summary>
Test if an enumeration value has a particular flag set, using 'logical and'. 
The relevant enumeration type is inferred from context.
</summary>
</member>
<member name="M:Microsoft.FSharp.Idioms.box``1(``0)">
<summary>
Convert a value to the univeral representation type 'obj',
where the argument type is inferred from context.
</summary>
</member>
<member name="M:Microsoft.FSharp.Idioms.foreach``2(``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit})">
<summary>
 This idiom corresponds to the C# "foreach" construct.
 Use as: 'foreach (collection) (fun (x:expectedType) -&gt; ...)'.
 Try using 'Idioms.foreachG' before using this function, as that
 detects if the collection supports a typesafe IEnumerable&lt;T&gt;.
 If any element of the heterogeneous collection does not
 have the given type then a runtime error will be raised.
 Not all F# collection types directly implement the required interfaces,
 hence you may need to call a projection function such as 'CollectionType.to_IEnumerable'.
</summary>
</member>
<member name="M:Microsoft.FSharp.Idioms.foreachG``2(``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit})">
<summary>
 Enumerator iteration. See 'foreach'.
</summary>
</member>
<member name="M:Microsoft.FSharp.Idioms.lock``2(``0,Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``1})">
<summary>
 The idiom corresponding to the C# "lock(x) { ... }"  construct. Use as:
   lock (x) (fun () -> ...)
</summary>
</member>
<member name="M:Microsoft.FSharp.Idioms.sizeof``1">
<summary>
Return a sizeof value containing an integer representing the runtime allocated size of handles to values of
a given F# type. Most F# types will have a handle size of 1 native machine word.
</summary>
</member>
<member name="M:Microsoft.FSharp.Idioms.typeof``1">
<summary>
 Generate a 'typ' value containing a System.Type runtime represenation of an F# type.
 The static type is still maintained on the value returned.

 The syntax '(type ...)' can now be used as a replacement for the 
 use of this operator when a System.Type object is required.
 This operator may be marked 'deprecated' in a suture release of F#.
 Note parentheses are currently required when using '(type ...)'.
</summary>
</member>
<member name="M:Microsoft.FSharp.Idioms.unbox``1(System.Object)">
<summary>
Convert a value from the univeral representation type 'obj' to another type,
where the result type is inferred from context.
</summary>
</member>
<member name="M:Microsoft.FSharp.Idioms.using``2(``0,Microsoft.FSharp.Core.FastFunc`2{``0,``1})">
<summary>
 The idiom corresponding to the C# "using" construct, which uses
 the IDisposable interface to dispose of a native
 resource even when an exception is raised by the protected
 code. Use as:
   using (myResource) (fun () -> ... )
</summary>
</member>
<member name="T:Microsoft.FSharp.Idioms">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.Equals(System.Object)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.GetHashCode">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_Addition(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_Division(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_Multiply(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_Range(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_RangeStep(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_Subtraction(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_UnaryNegation(Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.op_UnaryPlus(Microsoft.FSharp.Math.BigInt)">

</member>
<member name="T:Microsoft.FSharp.Math.BigInt">
<summary>
 The type of arbitrary-sized integers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigNum.GetHashCode">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.ToString">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_Addition(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_Division(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_Multiply(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_Range(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_RangeStep(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_Subtraction(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_UnaryNegation(Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.op_UnaryPlus(Microsoft.FSharp.Math.BigNum)">

</member>
<member name="T:Microsoft.FSharp.Math.BigNum">
<summary>
 The type of arbitrary-sized rational numbers
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.BigRational">

</member>
<member name="M:Microsoft.FSharp.Math.Complex.Abs(Microsoft.FSharp.Math.Complex)">

</member>
<member name="M:Microsoft.FSharp.Math.Complex.Cos(Microsoft.FSharp.Math.Complex)">

</member>
<member name="M:Microsoft.FSharp.Math.Complex.Create(System.Double,System.Double)">
<summary>
 Create a complex number x+ij using rectangular coordinates
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.CreatePolar(System.Double,System.Double)">
<summary>
 Create a complex number using magnitude/phase polar coordinates
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.Exp(Microsoft.FSharp.Math.Complex)">

</member>
<member name="M:Microsoft.FSharp.Math.Complex.Log(Microsoft.FSharp.Math.Complex)">

</member>
<member name="M:Microsoft.FSharp.Math.Complex.Sin(Microsoft.FSharp.Math.Complex)">

</member>
<member name="M:Microsoft.FSharp.Math.Complex.Sqrt(Microsoft.FSharp.Math.Complex)">

</member>
<member name="M:Microsoft.FSharp.Math.Complex.Tan(Microsoft.FSharp.Math.Complex)">

</member>
<member name="P:Microsoft.FSharp.Math.Complex.Conjugate">
<summary>
 The conjugate of a complex number, i.e. x-yi
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Complex.ImaginaryPart">
<summary>
 The imaginary part of a complex number
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Complex.Magnitude">
<summary>
 The polar-coordinate magnitude of a complex number
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Complex.One">
<summary>
 The complex number 1+0i
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Complex.OneI">
<summary>
 The complex number 0+1i
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Complex.Phase">
<summary>
 The polar-coordinate phase of a complex number
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Complex.RealPart">
<summary>
 The real part of a complex number
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Complex.Zero">
<summary>
 The complex number 0+0i
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Complex.i">
<summary>
 The imaginary part of a complex number
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Complex.r">
<summary>
 The real part of a complex number
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.op_Addition(Microsoft.FSharp.Math.Complex,Microsoft.FSharp.Math.Complex)">
<summary>
 Add two complex numbers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.op_Division(Microsoft.FSharp.Math.Complex,Microsoft.FSharp.Math.Complex)">
<summary>
 Complex division of two complex numbers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.op_DollarMultiply(System.Double,Microsoft.FSharp.Math.Complex)">
<summary>
 Multiply a scalar by a complex number 
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.op_Multiply(Microsoft.FSharp.Math.Complex,Microsoft.FSharp.Math.Complex)">
<summary>
 Multiply two complex numbers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.op_MultiplyDollar(Microsoft.FSharp.Math.Complex,System.Double)">
<summary>
 Multiply a complex number by a scalar
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.op_Subtraction(Microsoft.FSharp.Math.Complex,Microsoft.FSharp.Math.Complex)">
<summary>
 Subtract one complex number from another
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.op_UnaryNegation(Microsoft.FSharp.Math.Complex)">
<summary>
 Unary negation of a complex number
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.Complex">
<summary>
 The type of complex numbers stored as pairs of 64-bit floating point numbers in rectangular coordinates
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.DenseMatrix`1">
 <summary>
 The type of matrices.  The arithmetic operations on the element type are determined by inspection on the element type itself
 </summary>
</member>
<member name="M:Microsoft.FSharp.Math.IFloating`1.Acos(``0)">

</member>
<member name="M:Microsoft.FSharp.Math.IFloating`1.Asin(``0)">

</member>
<member name="M:Microsoft.FSharp.Math.IFloating`1.Atan(``0)">

</member>
<member name="M:Microsoft.FSharp.Math.IFloating`1.Atan2(``0,``0)">

</member>
<member name="M:Microsoft.FSharp.Math.IFloating`1.Cos(``0)">

</member>
<member name="M:Microsoft.FSharp.Math.IFloating`1.Cosh(``0)">

</member>
<member name="M:Microsoft.FSharp.Math.IFloating`1.Exp(``0)">

</member>
<member name="M:Microsoft.FSharp.Math.IFloating`1.Log(``0)">

</member>
<member name="M:Microsoft.FSharp.Math.IFloating`1.LogN(``0,``0)">

</member>
<member name="M:Microsoft.FSharp.Math.IFloating`1.Sin(``0)">

</member>
<member name="M:Microsoft.FSharp.Math.IFloating`1.Sinh(``0)">

</member>
<member name="M:Microsoft.FSharp.Math.IFloating`1.Sqrt(``0)">

</member>
<member name="M:Microsoft.FSharp.Math.IFloating`1.Tan(``0)">

</member>
<member name="M:Microsoft.FSharp.Math.IFloating`1.Tanh(``0)">

</member>
<member name="P:Microsoft.FSharp.Math.IFloating`1.Pi">

</member>
<member name="T:Microsoft.FSharp.Math.IFloating`1">

</member>
<member name="M:Microsoft.FSharp.Math.IFractional`1.Divide(``0,``0)">

</member>
<member name="M:Microsoft.FSharp.Math.IFractional`1.Reciprocal(``0)">

</member>
<member name="T:Microsoft.FSharp.Math.IFractional`1">

</member>
<member name="M:Microsoft.FSharp.Math.IIEEE`1.IsInfinite(``0)">

</member>
<member name="M:Microsoft.FSharp.Math.IIEEE`1.IsNaN(``0)">

</member>
<member name="P:Microsoft.FSharp.Math.IIEEE`1.Epsilon">

</member>
<member name="P:Microsoft.FSharp.Math.IIEEE`1.NaN">

</member>
<member name="P:Microsoft.FSharp.Math.IIEEE`1.NegativeInfinity">

</member>
<member name="P:Microsoft.FSharp.Math.IIEEE`1.PositiveInfinity">

</member>
<member name="T:Microsoft.FSharp.Math.IIEEE`1">

</member>
<member name="M:Microsoft.FSharp.Math.IIntegral`1.DivMod(``0,``0)">

</member>
<member name="M:Microsoft.FSharp.Math.IIntegral`1.Divide(``0,``0)">

</member>
<member name="M:Microsoft.FSharp.Math.IIntegral`1.Modulus(``0,``0)">

</member>
<member name="M:Microsoft.FSharp.Math.IIntegral`1.OfBigInt(Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.IIntegral`1.ToBigInt(``0)">

</member>
<member name="T:Microsoft.FSharp.Math.IIntegral`1">

</member>
<member name="M:Microsoft.FSharp.Math.INumeric`1.Abs(``0)">

</member>
<member name="M:Microsoft.FSharp.Math.INumeric`1.Add(``0,``0)">

</member>
<member name="M:Microsoft.FSharp.Math.INumeric`1.Multiply(``0,``0)">

</member>
<member name="M:Microsoft.FSharp.Math.INumeric`1.Negate(``0)">

</member>
<member name="M:Microsoft.FSharp.Math.INumeric`1.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">

</member>
<member name="M:Microsoft.FSharp.Math.INumeric`1.Sign(``0)">

</member>
<member name="M:Microsoft.FSharp.Math.INumeric`1.Subtract(``0,``0)">

</member>
<member name="M:Microsoft.FSharp.Math.INumeric`1.ToString(``0,System.String,System.IFormatProvider)">

</member>
<member name="P:Microsoft.FSharp.Math.INumeric`1.One">

</member>
<member name="P:Microsoft.FSharp.Math.INumeric`1.Zero">

</member>
<member name="T:Microsoft.FSharp.Math.INumeric`1">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.Equals(System.Object)">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.GetHashCode">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.GetSlice2D(Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.Pin``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.nativeptr`1{``0},``1})">
<summary>
 For native interop. Pin the given object for the duration of a single call to the given function.  A native pointer to
 the (0,0) element in the underlying array is passed to the given function.  Resources associated with the 
 pin are released when the function completes, even if an exception is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.PinHandle">
<summary>
 For native interop. Pin the given object, but the caller is responsible for freeing the GCHandle
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Matrix`1.Dimensions">
<summary>
 The number of (rows,columns) in the matrix
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Matrix`1.ElementOps">
<summary>
 Retrieve the dictionary of numeric operations associated with the element
 type of this matrix.  Accessing the property may raise an NotSupportedException if the element
 type doesn't support any numeric operations.  The object returned
 may support additional numeric operations such as IFractional: 
 this can be determined by a dynamic type test against the object
 returned.
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Matrix`1.Item(System.Int32,System.Int32)">
<summary>
 Get the item at the given position in the matrix
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Matrix`1.NumCols">
<summary>
 The number of columns in the matrix
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Matrix`1.NumRows">
<summary>
 The number of rows in the matrix
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Matrix`1.Transpose">
<summary>
 Get the transpose of the matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.op_Addition(Microsoft.FSharp.Math.Matrix`1{``0},Microsoft.FSharp.Math.Matrix`1{``0})">
<summary>
 Point-wise addition of two matrices.  An InvalidArgument exception will be
 raised if the dimensions do not match.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.op_AdditionAssignment(Microsoft.FSharp.Math.Matrix`1{``0},Microsoft.FSharp.Math.Matrix`1{``0})">
<summary>
 Inplace matrix addition. An InvalidArgument exception will be
 raised if the dimensions do not match. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.op_DollarMultiply(``0,Microsoft.FSharp.Math.Matrix`1{``0})">
<summary>
 Multiply each element of a matrix by the given scalar value
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.op_DotMultiply(Microsoft.FSharp.Math.Matrix`1{``0},Microsoft.FSharp.Math.Matrix`1{``0})">
<summary>
 Pointwise matrix multiplication.   An InvalidArgument exception will be
 raised if the dimensions do not match.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.op_DotMultiplyEquals(Microsoft.FSharp.Math.Matrix`1{``0},Microsoft.FSharp.Math.Matrix`1{``0})">
<summary>
 Inplace pointwise matrix multiplication. An InvalidArgument exception will be
 raised if the dimensions do not match.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.op_Multiply(Microsoft.FSharp.Math.Matrix`1{``0},Microsoft.FSharp.Math.Matrix`1{``0})">
<summary>
 Matrix multiplication.   An InvalidArgument exception will be
 raised if the dimensions do not match.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.op_Multiply(Microsoft.FSharp.Math.Matrix`1{``0},Microsoft.FSharp.Math.Vector`1{``0})">
<summary>
 Matrix-vector multiplication.   
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.op_MultiplyDollar(Microsoft.FSharp.Math.Matrix`1{``0},``0)">
<summary>
 Multiply each element of a matrix by the given scalar value
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.op_Subtraction(Microsoft.FSharp.Math.Matrix`1{``0},Microsoft.FSharp.Math.Matrix`1{``0})">
<summary>
 Point-wise subtraction of two matrices. An InvalidArgument exception will be
 raised if the dimensions do not match.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.op_SubtractionAssignment(Microsoft.FSharp.Math.Matrix`1{``0},Microsoft.FSharp.Math.Matrix`1{``0})">
<summary>
 Inplace matrix subtraction. An InvalidArgument exception will be
 raised if the dimensions do not match.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.op_UnaryNegation(Microsoft.FSharp.Math.Matrix`1{``0})">
<summary>
 Matrix negation.   
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix`1.op_UnaryPlus(Microsoft.FSharp.Math.Matrix`1{``0})">
<summary>
 A nop.
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Matrix`1.Item(System.Int32,System.Int32,``0)">
<summary>
 Get the item at the given position in the matrix
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.Matrix`1">
 <summary>
 The type of matrices.  The arithmetic operations on the element type are determined by inspection on the element type itself
 </summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVector`1.Equals(System.Object)">

</member>
<member name="M:Microsoft.FSharp.Math.RowVector`1.GetHashCode">

</member>
<member name="M:Microsoft.FSharp.Math.RowVector`1.GetSlice(Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32})">

</member>
<member name="M:Microsoft.FSharp.Math.RowVector`1.Pin``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.nativeptr`1{``0},``1})">
<summary>
 For native interop. Pin the given object for the duration of a single call to the given function.  A native pointer to
 the (0,0) element in the underlying array is passed to the given function.  Resources associated with the 
 pin are released when the function completes, even if an exception is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVector`1.PinHandle">
<summary>
 Pin the given matrix, but the caller is responsible for freeing the GCHandle
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.RowVector`1.ElementOps">

</member>
<member name="P:Microsoft.FSharp.Math.RowVector`1.Item(System.Int32)">

</member>
<member name="P:Microsoft.FSharp.Math.RowVector`1.Length">

</member>
<member name="P:Microsoft.FSharp.Math.RowVector`1.NumCols">

</member>
<member name="P:Microsoft.FSharp.Math.RowVector`1.Transpose">

</member>
<member name="M:Microsoft.FSharp.Math.RowVector`1.op_Addition(Microsoft.FSharp.Math.RowVector`1{``0},Microsoft.FSharp.Math.RowVector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.RowVector`1.op_AdditionAssignment(Microsoft.FSharp.Math.RowVector`1{``0},Microsoft.FSharp.Math.RowVector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.RowVector`1.op_DollarMultiply(``0,Microsoft.FSharp.Math.RowVector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.RowVector`1.op_DotMultiply(Microsoft.FSharp.Math.RowVector`1{``0},Microsoft.FSharp.Math.RowVector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.RowVector`1.op_DotMultiplyEquals(Microsoft.FSharp.Math.RowVector`1{``0},Microsoft.FSharp.Math.RowVector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.RowVector`1.op_Multiply(Microsoft.FSharp.Math.RowVector`1{``0},Microsoft.FSharp.Math.Vector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.RowVector`1.op_Multiply(Microsoft.FSharp.Math.RowVector`1{``0},Microsoft.FSharp.Math.Matrix`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.RowVector`1.op_Multiply(Microsoft.FSharp.Math.RowVector`1{``0},``0)">

</member>
<member name="M:Microsoft.FSharp.Math.RowVector`1.op_Subtraction(Microsoft.FSharp.Math.RowVector`1{``0},Microsoft.FSharp.Math.RowVector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.RowVector`1.op_SubtractionAssignment(Microsoft.FSharp.Math.RowVector`1{``0},Microsoft.FSharp.Math.RowVector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.RowVector`1.op_UnaryNegation(Microsoft.FSharp.Math.RowVector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.RowVector`1.op_UnaryPlus(Microsoft.FSharp.Math.RowVector`1{``0})">

</member>
<member name="P:Microsoft.FSharp.Math.RowVector`1.Item(System.Int32,``0)">

</member>
<member name="T:Microsoft.FSharp.Math.RowVector`1">
 <summary>
 The type of row vectors.  This type is included mostly only for completeness
 and is used relatively rarely.
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.SparseMatrix`1">

</member>
<member name="M:Microsoft.FSharp.Math.Vector`1.Equals(System.Object)">

</member>
<member name="M:Microsoft.FSharp.Math.Vector`1.GetHashCode">

</member>
<member name="M:Microsoft.FSharp.Math.Vector`1.GetSlice(Microsoft.FSharp.Core.Option`1{System.Int32},Microsoft.FSharp.Core.Option`1{System.Int32})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector`1.Pin``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.nativeptr`1{``0},``1})">
<summary>
 For native interop. Pin the given object for the duration of a single call to the given function.  A native pointer to
 the (0,0) element in the underlying array is passed to the given function.  Resources associated with the 
 pin are released when the function completes, even if an exception is raised.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector`1.PinHandle">
<summary>
 For native interop. Pin the given object, but the caller is responsible for freeing the GCHandle
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Vector`1.ElementOps">

</member>
<member name="P:Microsoft.FSharp.Math.Vector`1.Item(System.Int32)">

</member>
<member name="P:Microsoft.FSharp.Math.Vector`1.Length">

</member>
<member name="P:Microsoft.FSharp.Math.Vector`1.NumRows">

</member>
<member name="P:Microsoft.FSharp.Math.Vector`1.Transpose">

</member>
<member name="M:Microsoft.FSharp.Math.Vector`1.op_Addition(Microsoft.FSharp.Math.Vector`1{``0},Microsoft.FSharp.Math.Vector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector`1.op_AdditionAssignment(Microsoft.FSharp.Math.Vector`1{``0},Microsoft.FSharp.Math.Vector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector`1.op_DollarMultiply(``0,Microsoft.FSharp.Math.Vector`1{``0})">
<summary>
 Multiply each element of a vector by the given scalar value. An InvalidArgument exception will be
 raised if the dimensions do not match.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector`1.op_DotMultiply(Microsoft.FSharp.Math.Vector`1{``0},Microsoft.FSharp.Math.Vector`1{``0})">
<summary>
 Pointwise multiplication of two vectors.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector`1.op_DotMultiplyEquals(Microsoft.FSharp.Math.Vector`1{``0},Microsoft.FSharp.Math.Vector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector`1.op_Multiply(Microsoft.FSharp.Math.Vector`1{``0},Microsoft.FSharp.Math.RowVector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector`1.op_Multiply(Microsoft.FSharp.Math.Vector`1{``0},``0)">

</member>
<member name="M:Microsoft.FSharp.Math.Vector`1.op_Subtraction(Microsoft.FSharp.Math.Vector`1{``0},Microsoft.FSharp.Math.Vector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector`1.op_SubtractionAssignment(Microsoft.FSharp.Math.Vector`1{``0},Microsoft.FSharp.Math.Vector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector`1.op_UnaryNegation(Microsoft.FSharp.Math.Vector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector`1.op_UnaryPlus(Microsoft.FSharp.Math.Vector`1{``0})">

</member>
<member name="P:Microsoft.FSharp.Math.Vector`1.Item(System.Int32,``0)">

</member>
<member name="T:Microsoft.FSharp.Math.Vector`1">
 <summary>
 The type of column vectors.  The arithmetic operations on the element type are determined by inspection on the element type itself
 </summary>
</member>
<member name="T:Microsoft.FSharp.Math.complex">
<summary>
 The type of complex numbers 
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.matrix">
<summary>
 The type of floating point matrices
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.opsData`1">

</member>
<member name="T:Microsoft.FSharp.Math.rowvec">
<summary>
 The type of floating point row vectors
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.vector">
<summary>
 The type of floating point column vectors
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.BigInt.abs(Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.add(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.bits(Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.compare(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.div(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.divmod(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.equal(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.factorial(Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.gt(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.gte(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.hash(Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.hcf(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.isOne(Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.isZero(Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.lt(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.lte(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.max(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.min(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.mul(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.neg(Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.negative(Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.of_int(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.of_int64(System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.of_string(System.String)">

</member>
<member name="P:Microsoft.FSharp.Math.BigInt.one">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.positive(Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.pow(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.powi(Microsoft.FSharp.Math.BigInt,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.rem(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.scale(System.Int32,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.sign(Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.sub(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.to_float(Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.to_int(Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.to_int64(Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigInt.to_string(Microsoft.FSharp.Math.BigInt)">

</member>
<member name="P:Microsoft.FSharp.Math.BigInt.zero">

</member>
<member name="T:Microsoft.FSharp.Math.BigInt">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.abs(Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.add(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.compare(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.div(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.equal(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.gt(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.gte(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.lt(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.lte(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.max(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.min(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.mul(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.neg(Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.negative(Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.of_bigint(Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.of_int(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.of_string(System.String)">

</member>
<member name="P:Microsoft.FSharp.Math.BigNum.one">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.positive(Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.powi(Microsoft.FSharp.Math.BigNum,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.sign(Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.sub(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.to_bigint(Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.to_float(Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.to_int(Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Math.BigNum.to_string(Microsoft.FSharp.Math.BigNum)">

</member>
<member name="P:Microsoft.FSharp.Math.BigNum.zero">

</member>
<member name="T:Microsoft.FSharp.Math.BigNum">

</member>
<member name="P:Microsoft.FSharp.Math.Complex.Numerics">
<summary>
 An abstract representation of the numeric operations
 supported by this type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.add(Microsoft.FSharp.Math.Complex,Microsoft.FSharp.Math.Complex)">
<summary>
 Add two complex numbers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.cis(System.Double)">
<summary>
 A complex of magnitude 1 and the given phase and , i.e. cis x = mkPolar 1.0 x
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.conjugate(Microsoft.FSharp.Math.Complex)">
<summary>
 The conjugate of a complex number, i.e. x-yi
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.cos(Microsoft.FSharp.Math.Complex)">
<summary>
 Cosine
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.div(Microsoft.FSharp.Math.Complex,Microsoft.FSharp.Math.Complex)">
<summary>
 Complex division of two complex numbers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.exp(Microsoft.FSharp.Math.Complex)">
<summary>
 exp(x) = e^x
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.imagPart(Microsoft.FSharp.Math.Complex)">
<summary>
 The imaginary part of a complex number
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.log(Microsoft.FSharp.Math.Complex)">
<summary>
 log(x) is natural log (base e)
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.magnitude(Microsoft.FSharp.Math.Complex)">
<summary>
 The polar-coordinate magnitude of a complex number
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.mkPolar(System.Double,System.Double)">
<summary>
 Create a complex number using magnitude/phase polar coordinates
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.mkRect(System.Double,System.Double)">

</member>
<member name="M:Microsoft.FSharp.Math.Complex.mul(Microsoft.FSharp.Math.Complex,Microsoft.FSharp.Math.Complex)">
<summary>
 Multiply two complex numbers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.muls(Microsoft.FSharp.Math.Complex,System.Double)">
<summary>
 Multiply a complex number by a scalar
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.neg(Microsoft.FSharp.Math.Complex)">
<summary>
 Unary negation of a complex number
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Complex.one">
<summary>
 The complex number 1+0i
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Complex.onei">
<summary>
 The complex number 0+1i
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.phase(Microsoft.FSharp.Math.Complex)">
<summary>
 The polar-coordinate phase of a complex number
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Complex.pi">
<summary>
 pi
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.realPart(Microsoft.FSharp.Math.Complex)">
<summary>
 The real part of a complex number
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.sin(Microsoft.FSharp.Math.Complex)">
<summary>
 Sine
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.smul(System.Double,Microsoft.FSharp.Math.Complex)">
<summary>
 Multiply a scalar by a complex number 
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.sqrt(Microsoft.FSharp.Math.Complex)">
<summary>
 sqrt(x) and 0 &lt;= phase(x) &lt; pi
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.sub(Microsoft.FSharp.Math.Complex,Microsoft.FSharp.Math.Complex)">
<summary>
 Subtract one complex number from another
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Complex.tan(Microsoft.FSharp.Math.Complex)">
<summary>
 Tagent
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Complex.zero">
<summary>
 The complex number 0+0i
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.Complex">

</member>
<member name="M:Microsoft.FSharp.Math.GlobalAssociations.GetNumericAssociation``1">

</member>
<member name="M:Microsoft.FSharp.Math.GlobalAssociations.GetNumericAssociationOption``1">

</member>
<member name="M:Microsoft.FSharp.Math.GlobalAssociations.RegisterNumericAssociation``2(``0)">

</member>
<member name="M:Microsoft.FSharp.Math.GlobalAssociations.getNumericAssociation``1(Microsoft.FSharp.Core.ReifiedType`1{``0})">
<summary>
 Attempt to determine a numeric association for the given type, i.e. a registered dictionary of
 numeric operations.  The interface can be queried dynamically for additional functionality in the numerics
 hierarchy.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.GlobalAssociations.registerNumericAssociation``2(Microsoft.FSharp.Core.ReifiedType`1{``0},``1)">
<summary>
 Record an AppDomain-wide association between the given type and the given dictionary of
 numeric operations.  Raise an error if an existing association already exists. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.GlobalAssociations">
<summary>
 Associations are a way of associating dictionaries of
 operations with given types at runtime.  Associations are global to a 
 .NET application domain.  Once specified an association may not be deleted
 or modified.

 In this release the system of associations is simply 
 limited to a registry of types that support dictionaries (i.e. interface objects)
 of numeric operations.  The following types are pre-registered with associated numeric
 operations: float, int32, int64, bigint, float32, Complex, bignum.  Other types must be
 registered explicitly by user code.

</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Instances.BigIntNumerics">

</member>
<member name="P:Microsoft.FSharp.Math.Instances.BigNumNumerics">

</member>
<member name="P:Microsoft.FSharp.Math.Instances.Float32Numerics">

</member>
<member name="P:Microsoft.FSharp.Math.Instances.FloatNumerics">

</member>
<member name="P:Microsoft.FSharp.Math.Instances.Int32Numerics">

</member>
<member name="P:Microsoft.FSharp.Math.Instances.Int64Numerics">

</member>
<member name="T:Microsoft.FSharp.Math.Instances">

</member>
<member name="M:Microsoft.FSharp.Math.LinearAlgebra.cholesky(Microsoft.FSharp.Math.Matrix`1{System.Double})">

</member>
<member name="M:Microsoft.FSharp.Math.LinearAlgebra.choleskyFactor(Microsoft.FSharp.Math.Matrix`1{System.Double})">

</member>
<member name="M:Microsoft.FSharp.Math.LinearAlgebra.determinant(Microsoft.FSharp.Math.Matrix`1{System.Double})">

</member>
<member name="M:Microsoft.FSharp.Math.LinearAlgebra.isLowerTriangular(Microsoft.FSharp.Math.Matrix`1{System.Double})">

</member>
<member name="M:Microsoft.FSharp.Math.LinearAlgebra.isSymmetric(Microsoft.FSharp.Math.Matrix`1{System.Double})">

</member>
<member name="M:Microsoft.FSharp.Math.LinearAlgebra.lowerTriangularInverse(Microsoft.FSharp.Math.Matrix`1{System.Double})">

</member>
<member name="M:Microsoft.FSharp.Math.LinearAlgebra.symmetricInverse(Microsoft.FSharp.Math.Matrix`1{System.Double})">

</member>
<member name="T:Microsoft.FSharp.Math.LinearAlgebra">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.add(Microsoft.FSharp.Math.Matrix`1{System.Double},Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
Add two matrices (operator +)
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.constDiag(System.Int32,System.Double)">
<summary>
 Create a square matrix with the constant lying on diagonal
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.copy(Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
 Create a new matrix that is a copy of the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.cptMax(Microsoft.FSharp.Math.Matrix`1{System.Double},Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
Point-wise maximum element of two matrices
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.cptMin(Microsoft.FSharp.Math.Matrix`1{System.Double},Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
Point-wise minimum element of two matrices
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.cptMul(Microsoft.FSharp.Math.Matrix`1{System.Double},Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
Point-wise multiplication of two matrices (operator .*)
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.cptPow(Microsoft.FSharp.Math.Matrix`1{System.Double},System.Double)">
<summary>
Pointwise exponential of a matrix.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.create(System.Int32,System.Int32,System.Double)">
<summary>
 Create a matrix with all entries the given constant
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.diag(Microsoft.FSharp.Math.Vector`1{System.Double})">
<summary>
 Create a square matrix with the given vector lying on diagonal
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.dims(Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
 Get the dimensions of a matrix (rows x columns)
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.dot(Microsoft.FSharp.Math.Matrix`1{System.Double},Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
Dot product
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.exists(Microsoft.FSharp.Core.FastFunc`2{System.Double,System.Boolean},Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
 Check if a predicate holds for at least one element of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.existsi(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Double,System.Boolean}}},Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
 Check if a predicate holds for at least one element of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.fold``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{System.Double,``0}},``0,Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
 Fold the given function over all elements of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.foldByCol``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{System.Double,``0}},Microsoft.FSharp.Math.RowVector`1{``0},Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
 Fold the given function down each column of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.foldByRow``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{System.Double,``0}},Microsoft.FSharp.Math.Vector`1{``0},Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
 Fold the given function along each row of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.foldCol``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{System.Double,``0}},``0,Microsoft.FSharp.Math.Matrix`1{System.Double},System.Int32)">
<summary>
 Fold the given function along a particular column of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.foldRow``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{System.Double,``0}},``0,Microsoft.FSharp.Math.Matrix`1{System.Double},System.Int32)">
<summary>
 Fold the given function down a particular row of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.foldi``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{System.Double,``0}}}},``0,Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
 Fold the given function over all elements of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.forall(Microsoft.FSharp.Core.FastFunc`2{System.Double,System.Boolean},Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
 Check if a predicate holds for all elements of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.foralli(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Double,System.Boolean}}},Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
 Check if a predicate holds for all elements of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.get(Microsoft.FSharp.Math.Matrix`1{System.Double},System.Int32,System.Int32)">
<summary>
 Get an element of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.getCol(Microsoft.FSharp.Math.Matrix`1{System.Double},System.Int32)">
<summary>
 Select a column from a matrix as a vector.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.getCols(Microsoft.FSharp.Math.Matrix`1{System.Double},System.Int32,System.Int32)">
<summary>
 Select a number of columns from a matrix.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.getDiag(Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
 Return the primary diagonal of a matrix, as a vector.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.getDiagN(Microsoft.FSharp.Math.Matrix`1{System.Double},System.Int32)">
<summary>
 Return the nth diagonal of a matrix, as a vector.  Diagonal 0 is the primary
 diagonal, positive diagonals are further to the upper-right of the matrix.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.getRegion(Microsoft.FSharp.Math.Matrix`1{System.Double},System.Int32,System.Int32,System.Int32,System.Int32)">
<summary>
 Select a region from a matrix.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.getRow(Microsoft.FSharp.Math.Matrix`1{System.Double},System.Int32)">
<summary>
 Select a row from a matrix as a row vector.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.getRows(Microsoft.FSharp.Math.Matrix`1{System.Double},System.Int32,System.Int32)">
<summary>
 Select a number of rows from a matrix. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.identity(System.Int32)">
<summary>
 Create a square matrix with the constant 1.0 lying on diagonal
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.init(System.Int32,System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,System.Double}})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.init_dense``1(System.Int32,System.Int32,``0)">
<summary>
 Create a matrix with the given entries. 
 Create a dense representation matrix with the given entries. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.init_sparse``1(System.Int32,System.Int32,``0)">
<summary>
 Create a sparse representation matrix with the given entries. Not all 
 operations are yet supported for sparse matrices, and mutation is not
 supported at all. If an operation on sparse matrices raises a runtime exception then you may
 need to convert to dense matrices using to_dense.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.inplace_add(Microsoft.FSharp.Math.Matrix`1{System.Double},Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
 In-place addition mutates first matrix argument.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.inplace_assign(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,System.Double}},Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
 In-place assign mutates matrix argument. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.inplace_cptMul(Microsoft.FSharp.Math.Matrix`1{System.Double},Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
 In-place componentwise-multiplication mutates first matrix argument. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.inplace_mapi(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Double,System.Double}}},Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
 In-place map mutates matrix argument.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.inplace_scale(System.Double,Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
 In-place scaling mutates matrix argument.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.inplace_sub(Microsoft.FSharp.Math.Matrix`1{System.Double},Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
 In-place subtraction mutates first matrix argument. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.map(Microsoft.FSharp.Core.FastFunc`2{System.Double,System.Double},Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
 Map the given function over each element of the matrix, producing a new matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.mapi(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Double,System.Double}}},Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
 Map the given indexed function over each element of the matrix, producing a new matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.mul(Microsoft.FSharp.Math.Matrix`1{System.Double},Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
Multiply two matrices (operator * )
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.mulRV(Microsoft.FSharp.Math.RowVector`1{System.Double},Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
Multiply row vector by matrix (operator *% )
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.mulV(Microsoft.FSharp.Math.Matrix`1{System.Double},Microsoft.FSharp.Math.Vector`1{System.Double})">
<summary>
Multiply matrix by vector (operator *% )
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.ncols(Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
 Get the number of columns of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.neg(Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
Negation of the matrix (each element is negated) (unary operator -)
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.nonzero_entries(Microsoft.FSharp.Math.Matrix`1{System.Double})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.norm(Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
sum(x*x) of all the elements of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.nrows(Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
 Get the number of rows of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.of_array2(System.Double[,]`1)">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.of_list(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Collections.List`1{System.Double}})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.of_rowvec(Microsoft.FSharp.Math.RowVector`1{System.Double})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.of_scalar(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.of_seq``2(``0)">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.of_vector(Microsoft.FSharp.Math.Vector`1{System.Double})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.prod(Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
Multiply all the elements of the matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.randomize(Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
Generate a new matrix of the same size as the input with random entries 
drawn from the range 0..aij.  Random numbers are generated using a globally 
shared System.Random instance with the initial seed 99.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.scale(System.Double,Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
Pointwise multiplication of a matrix by a scalar
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.set(Microsoft.FSharp.Math.Matrix`1{System.Double},System.Int32,System.Int32,System.Double)">
<summary>
 Set an element of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.sub(Microsoft.FSharp.Math.Matrix`1{System.Double},Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
Subtract one matrix from another (operator -)
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.sum(Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
Sum all the elements of a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.to_array2(Microsoft.FSharp.Math.Matrix`1{System.Double})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.to_dense(Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
 Ensure that a matrix uses dense representation.  See init_sparse
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.to_rowvec(Microsoft.FSharp.Math.Matrix`1{System.Double})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.to_scalar(Microsoft.FSharp.Math.Matrix`1{System.Double})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.to_vector(Microsoft.FSharp.Math.Matrix`1{System.Double})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.trace(Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
 Sum of the diagonal elements of the matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.transpose(Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
Transpose of a matrix.  Use also m.Transpose
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.zero(System.Int32,System.Int32)">
<summary>
 Create a matrix with all entries zero
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.add``1(Microsoft.FSharp.Math.Matrix`1{``0},Microsoft.FSharp.Math.Matrix`1{``0})">
<summary>
 Matrix addition.
 The element type of the matrix must have an associated instance of INumeric&lt;'a&gt; (see [[GlobalAssociations]]) (else InvalidArgumentException).
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.compare``1(Microsoft.FSharp.Math.Matrix`1{``0},Microsoft.FSharp.Math.Matrix`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.constDiag``1(System.Int32,``0)">
<summary>
 Create a diagonal square matrix containing the given value along the diagonal.
 The element type of the matrix must have an associated instance of INumeric&lt;'a&gt; (see [[GlobalAssociations]]) (else InvalidArgumentException).
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.copy``1(Microsoft.FSharp.Math.Matrix`1{``0})">
<summary>
 Create a new matrix that is a copy of the given array
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.cptMax``1(Microsoft.FSharp.Math.Matrix`1{``0},Microsoft.FSharp.Math.Matrix`1{``0})">
<summary>
Take the pointwise maximum of two matrices
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.cptMin``1(Microsoft.FSharp.Math.Matrix`1{``0},Microsoft.FSharp.Math.Matrix`1{``0})">
<summary>
Take the pointwise maximum of two matrices
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.cptMul``1(Microsoft.FSharp.Math.Matrix`1{``0},Microsoft.FSharp.Math.Matrix`1{``0})">
<summary>
 Matrix pointwise-multiplication.
 The element type of the matrix must have an associated instance of INumeric&lt;'a&gt; (see [[GlobalAssociations]]) (else InvalidArgumentException).
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.create``1(System.Int32,System.Int32,``0)">
<summary>
 Create a matrix containing the given value at every element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.diag``1(Microsoft.FSharp.Math.Vector`1{``0})">
<summary>
 Create a matrix containing the given vector along the diagonal.
 The element type of the matrix must have an associated instance of INumeric&lt;'a&gt; (see [[GlobalAssociations]]) (else InvalidArgumentException).
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.dims``1(Microsoft.FSharp.Math.Matrix`1{``0})">
<summary>
 Get the number of (rows,columns) in a matrix.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.dot``1(Microsoft.FSharp.Math.Matrix`1{``0},Microsoft.FSharp.Math.Matrix`1{``0})">
<summary>
 Sum of the point-wise multiple of the two matrices.
 The element type of the matrix must have an associated instance of INumeric&lt;'a&gt; (see [[GlobalAssociations]]) (else InvalidArgumentException).
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.eops``1(Microsoft.FSharp.Math.Matrix`1{``0})">
<summary>
 Get the dictionary of operations assocaited with the element type
 The element type of the matrix must have an associated instance of INumeric&lt;'a&gt; (see [[GlobalAssociations]]) (else InvalidArgumentException).
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.exists``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Math.Matrix`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.existsi``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean}}},Microsoft.FSharp.Math.Matrix`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.fold``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,Microsoft.FSharp.Math.Matrix`1{``1})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.foldi``2(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}}}},``0,Microsoft.FSharp.Math.Matrix`1{``1})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.forall``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Math.Matrix`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.foralli``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean}}},Microsoft.FSharp.Math.Matrix`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.get``1(Microsoft.FSharp.Math.Matrix`1{``0},System.Int32,System.Int32)">
<summary>
 Get an element from a matrix.  The indexes are given in row/column order.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.getCol``1(Microsoft.FSharp.Math.Matrix`1{``0},System.Int32)">
<summary>
 Select a column from a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.getCols``1(Microsoft.FSharp.Math.Matrix`1{``0},System.Int32,System.Int32)">
<summary>
 Select a range of columns from a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.getDiag``1(Microsoft.FSharp.Math.Matrix`1{``0})">
<summary>
Return the diagonal of a matrix as a vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.getDiagN``1(Microsoft.FSharp.Math.Matrix`1{``0},System.Int32)">
<summary>
Return the nth diagonal of a matrix as a vector
 The 0th index is the main diagonal, and higher indexes are further to the upper-right of the matrix.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.getRegion``1(Microsoft.FSharp.Math.Matrix`1{``0},System.Int32,System.Int32,System.Int32,System.Int32)">
<summary>
 Select a region from a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.getRow``1(Microsoft.FSharp.Math.Matrix`1{``0},System.Int32)">
<summary>
 Select a row from a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.getRows``1(Microsoft.FSharp.Math.Matrix`1{``0},System.Int32,System.Int32)">
<summary>
 Select a range of rows from a matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.hash``1(Microsoft.FSharp.Math.Matrix`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.identity``1(System.Int32)">
<summary>
 Create a square matrix with the one for the element type lying on diagonal
 The element type of the matrix must have an associated instance of INumeric&lt;'a&gt; (see [[GlobalAssociations]]) (else InvalidArgumentException).
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.init``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0}})">
<summary>
 Create a matrix using the given function to compute the item at each index.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.init_dense``2(System.Int32,System.Int32,``0)">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.init_numeric``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Math.INumeric`1{``0},Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0}}})">
<summary>
 Create a matrix using the given function to compute the item at each index.
 The element type of the matrix must have an associated instance of INumeric&lt;'a&gt; (see [[GlobalAssociations]]) (else InvalidArgumentException).
 The function is passed the dictionary of associated operations in addition to the index pair.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.init_sparse``2(System.Int32,System.Int32,``0)">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.inplace_add``1(Microsoft.FSharp.Math.Matrix`1{``0},Microsoft.FSharp.Math.Matrix`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.inplace_assign``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0}},Microsoft.FSharp.Math.Matrix`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.inplace_cptMul``1(Microsoft.FSharp.Math.Matrix`1{``0},Microsoft.FSharp.Math.Matrix`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.inplace_mapi``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,``0}}},Microsoft.FSharp.Math.Matrix`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.inplace_scale``1(``0,Microsoft.FSharp.Math.Matrix`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.inplace_sub``1(Microsoft.FSharp.Math.Matrix`1{``0},Microsoft.FSharp.Math.Matrix`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.map``1(Microsoft.FSharp.Core.FastFunc`2{``0,``0},Microsoft.FSharp.Math.Matrix`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.mapi``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,``0}}},Microsoft.FSharp.Math.Matrix`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.mul``1(Microsoft.FSharp.Math.Matrix`1{``0},Microsoft.FSharp.Math.Matrix`1{``0})">
<summary>
 Matrix multiplication.
 The element type of the matrix must have an associated instance of INumeric&lt;'a&gt; (see [[GlobalAssociations]]) (else InvalidArgumentException).
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.mulRV``1(Microsoft.FSharp.Math.RowVector`1{``0},Microsoft.FSharp.Math.Matrix`1{``0})">
<summary>
 Matrix multiplication.
 The element type of the matrix must have an associated instance of INumeric&lt;'a&gt; (see [[GlobalAssociations]]) (else InvalidArgumentException).
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.mulV``1(Microsoft.FSharp.Math.Matrix`1{``0},Microsoft.FSharp.Math.Vector`1{``0})">
<summary>
 Matrix multiplication.
 The element type of the matrix must have an associated instance of INumeric&lt;'a&gt; (see [[GlobalAssociations]]) (else InvalidArgumentException).
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.ncols``1(Microsoft.FSharp.Math.Matrix`1{``0})">
<summary>
 Get the number of columns in a matrix.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.neg``1(Microsoft.FSharp.Math.Matrix`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.nonzero_entries``1(Microsoft.FSharp.Math.Matrix`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.norm``1(Microsoft.FSharp.Math.Matrix`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.nrows``1(Microsoft.FSharp.Math.Matrix`1{``0})">
<summary>
 Get the number of rows in a matrix.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.of_array2``1(``0[,]`1)">
<summary>
 Create a matrix from the given (usually constant) data  
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.of_list``1(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Collections.List`1{``0}})">
<summary>
 Create a matrix from the given (usually constant) data  
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.of_rowvec``1(Microsoft.FSharp.Math.RowVector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.of_scalar``1(``0)">
<summary>
 Create a 1x1 matrix containing the given value 
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.of_seq``3(``0)">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.of_vector``1(Microsoft.FSharp.Math.Vector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.prod``1(Microsoft.FSharp.Math.Matrix`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.scale``1(``0,Microsoft.FSharp.Math.Matrix`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.set``1(Microsoft.FSharp.Math.Matrix`1{``0},System.Int32,System.Int32,``0)">
<summary>
 Set an element in a matrix.  The indexes are given in row/column order.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.sub``1(Microsoft.FSharp.Math.Matrix`1{``0},Microsoft.FSharp.Math.Matrix`1{``0})">
<summary>
 Matrix subtraction.
 The element type of the matrix must have an associated instance of INumeric&lt;'a&gt; (see [[GlobalAssociations]]) (else InvalidArgumentException).
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.sum``1(Microsoft.FSharp.Math.Matrix`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.to_array2``1(Microsoft.FSharp.Math.Matrix`1{``0})">
<summary>
 Return a new array containing the elements of the given matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.to_rowvec``1(Microsoft.FSharp.Math.Matrix`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.to_scalar``1(Microsoft.FSharp.Math.Matrix`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.to_vector``1(Microsoft.FSharp.Math.Matrix`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.trace``1(Microsoft.FSharp.Math.Matrix`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.transpose``1(Microsoft.FSharp.Math.Matrix`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Matrix.Generic.zero``1(System.Int32,System.Int32)">
<summary>
 Create a matrix containing the zero element at each index.
 The element type of the matrix must have an associated instance of INumeric&lt;'a&gt; (see [[GlobalAssociations]]) (else InvalidArgumentException).
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.Matrix.Generic">
<summary>
 Operations to manipulate matrix types carrying
 arbitrary element types.  The names and types of the operations match those
 in the containing module Math.Matrix.  

 The numeric operations on the element type (add, zero etc.) are inferred from the type
 argument itself. That is, for some operations 
 the element type of the matrix must have an associated instance of INumeric&lt;'a&gt; 
 or some more specific numeric association (see [[GlobalAssociations]]) (else InvalidArgumentException).
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.Matrix">
<summary>
 Operations to manipulate floating
 point matrices.  The submodule [[Matrix.Generic]] contains a 
 matching set of operations to manipulate matrix types carrying
 arbitrary element types.
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.Notation.complex">
<summary>
 The type of complex numbers
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.Notation.matrix">
<summary>
 The type of floating point matrices
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.Notation.rowvec">
<summary>
 The type of floating point row vectors
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.Notation.vector">
<summary>
 The type of floating point column vectors
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Notation.M2S(Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
 Convert a matrix to a scalar.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Notation.M2V(Microsoft.FSharp.Math.Matrix`1{System.Double})">
<summary>
 Convert a matrix to a column vector. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Notation.S(System.Double)">
<summary>
 Create a matrix from a scalar.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Notation.V(Microsoft.FSharp.Math.Vector`1{System.Double})">
<summary>
 Create a matrix from a column vector.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Notation.complex(System.Double,System.Double)">
<summary>
 Create a complex number x+ij using rectangular coordinates
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Notation.matrix``2(``0)">
<summary>
 Create a matrix from lists of floats.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Notation.rowvec``1(``0)">
<summary>
 Create a row vector from lists of floats. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Notation.vector``1(``0)">
<summary>
 Create a column vector from lists of floats.
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.Notation.Generic.matrix`1">
<summary>
 The type of floating point matrices
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.Notation.Generic.rowvec`1">
<summary>
 The type of floating point row vectors
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.Notation.Generic.vector`1">
<summary>
 The type of floating point column vectors
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Notation.Generic.M2S``1(Microsoft.FSharp.Math.Matrix`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Notation.Generic.M2V``1(Microsoft.FSharp.Math.Matrix`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Notation.Generic.S``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Math.Notation.Generic.V``1(Microsoft.FSharp.Math.Vector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Notation.Generic.complex(System.Double,System.Double)">
<summary>
 Create a complex number x+ij using rectangular coordinates
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Notation.Generic.matrix``3(``0)">

</member>
<member name="M:Microsoft.FSharp.Math.Notation.Generic.rowvec``2(``0)">

</member>
<member name="M:Microsoft.FSharp.Math.Notation.Generic.vector``2(``0)">

</member>
<member name="T:Microsoft.FSharp.Math.Notation.Generic">
<summary>
 This module contains notation related to matrices and vectors carrying arbitrary element types.
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.Notation">
<summary>
 This module contains notation related to matrices and vectors
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.Primitives.BigNat">
<summary>
 Abstract internal type
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.Primitives.BigNat.n">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.BigNat.add(Microsoft.FSharp.Math.Primitives.BigNat,Microsoft.FSharp.Math.Primitives.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.BigNat.bits(Microsoft.FSharp.Math.Primitives.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.BigNat.compare(Microsoft.FSharp.Math.Primitives.BigNat,Microsoft.FSharp.Math.Primitives.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.BigNat.div(Microsoft.FSharp.Math.Primitives.BigNat,Microsoft.FSharp.Math.Primitives.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.BigNat.divmod(Microsoft.FSharp.Math.Primitives.BigNat,Microsoft.FSharp.Math.Primitives.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.BigNat.equal(Microsoft.FSharp.Math.Primitives.BigNat,Microsoft.FSharp.Math.Primitives.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.BigNat.factorial(Microsoft.FSharp.Math.Primitives.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.BigNat.get_small(Microsoft.FSharp.Math.Primitives.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.BigNat.gt(Microsoft.FSharp.Math.Primitives.BigNat,Microsoft.FSharp.Math.Primitives.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.BigNat.gte(Microsoft.FSharp.Math.Primitives.BigNat,Microsoft.FSharp.Math.Primitives.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.BigNat.hash(Microsoft.FSharp.Math.Primitives.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.BigNat.hcf(Microsoft.FSharp.Math.Primitives.BigNat,Microsoft.FSharp.Math.Primitives.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.BigNat.isOne(Microsoft.FSharp.Math.Primitives.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.BigNat.isZero(Microsoft.FSharp.Math.Primitives.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.BigNat.is_small(Microsoft.FSharp.Math.Primitives.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.BigNat.lt(Microsoft.FSharp.Math.Primitives.BigNat,Microsoft.FSharp.Math.Primitives.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.BigNat.lte(Microsoft.FSharp.Math.Primitives.BigNat,Microsoft.FSharp.Math.Primitives.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.BigNat.max(Microsoft.FSharp.Math.Primitives.BigNat,Microsoft.FSharp.Math.Primitives.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.BigNat.min(Microsoft.FSharp.Math.Primitives.BigNat,Microsoft.FSharp.Math.Primitives.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.BigNat.mul(Microsoft.FSharp.Math.Primitives.BigNat,Microsoft.FSharp.Math.Primitives.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.BigNat.of_int(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.BigNat.of_int64(System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.BigNat.of_string(System.String)">

</member>
<member name="P:Microsoft.FSharp.Math.Primitives.BigNat.one">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.BigNat.pow(Microsoft.FSharp.Math.Primitives.BigNat,Microsoft.FSharp.Math.Primitives.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.BigNat.powi(Microsoft.FSharp.Math.Primitives.BigNat,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.BigNat.rem(Microsoft.FSharp.Math.Primitives.BigNat,Microsoft.FSharp.Math.Primitives.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.BigNat.scale(System.Int32,Microsoft.FSharp.Math.Primitives.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.BigNat.sub(Microsoft.FSharp.Math.Primitives.BigNat,Microsoft.FSharp.Math.Primitives.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.BigNat.to_float(Microsoft.FSharp.Math.Primitives.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.BigNat.to_int(Microsoft.FSharp.Math.Primitives.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.BigNat.to_int64(Microsoft.FSharp.Math.Primitives.BigNat)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.BigNat.to_string(Microsoft.FSharp.Math.Primitives.BigNat)">

</member>
<member name="P:Microsoft.FSharp.Math.Primitives.BigNat.two">

</member>
<member name="P:Microsoft.FSharp.Math.Primitives.BigNat.zero">

</member>
<member name="T:Microsoft.FSharp.Math.Primitives.BigNat">

</member>
<member name="T:Microsoft.FSharp.Math.Primitives.FFT.fp">
<summary>
 fp is type for the finite field.
 Currently using p = 2^27.15+1 but do not rely on that.  
 Also, do not rely on fp being represented as uint32.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Primitives.FFT.computeFftPaddedPolynomialProduct(System.Int32,System.Int32,System.UInt32[]`1,System.UInt32[]`1)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.FFT.computeFftPolynomialProduct(System.Int32,System.Int32[]`1,System.Int32,System.Int32[]`1)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.FFT.fp_of_int(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Math.Primitives.FFT.int_of_fp(System.UInt32)">

</member>
<member name="P:Microsoft.FSharp.Math.Primitives.FFT.max_bits_inside_fp">
<summary>
 "2^max_bits_inside_fp - 1" fits inside fp
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Primitives.FFT.max_fp">
<summary>
 Maximum value in Fp is p-1.
</summary>
</member>
<member name="P:Microsoft.FSharp.Math.Primitives.FFT.mone">

</member>
<member name="P:Microsoft.FSharp.Math.Primitives.FFT.mzero">

</member>
<member name="T:Microsoft.FSharp.Math.Primitives.FFT">
<summary>
 FFT multiplication used by BigNat.
 Implements polynomial multiplication provided
 the coefficients of the result (and hence of the arguments too) fit inside Fp.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVector.copy(Microsoft.FSharp.Math.RowVector`1{System.Double})">

</member>
<member name="M:Microsoft.FSharp.Math.RowVector.create(System.Int32,System.Double)">
<summary>
 Create by constant initialization
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVector.get(Microsoft.FSharp.Math.RowVector`1{System.Double},System.Int32)">
<summary>
 Get an element of a column vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVector.init(System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,System.Double})">
<summary>
 Create by comprehension
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVector.length(Microsoft.FSharp.Math.RowVector`1{System.Double})">
<summary>
 Get the dimensions (number of rows) of a column rowvec.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVector.of_array(System.Double[]`1)">
<summary>
 Create a vector from an array of double precision floats
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVector.of_list(Microsoft.FSharp.Collections.List`1{System.Double})">
<summary>
 Create a vector from a list of numbers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVector.of_seq``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Math.RowVector.set(Microsoft.FSharp.Math.RowVector`1{System.Double},System.Int32,System.Double)">
<summary>
 Set an element of a column rowvec
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVector.to_array(Microsoft.FSharp.Math.RowVector`1{System.Double})">
<summary>
 Return a new array containing a copy of the elements of the given vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVector.transpose(Microsoft.FSharp.Math.RowVector`1{System.Double})">

</member>
<member name="M:Microsoft.FSharp.Math.RowVector.Generic.copy``1(Microsoft.FSharp.Math.RowVector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.RowVector.Generic.create``1(System.Int32,``0)">
<summary>
 Create by constant initialization
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVector.Generic.get``1(Microsoft.FSharp.Math.RowVector`1{``0},System.Int32)">
<summary>
 Get an element from a column vector.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVector.Generic.init``1(System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0})">
<summary>
 Create by comprehension
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVector.Generic.length``1(Microsoft.FSharp.Math.RowVector`1{``0})">
<summary>
 Get the number of rows in a column vector.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVector.Generic.of_array``1(``0[]`1)">
<summary>
 Create a row vector from an array of elements
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVector.Generic.of_list``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Create a row vector from a list of elements
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVector.Generic.of_seq``2(``0)">
<summary>
 Create a row vector from a sequence of elements
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVector.Generic.set``1(Microsoft.FSharp.Math.RowVector`1{``0},System.Int32,``0)">
<summary>
 Set an element in a column vector.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVector.Generic.to_array``1(Microsoft.FSharp.Math.RowVector`1{``0})">
<summary>
 Return a new array containing a copy of the elements of the given vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.RowVector.Generic.transpose``1(Microsoft.FSharp.Math.RowVector`1{``0})">
<summary>
 Transpose the row vector
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.RowVector.Generic">
<summary>
 Operations to manipulate row vectors types carrying
 arbitrary element types. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.RowVector">
<summary>
 Operations to manipulate floating
 point row vectors.  These are included for completeness and are
 nearly always transposed to column vectors.
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.Types.BigInt">

</member>
<member name="T:Microsoft.FSharp.Math.Types.BigNum">

</member>
<member name="T:Microsoft.FSharp.Math.Types.BigRational">

</member>
<member name="T:Microsoft.FSharp.Math.Types.Complex">

</member>
<member name="T:Microsoft.FSharp.Math.Types.IFloating`1">

</member>
<member name="T:Microsoft.FSharp.Math.Types.IFractional`1">

</member>
<member name="T:Microsoft.FSharp.Math.Types.IIEEE`1">

</member>
<member name="T:Microsoft.FSharp.Math.Types.IIntegral`1">

</member>
<member name="T:Microsoft.FSharp.Math.Types.INumeric`1">

</member>
<member name="T:Microsoft.FSharp.Math.Types.Matrix`1">

</member>
<member name="T:Microsoft.FSharp.Math.Types.RowVector`1">

</member>
<member name="T:Microsoft.FSharp.Math.Types.Vector`1">

</member>
<member name="T:Microsoft.FSharp.Math.Types.complex">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.add(Microsoft.FSharp.Math.Vector`1{System.Double},Microsoft.FSharp.Math.Vector`1{System.Double})">
<summary>
Add two vectors (operator +)
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.copy(Microsoft.FSharp.Math.Vector`1{System.Double})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.cptMul(Microsoft.FSharp.Math.Vector`1{System.Double},Microsoft.FSharp.Math.Vector`1{System.Double})">
<summary>
Point-wise multiplication of two vectors (operator .*)
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.cptPow(Microsoft.FSharp.Math.Vector`1{System.Double},System.Double)">
<summary>
Pointwise exponential of a vector.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.create(System.Int32,System.Double)">
<summary>
 Generate a vector of the given length where each entry contains the given value
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.dot(Microsoft.FSharp.Math.Vector`1{System.Double},Microsoft.FSharp.Math.Vector`1{System.Double})">
<summary>
Dot product
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.exists(Microsoft.FSharp.Core.FastFunc`2{System.Double,System.Boolean},Microsoft.FSharp.Math.Vector`1{System.Double})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.existsi(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Double,System.Boolean}},Microsoft.FSharp.Math.Vector`1{System.Double})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.fold``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{System.Double,``0}},``0,Microsoft.FSharp.Math.Vector`1{System.Double})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.foldi``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{System.Double,``0}}},``0,Microsoft.FSharp.Math.Vector`1{System.Double})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.forall(Microsoft.FSharp.Core.FastFunc`2{System.Double,System.Boolean},Microsoft.FSharp.Math.Vector`1{System.Double})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.foralli(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Double,System.Boolean}},Microsoft.FSharp.Math.Vector`1{System.Double})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.get(Microsoft.FSharp.Math.Vector`1{System.Double},System.Int32)">
<summary>
 Get an element of a column vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.init(System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,System.Double})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.inplace_add(Microsoft.FSharp.Math.Vector`1{System.Double},Microsoft.FSharp.Math.Vector`1{System.Double})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.inplace_assign(Microsoft.FSharp.Core.FastFunc`2{System.Int32,System.Double},Microsoft.FSharp.Math.Vector`1{System.Double})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.inplace_cptMul(Microsoft.FSharp.Math.Vector`1{System.Double},Microsoft.FSharp.Math.Vector`1{System.Double})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.inplace_mapi(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Double,System.Double}},Microsoft.FSharp.Math.Vector`1{System.Double})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.inplace_scale(System.Double,Microsoft.FSharp.Math.Vector`1{System.Double})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.inplace_sub(Microsoft.FSharp.Math.Vector`1{System.Double},Microsoft.FSharp.Math.Vector`1{System.Double})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.length(Microsoft.FSharp.Math.Vector`1{System.Double})">
<summary>
 Get the dimensions (number of rows) of a column vector.  Identical to [[nrows]]
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.map(Microsoft.FSharp.Core.FastFunc`2{System.Double,System.Double},Microsoft.FSharp.Math.Vector`1{System.Double})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.mapi(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Double,System.Double}},Microsoft.FSharp.Math.Vector`1{System.Double})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.neg(Microsoft.FSharp.Math.Vector`1{System.Double})">
<summary>
Negation of the vector (each element is negated) (unary operator -)
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.norm(Microsoft.FSharp.Math.Vector`1{System.Double})">
<summary>
sum(x*x) of all or some of the matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.nrows(Microsoft.FSharp.Math.Vector`1{System.Double})">
<summary>
 Get the number of rows of a column vector. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.of_array(System.Double[]`1)">
<summary>
 Create a vector from an array of double precision floats
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.of_list(Microsoft.FSharp.Collections.List`1{System.Double})">
<summary>
 Create a vector from a list of numbers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.of_scalar(System.Double)">
<summary>
 Create a 1-element vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.of_seq``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.prod(Microsoft.FSharp.Math.Vector`1{System.Double})">
<summary>
Multiply all the elements of the matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.range(System.Int32,System.Int32)">
<summary>
 Create a vector that represents a integral mesh over the given range
 e.g. range 1 5 = vector [ 1.;2.;3.;4.;5. ]
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.rangef(System.Double,System.Double,System.Double)">
<summary>
 Create a vector that represents a mesh over the given range
 e.g. rangef (-1.0) 0.5 1.0 = vector [ -1.0; -0.5; 0.0; 0.5; 1.0]
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.scale(System.Double,Microsoft.FSharp.Math.Vector`1{System.Double})">
<summary>
Pointwise multiplication of a matrix by a scalar
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.set(Microsoft.FSharp.Math.Vector`1{System.Double},System.Int32,System.Double)">
<summary>
 Set an element of a column vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.sub(Microsoft.FSharp.Math.Vector`1{System.Double},Microsoft.FSharp.Math.Vector`1{System.Double})">
<summary>
Subtract one vector from another (operator -)
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.sum(Microsoft.FSharp.Math.Vector`1{System.Double})">
<summary>
Sum all the elements of a vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.to_array(Microsoft.FSharp.Math.Vector`1{System.Double})">
<summary>
 Return a new array containing a copy of the elements of the given vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.transpose(Microsoft.FSharp.Math.Vector`1{System.Double})">
<summary>
Transpose of a matrix.  Use also m.Transpose
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.zero(System.Int32)">
<summary>
 Return a vector of the given length where every entry is zero.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.add``1(Microsoft.FSharp.Math.Vector`1{``0},Microsoft.FSharp.Math.Vector`1{``0})">
<summary>
Add two vectors (operator +)
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.copy``1(Microsoft.FSharp.Math.Vector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.cptMax``1(Microsoft.FSharp.Math.Vector`1{``0},Microsoft.FSharp.Math.Vector`1{``0})">
<summary>
Take the pointwise maximum of two vectors
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.cptMin``1(Microsoft.FSharp.Math.Vector`1{``0},Microsoft.FSharp.Math.Vector`1{``0})">
<summary>
Take the pointwise minimum of two vectors
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.cptMul``1(Microsoft.FSharp.Math.Vector`1{``0},Microsoft.FSharp.Math.Vector`1{``0})">
<summary>
Point-wise multiplication of two vectors (operator .*)
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.create``1(System.Int32,``0)">
<summary>
 Generate a vector of the given length where each entry contains the given value
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.dot``1(Microsoft.FSharp.Math.Vector`1{``0},Microsoft.FSharp.Math.Vector`1{``0})">
<summary>
Dot product
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.eops``1(Microsoft.FSharp.Math.Vector`1{``0})">
<summary>
 Get the dictionary of operations assocaited with the element type
 The element type of the matrix must have an associated instance of INumeric&lt;'a&gt; (see [[GlobalAssociations]]) (else InvalidArgumentException).
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.exists``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Math.Vector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.existsi``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean}},Microsoft.FSharp.Math.Vector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.fold``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,Microsoft.FSharp.Math.Vector`1{``1})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.foldi``2(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}}},``0,Microsoft.FSharp.Math.Vector`1{``1})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.forall``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Math.Vector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.foralli``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean}},Microsoft.FSharp.Math.Vector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.get``1(Microsoft.FSharp.Math.Vector`1{``0},System.Int32)">
<summary>
 Get an element of a column vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.init``1(System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0})">
<summary>
 Creation: general
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.init_numeric``1(System.Int32,Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Math.INumeric`1{``0},Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0}})">
<summary>
 Creation: useful when the element type has associated operations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.inplace_add``1(Microsoft.FSharp.Math.Vector`1{``0},Microsoft.FSharp.Math.Vector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.inplace_assign``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0},Microsoft.FSharp.Math.Vector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.inplace_cptMul``1(Microsoft.FSharp.Math.Vector`1{``0},Microsoft.FSharp.Math.Vector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.inplace_mapi``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},Microsoft.FSharp.Math.Vector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.inplace_scale``1(``0,Microsoft.FSharp.Math.Vector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.inplace_sub``1(Microsoft.FSharp.Math.Vector`1{``0},Microsoft.FSharp.Math.Vector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.length``1(Microsoft.FSharp.Math.Vector`1{``0})">
<summary>
 Get the dimensions (number of rows) of a column vector.  Identical to [[nrows]]
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.map``1(Microsoft.FSharp.Core.FastFunc`2{``0,``0},Microsoft.FSharp.Math.Vector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.mapi``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},Microsoft.FSharp.Math.Vector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.neg``1(Microsoft.FSharp.Math.Vector`1{``0})">
<summary>
Negation of the vector (each element is negated) (unary operator -)
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.norm``1(Microsoft.FSharp.Math.Vector`1{``0})">
<summary>
sum(x*x) of all or some of the matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.nrows``1(Microsoft.FSharp.Math.Vector`1{``0})">
<summary>
 Get the number of rows of a column vector. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.of_array``1(``0[]`1)">
<summary>
 Create a vector from an array of elements
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.of_list``1(Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Create a vector from a list of numbers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.of_scalar``1(``0)">
<summary>
 Create a 1-element vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.of_seq``2(``0)">
<summary>
 Create a vector from a sequence of numbers
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.prod``1(Microsoft.FSharp.Math.Vector`1{``0})">
<summary>
Multiply all the elements of the matrix
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.scale``1(``0,Microsoft.FSharp.Math.Vector`1{``0})">
<summary>
Pointwise multiplication of a matrix by a scalar
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.set``1(Microsoft.FSharp.Math.Vector`1{``0},System.Int32,``0)">
<summary>
 Set an element of a column vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.sub``1(Microsoft.FSharp.Math.Vector`1{``0},Microsoft.FSharp.Math.Vector`1{``0})">
<summary>
Subtract one vector from another (operator -)
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.sum``1(Microsoft.FSharp.Math.Vector`1{``0})">
<summary>
Sum all the elements of a vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.to_array``1(Microsoft.FSharp.Math.Vector`1{``0})">
<summary>
 Return a new array containing a copy of the elements of the given vector
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.transpose``1(Microsoft.FSharp.Math.Vector`1{``0})">
<summary>
Transpose of a matrix.  Use also m.Transpose
</summary>
</member>
<member name="M:Microsoft.FSharp.Math.Vector.Generic.zero``1(System.Int32)">
<summary>
 Return a vector of the given length where every entry is zero.
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.Vector.Generic">
<summary>
 Operations to manipulate column vectors carrying
 arbitrary element types.  
</summary>
</member>
<member name="T:Microsoft.FSharp.Math.Vector">
<summary>
 Operations to manipulate floating
 point column vectors.  The submodule VectorOps.Generic contains a 
 matching set of operations to manipulate column vectors carrying
 arbitrary element types.
</summary>
</member>
<member name="T:Microsoft.FSharp.NativeInterop.CMatrix`1">
<summary>
 See NativeArray2
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.FortranMatrix`1.FromPtr(Microsoft.FSharp.Core.nativeptr`1{``0},System.Int32,System.Int32)">

</member>
<member name="P:Microsoft.FSharp.NativeInterop.FortranMatrix`1.Item(System.Int32,System.Int32)">
<summary>
 WARNING: use of this function may lead to unverifiable or invalid code
</summary>
</member>
<member name="P:Microsoft.FSharp.NativeInterop.FortranMatrix`1.NativeTranspose">
<summary>
 View a FortranMatrix as a CMatrix.  Doesn't actually allocate
 a new matirx - just gives a different label to the same bits, and swaps the
 row/column count information associated with the bits.
</summary>
</member>
<member name="P:Microsoft.FSharp.NativeInterop.FortranMatrix`1.NumCols">

</member>
<member name="P:Microsoft.FSharp.NativeInterop.FortranMatrix`1.NumRows">

</member>
<member name="P:Microsoft.FSharp.NativeInterop.FortranMatrix`1.Ptr">

</member>
<member name="P:Microsoft.FSharp.NativeInterop.FortranMatrix`1.Item(System.Int32,System.Int32,``0)">
<summary>
 WARNING: use of this function may lead to unverifiable or invalid code
</summary>
</member>
<member name="T:Microsoft.FSharp.NativeInterop.FortranMatrix`1">
<summary>
 This type wraps a pointer to a blob of unmanaged memory assumed to contain
 a Fortran-style column major two-dimensional matrix of items compatible with the (presumably blittable) 
 type 'a. The blob of memory must be allocated and managed externally, 
 e.g. by a computation routine written in C.

 All operations on this type are marked inlined
 because the code used to implement the operations is not verifiable.  

 Any code that uses these operations will be unverifiable and may 
 cause memory corruption if not used with extreme care.
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativeArray2`1.FromPtr(Microsoft.FSharp.Core.nativeptr`1{``0},System.Int32,System.Int32)">

</member>
<member name="P:Microsoft.FSharp.NativeInterop.NativeArray2`1.Item(System.Int32,System.Int32)">
<summary>
 WARNING: use of this function may lead to unverifiable or invalid code
</summary>
</member>
<member name="P:Microsoft.FSharp.NativeInterop.NativeArray2`1.NativeTranspose">
<summary>
 View a CMatrix as a FortranMatrix.  Doesn't actually allocate
 a new matirx - just gives a different label to the same bits, and swaps the
 row/column count information associated with the bits.
</summary>
</member>
<member name="P:Microsoft.FSharp.NativeInterop.NativeArray2`1.NumCols">

</member>
<member name="P:Microsoft.FSharp.NativeInterop.NativeArray2`1.NumRows">

</member>
<member name="P:Microsoft.FSharp.NativeInterop.NativeArray2`1.Ptr">

</member>
<member name="P:Microsoft.FSharp.NativeInterop.NativeArray2`1.Item(System.Int32,System.Int32,``0)">
<summary>
 WARNING: use of this function may lead to unverifiable or invalid code
</summary>
</member>
<member name="T:Microsoft.FSharp.NativeInterop.NativeArray2`1">
<summary>
 This type wraps a pointer to a blob of unmanaged memory assumed to contain
 a C-style row major two-dimensional matrix of items compatible with the (presumably blittable) 
 type 'a. The blob of memory must be allocated and managed externally, 
 e.g. by a computation routine written in C.

 All operations on this type are marked inlined
 because the code used to implement the operations is not verifiable.  

 Any code that uses these operations will be unverifiable and may 
 cause memory corruption if not used with extreme care.
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativeArray`1.FromPtr(Microsoft.FSharp.Core.nativeptr`1{``0},System.Int32)">

</member>
<member name="P:Microsoft.FSharp.NativeInterop.NativeArray`1.Item(System.Int32)">
<summary>
 WARNING: use of this function may lead to unverifiable or invalid code
</summary>
</member>
<member name="P:Microsoft.FSharp.NativeInterop.NativeArray`1.Length">

</member>
<member name="P:Microsoft.FSharp.NativeInterop.NativeArray`1.Ptr">

</member>
<member name="P:Microsoft.FSharp.NativeInterop.NativeArray`1.Item(System.Int32,``0)">
<summary>
 WARNING: use of this function may lead to unverifiable or invalid code
</summary>
</member>
<member name="T:Microsoft.FSharp.NativeInterop.NativeArray`1">
<summary>
 This type wraps a pointer to a blob of unmanaged memory assumed to contain
 a C-style one-dimensional array of items compatible with the (presumably blittable) 
 type 'a.  The blob of memory must be allocated and managed externally, 
 e.g. by a computation routine written in C.

 All operations on this type are marked inlined
 because the code used to implement the operations is not verifiable.  

 Any code that uses these operations will be unverifiable and may 
 cause memory corruption if not used with extreme care.
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.PinnedArray2`1.Free">

</member>
<member name="M:Microsoft.FSharp.NativeInterop.PinnedArray2`1.FromNative(Microsoft.FSharp.NativeInterop.NativeArray2`1{``0},System.Runtime.InteropServices.GCHandle)">

</member>
<member name="P:Microsoft.FSharp.NativeInterop.PinnedArray2`1.NativeArray">

</member>
<member name="P:Microsoft.FSharp.NativeInterop.PinnedArray2`1.NumCols">

</member>
<member name="P:Microsoft.FSharp.NativeInterop.PinnedArray2`1.NumRows">

</member>
<member name="P:Microsoft.FSharp.NativeInterop.PinnedArray2`1.Ptr">

</member>
<member name="M:Microsoft.FSharp.NativeInterop.PinnedArray2`1.of_array2(``0[,]`1)">

</member>
<member name="M:Microsoft.FSharp.NativeInterop.PinnedArray2`1.of_matrix(Microsoft.FSharp.Math.Matrix`1{``0})">

</member>
<member name="T:Microsoft.FSharp.NativeInterop.PinnedArray2`1">
<summary>
 Represents a pinned handle to a structure with an underlying 2D array, i.e. an underlying NativeArray2.
 Used when interfacing with native code math libraries such as LAPACK.
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.PinnedArray`1.Free">

</member>
<member name="M:Microsoft.FSharp.NativeInterop.PinnedArray`1.FromNative(Microsoft.FSharp.NativeInterop.NativeArray`1{``0},System.Runtime.InteropServices.GCHandle)">

</member>
<member name="P:Microsoft.FSharp.NativeInterop.PinnedArray`1.Length">

</member>
<member name="P:Microsoft.FSharp.NativeInterop.PinnedArray`1.NativeArray">

</member>
<member name="P:Microsoft.FSharp.NativeInterop.PinnedArray`1.Ptr">

</member>
<member name="M:Microsoft.FSharp.NativeInterop.PinnedArray`1.of_array(``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.NativeInterop.PinnedArray`1.of_rowvec(Microsoft.FSharp.Math.RowVector`1{``0})">

</member>
<member name="M:Microsoft.FSharp.NativeInterop.PinnedArray`1.of_vector(Microsoft.FSharp.Math.Vector`1{``0})">

</member>
<member name="T:Microsoft.FSharp.NativeInterop.PinnedArray`1">
<summary>
 Represents a pinned handle to a structure with an underlying 1D array, i.e. an underlying NativeArray.
 Used when interfacing with native code math libraries such as LAPACK.
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtr.add``1(Microsoft.FSharp.Core.nativeptr`1{``0},System.Int32)">
<summary>
 WARNING: use of this function may lead to unverifiable or invalid code
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtr.get``1(Microsoft.FSharp.Core.nativeptr`1{``0},System.Int32)">
<summary>
 WARNING: use of this function may lead to unverifiable or invalid code
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtr.of_NativeArray``1(Microsoft.FSharp.NativeInterop.NativeArray`1{``0})">
<summary>
 WARNING: use of this function may lead to unverifiable or invalid code
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtr.of_ilsigptr``1(Microsoft.FSharp.Core.nativeptr`1{``0})">
<summary>
 WARNING: use of this function may lead to unverifiable or invalid code
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtr.of_nativeint``1(System.IntPtr)">
<summary>
 WARNING: use of this function may lead to unverifiable or invalid code
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtr.set``1(Microsoft.FSharp.Core.nativeptr`1{``0},System.Int32,``0)">
<summary>
 WARNING: use of this function may lead to unverifiable or invalid code
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtr.to_NativeArray``1(Microsoft.FSharp.Core.nativeptr`1{``0},System.Int32)">
<summary>
 WARNING: use of this function may lead to unverifiable or invalid code
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtr.to_ilsigptr``1(Microsoft.FSharp.Core.nativeptr`1{``0})">
<summary>
 WARNING: use of this function may lead to unverifiable or invalid code
</summary>
</member>
<member name="M:Microsoft.FSharp.NativeInterop.NativePtr.to_nativeint``1(Microsoft.FSharp.Core.nativeptr`1{``0})">
<summary>
 WARNING: use of this function may lead to unverifiable or invalid code
</summary>
</member>
<member name="T:Microsoft.FSharp.NativeInterop.NativePtr">

</member>
<member name="M:Microsoft.FSharp.NativeInterop.Ref.pin``2(Microsoft.FSharp.Core.Ref`1{``0},Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.nativeptr`1{``0},``1})">
<summary>
 Pin the given ref for the duration of a single call to the given function.  A native pointer to
 the contents of the ref is passed to the given function.  Cleanup the GCHandle associated with the 
 pin when the function completes, even if an exception is raised.

 This function should only be used if 'a is a simple blittable type
 such as "int" that does not contain any further heap references.

 WARNING: use of this function may lead to unverifiable or invalid code
</summary>
</member>
<member name="T:Microsoft.FSharp.NativeInterop.Ref">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.abs(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.op_Append``1(Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.op_MultiplyMultiply(System.Double,System.Double)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.string_of_int(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.blit``1(``0[]`1,System.Int32,``0[]`1,System.Int32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.copy``1(``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.create``1(System.Int32,``0)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.fold_left``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``0}},``0,``1[]`1)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.fold_right``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,``1}},``0[]`1,``1)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.get``1(``0[]`1,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.geta``1(``0[]`1,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.init``1(System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.length``1(``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.make``1(System.Int32,``0)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.of_list``1(Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.set``1(``0[]`1,System.Int32,``0)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.sub``1(``0[]`1,System.Int32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.to_list``1(``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Array.zero_create``1(System.Int32)">

</member>
<member name="T:Microsoft.FSharp.Primitives.Basics.Array">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Bytearray.blit(System.Byte[]`1,System.Int32,System.Byte[]`1,System.Int32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Bytearray.get(System.Byte[]`1,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Bytearray.init(System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,System.Byte})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Bytearray.length(System.Byte[]`1)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Bytearray.set(System.Byte[]`1,System.Int32,System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Bytearray.sub(System.Byte[]`1,System.Int32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Bytearray.zero_create(System.Int32)">

</member>
<member name="T:Microsoft.FSharp.Primitives.Basics.Bytearray">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Char.chr(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.Char.code(System.Char)">

</member>
<member name="T:Microsoft.FSharp.Primitives.Basics.Char">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.append``1(Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.concat``2(``0)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.exists``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.filter``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.find``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.for_all``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.init``1(System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.iter``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.iteri``1(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.length``1(Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.map``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.mapi``2(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{``0,``1}},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.nonempty``1(Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.of_array``1(``0[]`1)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.partition``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.rev``1(Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.rev_append``1(Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.to_array``1(Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.tryfind``1(Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean},Microsoft.FSharp.Collections.List`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.unzip``2(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.unzip3``3(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Core.Tuple`3{``0,``1,``2}})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.zip``2(Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``1})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.List.zip3``3(Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``1},Microsoft.FSharp.Collections.List`1{``2})">

</member>
<member name="T:Microsoft.FSharp.Primitives.Basics.List">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.NativeOps.of_ilsigptr``1(Microsoft.FSharp.Core.nativeptr`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.NativeOps.of_nativeint``1(System.IntPtr)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.NativeOps.pinAny``1(System.Object,Microsoft.FSharp.Core.FastFunc`2{System.Runtime.InteropServices.GCHandle,``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.NativeOps.pinUnscoped(System.Object)">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.NativeOps.to_ilsigptr``1(Microsoft.FSharp.Core.nativeptr`1{``0})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.NativeOps.to_nativeint``1(Microsoft.FSharp.Core.nativeptr`1{``0})">

</member>
<member name="T:Microsoft.FSharp.Primitives.Basics.NativeOps">

</member>
<member name="T:Microsoft.FSharp.Primitives.Basics.RangeOps.range">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.RangeOps.foldR``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{System.Int32,``0}},``0,Microsoft.FSharp.Core.Tuple`2{System.Int32,System.Int32})">

</member>
<member name="M:Microsoft.FSharp.Primitives.Basics.RangeOps.sumfR(Microsoft.FSharp.Core.FastFunc`2{System.Int32,System.Double},Microsoft.FSharp.Core.Tuple`2{System.Int32,System.Int32})">

</member>
<member name="T:Microsoft.FSharp.Primitives.Basics.RangeOps">

</member>
<member name="T:Microsoft.FSharp.Primitives.Basics">
<summary>
 Definitions internal for this library.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.GetFreeVariables">
<summary>
 Get the free expression variables of an expression as a list
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr.Substitute(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Quotations.ExprVarName,Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Quotations.Expr}})">
<summary>
 Substitute through the given expression using the given functions
 to map variables to new values.  The functions must give consistent results
 at each application.  Variable renaming may occur on the target expression
 if variable capture occurs.
</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.Expr.Type">
<summary>
 Returns type of an expression
</summary>
</member>
<member name="T:Microsoft.FSharp.Quotations.Expr">
<summary>
 Quoted expressions annotated decorated with System.Types. 
 A quoted expression can be decomposed using the 
 Query functions on the expression families defined in this module.
 efVar, efApp, efLambda, efConst, efQuote and efHole form a complete 
 non-overlapping decomposition of the type of quoted expressions.
</summary>
</member>
<member name="T:Microsoft.FSharp.Quotations.ExprConstInfo">
<summary>
 Expression contants.  A number of expression constants and 
 constructors are built into the term structure and should be kept in the
 normal form where they are applied to all arguments.  These are detected
 and constructed by using expression families efCond, efAnyTopDefn, efLetRec, efRecdMk
 efRecdGet, efUnionMk, efUnionGet, efUnionTest, efTupleMk, efTupleGet, efEquality, efCoerce
 efArrayMk, efUnit etc.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.ExprVar.Create(Microsoft.FSharp.Quotations.ExprVarName)">

</member>
<member name="M:Microsoft.FSharp.Quotations.ExprVar.Fresh(System.String,System.Type)">

</member>
<member name="P:Microsoft.FSharp.Quotations.ExprVar.Name">

</member>
<member name="P:Microsoft.FSharp.Quotations.ExprVar.Text">

</member>
<member name="P:Microsoft.FSharp.Quotations.ExprVar.Type">

</member>
<member name="T:Microsoft.FSharp.Quotations.ExprVar">
<summary>
 Information at the binding site of a variable
</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.ExprVarName.Text">
<summary>
 A textual representation of the name of a variable
</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.ExprVarName.Type">

</member>
<member name="T:Microsoft.FSharp.Quotations.ExprVarName">
<summary>
 Names of variables.  See [[FreshExprVarName]], [[ExprVar.Create]] and [[ExprVar.Fresh]] to generate new names.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Expr`1.Substitute(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Quotations.ExprVarName,Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Quotations.Expr}})">
<summary>
 Substitution and instantiation.
 Replace expression variables with parameters using the
 given substitution maps.  The functions return expressions that
 do not carry static type annotations (Expr),
 hence there is an implicit requirement that these functions return
 correctly typed expressions.
</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.Expr`1.Raw">

</member>
<member name="T:Microsoft.FSharp.Quotations.Expr`1">
<summary>
 Type-carrying quoted expressions.  Expressions are generated either
 by quotations and quotation templates in source text or
 programatically by using runtime-type-annotated expressions [[Expr]] and using
 [[of_raw]] to annotate them.
</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.Template`2.Raw">

</member>
<member name="T:Microsoft.FSharp.Quotations.Template`2">
<summary>
 Type-carrying quoted raw expression templates.
</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.Template`4.Raw">

</member>
<member name="T:Microsoft.FSharp.Quotations.Template`4">
<summary>
 Templates for type-carrying quoted expressions.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.TopDefnData.Create(System.Reflection.Assembly,Microsoft.FSharp.Core.Tuple`2{Microsoft.FSharp.Collections.List`1{System.String},System.String},Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Collections.List`1{System.Type},System.Type})">

</member>
<member name="P:Microsoft.FSharp.Quotations.TopDefnData.Assembly">

</member>
<member name="P:Microsoft.FSharp.Quotations.TopDefnData.Path">

</member>
<member name="P:Microsoft.FSharp.Quotations.TopDefnData.TypeScheme">

</member>
<member name="T:Microsoft.FSharp.Quotations.TopDefnData">
<summary>
 Specificaton of a reference to a top-level definition, including
 the namespace/module path to an F# value
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.RawArgSaver`1..ctor">

</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.RawArgSaver`1.Make(System.Object)">

</member>
<member name="T:Microsoft.FSharp.Quotations.Raw.RawArgSaver`1">
<summary>
 For internal use only.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.DeepMacroExpandUntil(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Quotations.Expr,System.Boolean},Microsoft.FSharp.Quotations.Expr)">
<summary>
 Perform macro expansion (deep call-by-value reduction) 
 on an expression.  Lambda applications are beta-reduced 
 after reducing the function term and the argument term.
 Top-level definitions are expanded according to any top definition data
 that is available via ResolveTopDefinition.  

 The interior bodies of lambda expressions are expanded.  Reduction rules
 for unions, records, arithmetic etc. are not applied.

 A cutoff that halts the rewriting for expressions
 that pass the given test (usually a test for inclusion within a particular
 'target' langauge).

 This function is mainly included for demonstration purposes and should
 not be used in production quotation processing.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.ExplicitlyRegisterTopDefs(System.Reflection.Assembly,System.String,System.Byte[]`1)">
<summary>
 Permit interactive environments such as F# Interactive
 to explicitly register new pickled resources that represent persisted 
 top level definitions. The string indicates a unique name for the resources
 being added.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkAnyTopDefnUse(Microsoft.FSharp.Quotations.TopDefnData,Microsoft.FSharp.Collections.List`1{System.Type})">
<summary>
 Build expressions that are constants referring to top-level public definitions,
 where the constants may generic and applied to a number of type arguments.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkApp(Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build expression applications
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkApps(Microsoft.FSharp.Core.Tuple`2{Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.Expr}})">
<summary>
 Build an iterated series of function applications f x1 ... xN
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkBool(System.Boolean)">
<summary>
 Build constant boolean expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkByte(System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkChar(System.Char)">
<summary>
 Build constant unicode character expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkCoerce(System.Type,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build coercion expressions, resulting from implicit coercions at object-model calls and explicit coercions elsewhere.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkCond(Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build 'if ... then ... else' expressions    
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkCtorCall(System.Reflection.ConstructorInfo,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.Expr})">
<summary>
 Build new-object calls to constructors in the .NET obejct model
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkDouble(System.Double)">
<summary>
 Build constant 64-bit floating point number expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkEncodedForLoop(Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build for-loop expressions, where the body of the for-loop is encoded as a lambda.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkEncodedWhileLoop(Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build while-loop expressions, where the body of the loop is encoded as a lambda.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkEquality(Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build equality tests, resulting primarily from the 
 compilation of pattern matching 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkFieldGet(System.Reflection.FieldInfo,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build .NET IL field-fetches in the .NET object model
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkGenericTopDefnApp(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build expressions corresponding to uses and applications of a particular known top level generic definition.
 e.g. MkGenericTopDefnApp (&lt;@ List.map @&gt;) ([(type int); (type string)], [&lt;@ 1;2 @&gt;]
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkGenericTopDefnUse(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build expressions corresponding to uses of a particular known top level generic value.
 e.g. MkGenericTopDefnUse (&lt;@ List.map @&gt;) [(type int); (type string)]
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkGetAddr(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build address-access expressions.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkHole(System.Type)">
<summary>
 Build  holes in quotation templates
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkInt16(System.Int16)">

</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkInt32(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkInt64(System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkLambda(Microsoft.FSharp.Quotations.ExprVar,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build lambda (abstraction) expressions 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkLambdas(Microsoft.FSharp.Core.Tuple`2{Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.ExprVar},Microsoft.FSharp.Quotations.Expr})">
<summary>
 Build an iterated series of lambdas abstractions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkLet(Microsoft.FSharp.Core.Tuple`2{Microsoft.FSharp.Quotations.ExprVar,Microsoft.FSharp.Quotations.Expr},Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build expressions associated with 'let' constructs
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkLetRec(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Core.Tuple`2{Microsoft.FSharp.Quotations.ExprVar,Microsoft.FSharp.Quotations.Expr}},Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build recursives expressions associated with 'let rec' constructs
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkLiftedValue(System.Object,System.Type)">
<summary>
 Build expressions made up of arbitrary reified (lifted) values
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkMethodCall(System.Reflection.MethodInfo,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.Expr})">
<summary>
 Build calls to the .NET obejct model, excluding property accesses etc.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkNamedType(System.Type,Microsoft.FSharp.Collections.List`1{System.Type})">

</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkNewArray(System.Type,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.Expr})">
<summary>
 Build array construction expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkNewDelegate(System.Type,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build calls to construct delegate values in the .NET obejct model
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkPropGet(System.Reflection.PropertyInfo,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build calls to property accessors or field-fetches in the .NET object model
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkQuote(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build quoted expressions (for inner quotations)
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkRecd(System.Type,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.Expr})">
<summary>
 Build record-construction expressions 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkRecdGet(System.Type,System.String,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build record-access expressions 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkRecdSet(System.Type,System.String,Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build record-access expressions 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkSByte(System.SByte)">
<summary>
 Build constant signed 8-bit integers
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkSeq(Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build sequence expressions "a;b"
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkSingle(System.Single)">
<summary>
 Build constant 32-bit floating point number expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkString(System.String)">
<summary>
 Build constant string expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkSum(System.Type,System.String,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.Expr})">
<summary>
 Build discriminated-union construction expressions 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkSumFieldGet(System.Type,System.String,System.Int32,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build discriminated-union access expressions, resulting primarily
 from the compilation of pattern matches
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkSumTagTest(System.Type,System.String,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build discriminated-union discrimination test expressions, resulting 
 primarily from the compilation of pattern matches
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkTemplate``2(Microsoft.FSharp.Quotations.Template`2{``0,``1})">
<summary>
 Match an existing raw expression against the given expression template
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkTuple(System.Type,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.Expr})">
<summary>
 Build tuple-expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkTupleGet(System.Type,System.Int32,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build tuple access expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkUInt16(System.UInt16)">

</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkUInt32(System.UInt32)">

</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkUInt64(System.UInt64)">

</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkUnit">
<summary>
 Build 'unit' constant expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.MkVar(Microsoft.FSharp.Quotations.ExprVarName)">
<summary>
 Build variable expressions     
</summary>
</member>
<member name="P:Microsoft.FSharp.Quotations.Raw.PickledDefinitionsResourceNameBase">
<summary>
 Files compiled with --quotation-data persist definitions to 
 the emitted assembly ('cross stage persistence of level 0 definitions').
 They are saved as a resource in the emitted module.  This is the base name
 for the resources.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.ResolveTopDefinition(Microsoft.FSharp.Quotations.TopDefnData,Microsoft.FSharp.Collections.List`1{System.Type})">
<summary>
 Attempt to resolve a top level definition to an implementation.  If the definition is 
 polymorphic then appropriate type arguments must also be specified.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unpickle``2(System.Type,System.Byte[]`1)">
<summary>
 This function is called automatically when quotation syntax (&lt;@@ @@&gt;) and related raw-expression
 quotations are used. The bytes are a pickled binary representation of an unlinke form of the qutoed expression,
 and the System.Type argument is any type in the assembly where the quoted
 expression occurs, i.e. it helps scope the interpretation of the cross-assembly
 references in the bytes.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.op_LessAtAt AtAtGreater``2(Microsoft.FSharp.Quotations.Template`2{``0,``1})">
<summary>
 ASCII syntax for raw expression quotation.  If there are holes
 in the expression then 'b is a function type that is used produced to generate new terms.
 For example, if there are no holes then 'b is always just 'Expr'.
 If there is one hole, then 'b is Expr -&gt; Expr.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.op_LessAtAtDot DotAtAtGreater``2(Microsoft.FSharp.Quotations.Template`2{``0,``1})">
<summary>
 ASCII syntax for raw expression template quotation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.op_TwiddleAtAt``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|AnyTopDefnUse|_|(Microsoft.FSharp.Quotations.Expr)">

</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|Apps|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize an iterated series of function applications f x1 ... xN
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|App|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize expression applications
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|Bool|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize constant boolean expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|Byte|_|(Microsoft.FSharp.Quotations.Expr)">

</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|Char|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize constant unicode character expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|Coerce|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize coercion expressions, resulting from implicit coercions at object-model calls and explicit coercions elsewhere.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|Cond|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize 'if ... then ... else' expressions    
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|CtorCall|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize new-object calls to constructors in the .NET obejct model
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|Double|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize constant 64-bit floating point number expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|EncodedForLoop|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize for-loop expressions, where the body of the for-loop is encoded as a lambda.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|EncodedWhileLoop|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize while-loop expressions, where the body of the loop is encoded as a lambda.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|Equality|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize equality tests, resulting primarily from the 
 compilation of pattern matching 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|FieldGet|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize .NET IL field-fetches in the .NET object model
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|GenericTopDefnApp|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build expressions corresponding to uses and applications of a particular known top level generic definition.
 e.g. GenericTopDefnApp (&lt;@ List.map @&gt;) will recognize (&lt;@ List.map string_of_int [1;2] @&gt;) as
 an application of the map function to types [(type int); (type string)] and arguments
 (&lt;@ string_of_int @&gt;) ad [&lt;@ 1;2 @&gt;].
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|GenericTopDefnUse|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build expressions corresponding to uses of a particular known top level generic value.
 e.g. MkGenericTopDefnUse (&lt;@ List.map @&gt;)  will recognize 
 (&lt;@ List.map : (string -&gt; int) -%gt; string list -&gt; int list l@&gt;) as
 an application of the map function to types [(type int); (type string)].
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|GetAddr|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize address-access expressions.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|Hole|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize expressions representing holes in quotation templates
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|Int16|_|(Microsoft.FSharp.Quotations.Expr)">

</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|Int32|_|(Microsoft.FSharp.Quotations.Expr)">

</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|Int64|_|(Microsoft.FSharp.Quotations.Expr)">

</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|Lambdas|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize an iterated series of lambdas abstractions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|Lambda|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize lambda (abstraction) expressions 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|LazyAnd|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize the encoded form of 'a &amp;&amp; b'
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|LazyOr|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize the encoded form of 'a || b'
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|LetRec|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize recursives expressions associated with 'let rec' constructs
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|Let|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize expressions associated with 'let' constructs
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|LiftedValue|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize expressions made up of arbitrary reified (lifted) values
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|MethodCall|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize calls to the .NET obejct model, excluding property accesses etc.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|NewArray|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize array construction expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|NewDelegate|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize calls to construct delegate values in the .NET obejct model
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|PropGet|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize calls to property accessors or field-fetches in the .NET object model
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|Quote|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize quoted expressions (for inner quotations)
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|RecdGet|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize record-access expressions 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|RecdSet|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize record-access expressions 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|Recd|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize record-construction expressions 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|ResolvedTopDefnUse|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Attempt to resolve a use of a top level definition to an implementation.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|ResolvedTopDefn|_|(Microsoft.FSharp.Quotations.TopDefnData,Microsoft.FSharp.Collections.List`1{System.Type})">
<summary>
 Attempt to resolve a top level definition to an implementation.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|SByte|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize constant signed 8-bit integers
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|Seq|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize sequence expressions "a;b"
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|Single|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize constant 32-bit floating point number expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|String|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize constant string expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|SumFieldGet|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize discriminated-union access expressions, resulting primarily
 from the compilation of pattern matches
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|SumTagTest|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize discriminated-union discrimination test expressions, resulting 
 primarily from the compilation of pattern matches
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|Sum|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize discriminated-union construction expressions 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|Template|_|``2(Microsoft.FSharp.Quotations.Template`2{``0,``1})">
<summary>
 Match an existing raw expression against the given raw expression template
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|TopDefnApp|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build expressions corresponding to uses and applications of a particular known top level definition.
 e.g. TopDefnApp (&lt;@ string_of_int @&gt;) will recognize (&lt;@ string_of_int 3 @&gt;) as
 an application. This function may be used with top level generic definitions, but the types
 arguments to the generic definition will not be returned. If the type arguments are relevant then
 use GenericTopDefnApp instead.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|TupleGet|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize tuple access expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|Tuple|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize tuple-expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|UInt16|_|(Microsoft.FSharp.Quotations.Expr)">

</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|UInt32|_|(Microsoft.FSharp.Quotations.Expr)">

</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|UInt64|_|(Microsoft.FSharp.Quotations.Expr)">

</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|Unit|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize 'unit' constant expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.|Var|_|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Recognize variable expressions     
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.BindingStructure.MkConstApp(Microsoft.FSharp.Quotations.ExprConstInfo,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.Expr})">
<summary>
 Build constant expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.BindingStructure.|Var|Lambda|ConstApp|Hole|Quote|(Microsoft.FSharp.Quotations.Expr)">
<summary>
 A complete decomposition viewing the expression tree as a binding structure
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.BindingStructure.Unchecked.MkConstApp(Microsoft.FSharp.Quotations.ExprConstInfo,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.Expr})">

</member>
<member name="T:Microsoft.FSharp.Quotations.Raw.BindingStructure.Unchecked">

</member>
<member name="T:Microsoft.FSharp.Quotations.Raw.BindingStructure">

</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkApp(Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build expression applications
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkApps(Microsoft.FSharp.Core.Tuple`2{Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.Expr}})">
<summary>
 Build an iterated series of function applications f x1 ... xN
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkBool(System.Boolean)">
<summary>
 Build constant boolean expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkByte(System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkChar(System.Char)">
<summary>
 Build constant unicode character expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkCoerce(System.Type,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build coercion expressions, resulting from implicit coercions at object-model calls and explicit coercions elsewhere.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkCond(Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build expressions that are constants referring to top-level public definitions,
 where the constants may generic and applied to a number of type arguments.
 Build 'if ... then ... else' expressions    
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkCtorCall(System.Reflection.ConstructorInfo,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.Expr})">
<summary>
 Build new-object calls to constructors in the .NET obejct model
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkDouble(System.Double)">
<summary>
 Build constant 64-bit floating point number expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkEncodedForLoop(Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build for-loop expressions, where the body of the for-loop is encoded as a lambda.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkEncodedWhileLoop(Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build while-loop expressions, where the body of the loop is encoded as a lambda.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkEquality(Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build equality tests, resulting primarily from the 
 compilation of pattern matching 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkFieldGet(System.Reflection.FieldInfo,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build .NET IL field-fetches in the .NET object model
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkGenericTopDefnApp(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build expressions corresponding to uses and applications of a particular known top level generic definition.
 e.g. MkGenericTopDefnApp (&lt;@ List.map @&gt;) ([(type int); (type string)], [&lt;@ 1;2 @&gt;]
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkGetAddr(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build address-access expressions.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkHole(System.Type)">
<summary>
 Build  holes in quotation templates
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkInt16(System.Int16)">

</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkInt32(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkInt64(System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkLambda(Microsoft.FSharp.Quotations.ExprVar,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build lambda (abstraction) expressions 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkLambdas(Microsoft.FSharp.Core.Tuple`2{Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.ExprVar},Microsoft.FSharp.Quotations.Expr})">
<summary>
 Build an iterated series of lambdas abstractions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkLet(Microsoft.FSharp.Core.Tuple`2{Microsoft.FSharp.Quotations.ExprVar,Microsoft.FSharp.Quotations.Expr},Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build expressions associated with 'let' constructs
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkLetRec(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Core.Tuple`2{Microsoft.FSharp.Quotations.ExprVar,Microsoft.FSharp.Quotations.Expr}},Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build recursives expressions associated with 'let rec' constructs
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkLiftedValue(System.Object,System.Type)">
<summary>
 Build expressions made up of arbitrary reified (lifted) values
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkMethodCall(System.Reflection.MethodInfo,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.Expr})">
<summary>
 Build calls to the .NET obejct model, excluding property accesses etc.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkNewArray(System.Type,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.Expr})">
<summary>
 Build array construction expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkNewDelegate(System.Type,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build calls to construct delegate values in the .NET obejct model
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkPropGet(System.Reflection.PropertyInfo,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build calls to property accessors or field-fetches in the .NET object model
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkQuote(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build quoted expressions (for inner quotations)
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkRecd(System.Type,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.Expr})">
<summary>
 Build record-construction expressions 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkRecdGet(System.Type,System.String,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build record-access expressions 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkRecdSet(System.Type,System.String,Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build record-access expressions 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkSByte(System.SByte)">
<summary>
 Build constant signed 8-bit integers
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkSeq(Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build sequence expressions "a;b"
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkSingle(System.Single)">
<summary>
 Build constant 32-bit floating point number expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkString(System.String)">
<summary>
 Build constant string expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkSum(System.Type,System.String,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.Expr})">
<summary>
 Build discriminated-union construction expressions 
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkSumFieldGet(System.Type,System.String,System.Int32,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build discriminated-union access expressions, resulting primarily
 from the compilation of pattern matches
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkSumTagTest(System.Type,System.String,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build discriminated-union discrimination test expressions, resulting 
 primarily from the compilation of pattern matches
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkTuple(System.Type,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Quotations.Expr})">
<summary>
 Build tuple-expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkTupleGet(System.Type,System.Int32,Microsoft.FSharp.Quotations.Expr)">
<summary>
 Build tuple access expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkUInt16(System.UInt16)">

</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkUInt32(System.UInt32)">

</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkUInt64(System.UInt64)">

</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkUnit">
<summary>
 Build 'unit' constant expressions
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Raw.Unchecked.MkVar(Microsoft.FSharp.Quotations.ExprVarName)">
<summary>
 Build variable expressions     
</summary>
</member>
<member name="T:Microsoft.FSharp.Quotations.Raw.Unchecked">
<summary>
 Contains construction functions that don't perform type-checking
</summary>
</member>
<member name="T:Microsoft.FSharp.Quotations.Raw">
<summary>
 Quoted expressions and operations related to them.  These
 expressions trees are dynamically annotated with type information which is
 dynamically checked for consistency.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Typed.ArgSaver`2..ctor">

</member>
<member name="M:Microsoft.FSharp.Quotations.Typed.ArgSaver`2.Make(System.Object)">

</member>
<member name="T:Microsoft.FSharp.Quotations.Typed.ArgSaver`2">
<summary>
 For internal use only.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Typed.DeepMacroExpandUntil``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Quotations.Expr,System.Boolean},Microsoft.FSharp.Quotations.Expr`1{``0})">
<summary>
 This function is mainly included for demonstration purposes and should
 not be used in production quotation processing.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Typed.MkTemplate``3(Microsoft.FSharp.Quotations.Template`4{``0,``1,``2,Microsoft.FSharp.Quotations.Expr`1{``0}})">
<summary>
 Fill the holes in a typed expression template
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Typed.Unpickle``4(System.Type,System.Byte[]`1)">
<summary>
 This function is called automatically when quotation syntax (&lt;@ @&gt;) and related typed-expression
 quotations are used. The bytes are a pickled binary representation of an unlinke form of the qutoed expression,
 and the System.Type argument is any type in the assembly where the quoted
 expression occurs, i.e. it helps scope the interpretation of the cross-assembly
 references in the bytes.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Typed.lift``1(``0)">
<summary>
 Reify any runtime value as an expression of family LiftedValue.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Typed.map_raw``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Quotations.Expr,Microsoft.FSharp.Quotations.Expr},Microsoft.FSharp.Quotations.Expr`1{``0})">
<summary>
 Apply a an operation to the underlying raw term
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Typed.of_raw``1(Microsoft.FSharp.Quotations.Expr)">
<summary>
 Return a new typed expression given an underlying runtime-typed expression.
 A type annotation is usually required to use this function, and 
 using an incorrect type annotation may result in a later runtime exception.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Typed.op_Chevrons``3(Microsoft.FSharp.Quotations.Template`4{``0,``1,``2,Microsoft.FSharp.Quotations.Expr`1{``0}})">
<summary>
 Quote an expression.  If there are holes
 in the expression then a function is produced to generate new terms
 via the function 'fill'.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Typed.op_LessAmp_AmpLess``3(Microsoft.FSharp.Quotations.Template`4{``0,``1,``2,Microsoft.FSharp.Quotations.Expr`1{``0}})">
<summary>
 ASCII syntax for typed expression quotation.  If there are holes
 in the expression then a function is produced to generate new terms
 by filling in the holes with the arguments given to the function.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Typed.op_LessAtDot DotAtGreater``3(Microsoft.FSharp.Quotations.Template`4{``0,``1,``2,Microsoft.FSharp.Quotations.Expr`1{``0}})">
<summary>
 ASCII syntax for typed expression template quotation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Typed.op_TwiddleAt``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Quotations.Typed.to_raw``1(Microsoft.FSharp.Quotations.Expr`1{``0})">
<summary>
 Return the untyped expression underlying this type-annotated expression
</summary>
</member>
<member name="M:Microsoft.FSharp.Quotations.Typed.|Template|_|``3(Microsoft.FSharp.Quotations.Template`4{``0,``1,``2,Microsoft.FSharp.Quotations.Expr`1{``0}})">
<summary>
 Match an existing typed expression against the given typed expression template
</summary>
</member>
<member name="T:Microsoft.FSharp.Quotations.Typed">
<summary>
 Type-carrying quoted expressions and operations related to them.
</summary>
</member>
<member name="P:Microsoft.FSharp.Reflection.ModuleDefinition.CompiledHandle">
<summary>
 A handle that represents the compiled form of the F# module.
</summary>
</member>
<member name="P:Microsoft.FSharp.Reflection.ModuleDefinition.ConcreteValues">
<summary>
 Fetch the list of concrete values in the F# Module, i.e. those that 
 have a canonical corresponding construct in the compiled IL version of the F# code. Inlined
 values and private values optimized away during compilation are not returned.
</summary>
</member>
<member name="P:Microsoft.FSharp.Reflection.ModuleDefinition.ModuleDefinitions">
<summary>
 Fetch the list of public nexted module definitions in the F# Module.
</summary>
</member>
<member name="P:Microsoft.FSharp.Reflection.ModuleDefinition.TypeDefinitions">
<summary>
 Fetch the list of public type definitions in the F# Module.
 Private types and type abbreviations are not returned.
</summary>
</member>
<member name="T:Microsoft.FSharp.Reflection.ModuleDefinition">

</member>
<member name="P:Microsoft.FSharp.Reflection.TypeDefinition.CompiledHandle">
<summary>
 A handle that represents the compiled form of the F# type definition.
 This can be used to access all the features of the type definition, e.g. the
 type parameters, properties and other members. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Reflection.TypeDefinition.TypeInfo">
<summary>
 Return the GetTypeInfoOfType decomposition of a generic instance of the type.
</summary>
</member>
<member name="T:Microsoft.FSharp.Reflection.TypeDefinition">

</member>
<member name="T:Microsoft.FSharp.Reflection.TypeInfo">
<summary>
Represents the one-level decomposition of an F# type according to the
various structural types supported by the F# language.  

 Note: Most attributes associated with a System.Type value can be accessed
 via regular .NET reflection. However, it is useful to be able to view some
 F# type definitions from the perspective of the F# language, in particular
 for record, tuple and discriminated-union definitions. Although these types
 are ultimately compiled as .NET types, the details of the encoding used is
 often irrelevant, and this type and other items in this API help hide the
 details of this encoding.

</summary>
</member>
<member name="P:Microsoft.FSharp.Reflection.ValueDefinition.CompiledHandle">
<summary>
 A handle that represents the compiled form of the F# value
</summary>
</member>
<member name="T:Microsoft.FSharp.Reflection.ValueDefinition">

</member>
<member name="T:Microsoft.FSharp.Reflection.ValueInfo">
<summary>
Represents the one-level decomposition of an F# value according to the
various structural types supported by the F# language.  
</summary>
</member>
<member name="T:Microsoft.FSharp.Reflection.typeinfo`1">

</member>
<member name="M:Microsoft.FSharp.Reflection.AbstractType(System.Type)">

</member>
<member name="M:Microsoft.FSharp.Reflection.AbstractValue(System.Object)">

</member>
<member name="M:Microsoft.FSharp.Reflection.ExternalType(System.Type)">

</member>
<member name="M:Microsoft.FSharp.Reflection.ExternalValue(System.Object)">

</member>
<member name="M:Microsoft.FSharp.Reflection.GetAssemblyModules(System.Reflection.Assembly)">

</member>
<member name="M:Microsoft.FSharp.Reflection.GetAssemblyTypes(System.Reflection.Assembly)">

</member>
<member name="M:Microsoft.FSharp.Reflection.GetTypeInfoOfType(System.Type)">

</member>
<member name="M:Microsoft.FSharp.Reflection.GetTypeInfoOfValue``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Reflection.GetValueInfo``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Reflection.GetValueInfoOfObject(System.Object)">

</member>
<member name="M:Microsoft.FSharp.Reflection.IsListType(System.Type)">
<summary>
 A convenience function
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.IsOptionType(System.Type)">
<summary>
 A convenience function
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.IsUnitType(System.Type)">
<summary>
 A convenience function
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.typeinfoof``1">

</member>
<member name="M:Microsoft.FSharp.Reflection.|AbstractType|_|(Microsoft.FSharp.Reflection.TypeInfo)">

</member>
<member name="M:Microsoft.FSharp.Reflection.|AbstractValue|_|(Microsoft.FSharp.Reflection.ValueInfo)">

</member>
<member name="M:Microsoft.FSharp.Reflection.|ExternalType|_|(Microsoft.FSharp.Reflection.TypeInfo)">

</member>
<member name="M:Microsoft.FSharp.Reflection.|ExternalValue|_|(Microsoft.FSharp.Reflection.ValueInfo)">

</member>
<member name="M:Microsoft.FSharp.Reflection.Assembly.GetFSharpModules(System.Reflection.Assembly)">
<summary>
 Get an enumeration of handles to the F#-defined concrete 
 module definitions in an assembly.  Nested module definitions
 are not returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Assembly.GetFSharpTypeDefinitions(System.Reflection.Assembly)">
<summary>
 Get handles to the F#-defined concrete type definitions 
 in an assembly.  Type definitions nested inside modules
 are not returned, nor are type definitions hidden inside modules, 
 and nor are type abbreviations.
</summary>
</member>
<member name="T:Microsoft.FSharp.Reflection.Assembly">

</member>
<member name="M:Microsoft.FSharp.Reflection.Type.GetInfo(System.Type)">
<summary>
 Get the TypeInfo for a System.Type
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Type.GetTypeOfReprType(System.Type)">
<summary>
 Throw away extraneous compiler-specific information from a runtime type to return a true F# type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Type.IsListType(System.Type)">
<summary>
 A convenience function
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Type.IsOptionType(System.Type)">
<summary>
 A convenience function
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Type.IsUnitType(System.Type)">
<summary>
 A convenience function
</summary>
</member>
<member name="P:Microsoft.FSharp.Reflection.Type.MaxTupleSize">
<summary>
 The maximum size for which the structure of tuple types are faithfully reported by reflection
</summary>
</member>
<member name="T:Microsoft.FSharp.Reflection.Type">

</member>
<member name="M:Microsoft.FSharp.Reflection.Value.GetInfo``1(``0)">
<summary>
 Get the reflective view of a value
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Value.GetRecordConstructor(System.Type)">
<summary>
 Precompute a function for constructing a record value. 

 Assumes the given type is a RecordType.
 If not an unspecified exception is raised during pre-computation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Value.GetRecordFieldReader(System.Type,System.String)">
<summary>
 Precompute a function for reading a particular field from a record.
 Assumes the given type is a RecordType with a field of the given name. 
 If not an unspecified exception is raised during pre-computation.

 Using the computed function will be much faster than executing a corresponding call to Value.GetInfo
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Value.GetRecordReader(System.Type)">
<summary>
 Precompute a function for reading all the fields from a record. The fields are returned in the
 same order as the fields reported by a call to Microsoft.FSharp.Reflection.Type.GetInfo for
 this type.

 Assumes the given type is a RecordType. 
 If not an unspecified exception is raised during pre-computation.

 Using the computed function will be much faster than executing a corresponding call to Value.GetInfo
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Value.GetSumConstructor(System.Type,System.Int32)">
<summary>
 Precompute a function for constructing a discriminated union value for a particular tag. 

 Assumes the given type is a SumType where the tag is a legitimate tag for the type.
 If not an unspecified exception is raised during pre-computation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Value.GetSumRecordReader(System.Type,System.Int32)">
<summary>
 Precompute a function for reading all the fields for a particular discriminator tag of a sum type

 Assumes the given type is a SumType where the tag is a legitimate tag for the type.
 If not an unspecified exception is raised during pre-computation.

 Tags can be mapped to and from names using the functions returned by GetSumTagConverters

 Using the computed function will be much faster than executing a corresponding call to Value.GetInfo
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Value.GetSumTagConverters(System.Type)">
<summary>
 Precompute a pair of functions for converting between integer discriminator tags
 the names of the discriminators for the given sum type.

 Assumes the given type is a SumType. 
 If not an unspecified exception is raised during pre-computation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Value.GetSumTagReader(System.Type)">
<summary>
 Precompute a function for reading an integer representing the discriminator tag of a sum type.

 Assumes the given type is a SumType. 
 If not an unspecified exception is raised during pre-computation.

 Using the computed function will be much faster than executing a corresponding call to Value.GetInfo
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Value.GetTupleConstructor(System.Type)">
<summary>
 Precompute a function for reading the values of a particular tuple type

 Assumes the given type is a TupleType.
 If not an unspecified exception is raised during pre-computation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Value.GetTupleReader(System.Type)">
<summary>
 Precompute a function for reading the values of a particular tuple type

 Assumes the given type is a TupleType.
 If not an unspecified exception is raised during pre-computation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Value.GetType``1(``0)">
<summary>
 Get the reified F# type of the value.  This will often be less
 specific than obj.GetType().
</summary>
</member>
<member name="M:Microsoft.FSharp.Reflection.Value.GetTypeInfo``1(``0)">

</member>
<member name="T:Microsoft.FSharp.Reflection.Value">

</member>
<member name="T:Microsoft.FSharp.Reflection">

</member>
<member name="T:Microsoft.FSharp.Text.Format`4">

</member>
<member name="T:Microsoft.FSharp.Text.format4`4">

</member>
<member name="T:Microsoft.FSharp.Text.Printf.BuildStringFormat`1">

</member>
<member name="T:Microsoft.FSharp.Text.Printf.BuilderFormat`1">

</member>
<member name="T:Microsoft.FSharp.Text.Printf.BuilderFormat`2">

</member>
<member name="T:Microsoft.FSharp.Text.Printf.StringFormat`1">

</member>
<member name="T:Microsoft.FSharp.Text.Printf.StringFormat`2">

</member>
<member name="T:Microsoft.FSharp.Text.Printf.TextWriterFormat`1">

</member>
<member name="T:Microsoft.FSharp.Text.Printf.TextWriterFormat`2">

</member>
<member name="T:Microsoft.FSharp.Text.Printf.bstring_format`1">
<summary>
 The type of formats accepted by printers that produce strings but print intermediate results to buffers 
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.Printf.buffer_format`1">
<summary>
 The type of formats accepted by printers that write to buffers
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.Printf.kbuffer_format`2">
<summary>
 The type of formats accepted by print-then-call printers that write to buffers
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.Printf.kstring_format`2">
<summary>
 The type of formats accepted by print-then-call printers that produce strings
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.Printf.ktextwriter_format`2">
<summary>
 The type of formats accepted by print-then-call printers that write to an instance of the .NET type System.IO.TextWriter
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.Printf.string_format`1">
<summary>
 The type of formats accepted by printers that produce strings
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.Printf.textwriter_format`1">
<summary>
 The type of formats accepted by printers that write to an instance of the .NET type System.IO.TextWriter
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.bfailwithf``2(Microsoft.FSharp.Text.Format`4{``0,System.Text.StringBuilder,Microsoft.FSharp.Core.Unit,``1})">
<summary>
 Print to a string buffer and raise an exception with the given
 result.   Helper printers must print to string buffers.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.bfprintf``1(System.IO.TextWriter,Microsoft.FSharp.Text.Format`4{``0,System.Text.StringBuilder,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to a text writer or an OCaml-compatible channel, but intermediary 
 printers write via a buffer, which is often the most convenient way to write
 intermediary printers.  Useful if your primitive printing functions 
 are defined to write to buffers, but you ultimately want to
 go to a file.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.bprintf``1(System.Text.StringBuilder,Microsoft.FSharp.Text.Format`4{``0,System.Text.StringBuilder,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to a string buffer, which is a StringBuilder
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.bsprintf``1(Microsoft.FSharp.Text.Format`4{``0,System.Text.StringBuilder,Microsoft.FSharp.Core.Unit,System.String})">
<summary>
 Print to a string buffer, which is a StringBuilder.
 Return the result as a string.  Helper printers must print to 
 string buffers.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.btwprintf``2(``0,Microsoft.FSharp.Text.Format`4{``1,System.Text.StringBuilder,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to any subtype of TextWriter, but intermediary 
 printers write via a buffer, which is often the most convenient way to write
 intermediary printers.  Useful if your primitive printing functions 
 are defined to write to buffers, but you ultimately want to
 go to a file.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.eprintf``1(Microsoft.FSharp.Text.Format`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Formatted printing to stderr
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.eprintfn``1(Microsoft.FSharp.Text.Format`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Formatted printing to stderr, adding a newline 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.failwithf``2(Microsoft.FSharp.Text.Format`4{``0,Microsoft.FSharp.Core.Unit,System.String,``1})">
<summary>
 Print to a string buffer and raise an exception with the given
 result.   Helper printers must return strings.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.fprintf``1(System.IO.TextWriter,Microsoft.FSharp.Text.Format`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to a text writer or an OCaml-compatible channel
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.fprintfn``1(System.IO.TextWriter,Microsoft.FSharp.Text.Format`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to a text writer or an OCaml-compatible channel, adding a newline
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.gprintf``4(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Tuple`4{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FastFunc`2{System.Char,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``2}}},Microsoft.FSharp.Text.Format`4{``3,``0,``1,``2})">
<summary>
A building block for processing format strings.  This processes the format character at
the given position (which normally follows a '%' in a format
string) and produces an 'obj' which can be dynamically cast to
a type that depends on the format specifier. 

The function 'cont' is called to produce the object that will be returned
after this part of the format is processed.

The function 'outa' is called to process the 'c values returned by 'a' and 't' specifiers.

The function 'outc' is called to emit characters.

The intentional type representation 'ty' should be the representation of the expected
return type for the formatting.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.kbprintf``2(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``0},System.Text.StringBuilder,Microsoft.FSharp.Text.Format`4{``1,System.Text.StringBuilder,Microsoft.FSharp.Core.Unit,``0})">
<summary>
 bprintf, but call the given 'final' function to generate the result.
 See [[kprintf]].
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.kbsprintf``2(Microsoft.FSharp.Core.FastFunc`2{System.String,``0},Microsoft.FSharp.Text.Format`4{``1,System.Text.StringBuilder,Microsoft.FSharp.Core.Unit,``0})">
<summary>
 bsprintf, but call the given 'final' function to generate the result.
 See [[kprintf]].
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.kfprintf``2(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``0},System.IO.TextWriter,Microsoft.FSharp.Text.Format`4{``1,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,``0})">
<summary>
 fprintf, but call the given 'final' function to generate the result.
 See [[kprintf]].
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.kprintf``2(Microsoft.FSharp.Core.FastFunc`2{System.String,``0},Microsoft.FSharp.Text.Format`4{``1,Microsoft.FSharp.Core.Unit,System.String,``0})">
<summary>
 printf, but call the given 'final' function to generate the result.
 For example, these let the printing force a flush after all output has 
 been entered onto the channel, but not before. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.ksprintf``2(Microsoft.FSharp.Core.FastFunc`2{System.String,``0},Microsoft.FSharp.Text.Format`4{``1,Microsoft.FSharp.Core.Unit,System.String,``0})">
<summary>
 sprintf, but call the given 'final' function to generate the result.
 See [[kprintf]].
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.ktwprintf``3(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Core.Unit,``0},``1,Microsoft.FSharp.Text.Format`4{``2,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,``0})">
<summary>
 twprintf, but call the given 'final' function to generate the result.
 See [[kprintf]].
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.printf``1(Microsoft.FSharp.Text.Format`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Formatted printing to stdout
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.printfn``1(Microsoft.FSharp.Text.Format`4{``0,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Formatted printing to stdout, adding a newline 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.sprintf``1(Microsoft.FSharp.Text.Format`4{``0,Microsoft.FSharp.Core.Unit,System.String,System.String})">
<summary>
 Print to a string via an internal string buffer and return 
 the result as a string.  Helper printers must return strings.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.twprintf``2(``0,Microsoft.FSharp.Text.Format`4{``1,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to any subtype of the .NET type System.IO.TextWriter
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.Printf.twprintfn``2(``0,Microsoft.FSharp.Text.Format`4{``1,System.IO.TextWriter,Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Print to any subtype of the .NET type System.IO.TextWriter, and add a newline
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.Printf">
<summary> Extensible printf-style formatting for numbers and other datatypes
</summary>
 <remarks>
 <p>Format specifications are strings with "%" markers indicating format 
  placeholders. Format placeholders consist of:</p>
 <pre>
    %[flags][width][.precision][type]
 </pre> 
 <p>where the type is interpreted as follows:</p>
 <pre>
    %b:         bool, formatted as "true" or "false"
    %s:         string, formatted as its unescaped contents
    %d, %i:     any basic integer type formatted as a decimal integer, signed if the basic integer type is signed.
    %u:         any basic integer type formatted as an unsigned decimal integer
    %x, %X, %o: any basic integer type formatted as an unsigned hexadecimal 
                (a-f)/Hexadecimal (A-F)/Octal integer
 
    %e, %E, %f, %F, %g, %G: 
                any basic floating point type (float,float32) formatted
                using a C-style floating point format specifications, i.e
 
          %e, %E: Signed value having the form [-]d.dddde[sign]ddd where 
                  d is a single decimal digit, dddd is one or more decimal
                  digits, ddd is exactly three decimal digits, and sign 
                  is + or -
 
          %f:     Signed value having the form [-]dddd.dddd, where dddd is one
                  or more decimal digits. The number of digits before the 
                  decimal point depends on the magnitude of the number, and 
                  the number of digits after the decimal point depends on 
                  the requested precision.
 
          %g, %G: Signed value printed in f or e format, whichever is 
                  more compact for the given value and precision.
 
 
    %M:     System.Decimal value
 
    %O:     Any value, printed by boxing the object and using it's ToString method(s)
 
    %A:     Any value, printed by using Microsoft.FSharp.Text.StructuredFormat.Display.any_to_string with the default layout settings 
 
    %a: a general format specifier, requires two arguments:
          (1) a function which accepts two arguments:
                (a) a context parameter of the appropriate type for the
                    given formatting function (e.g. an #System.IO.TextWriter)
                (b) a value to print
               and which either outputs or returns appropriate text.
 
          (2) the particular value to print
 
 
    %t: a general format specifier, requires one argument:
          (1) a function which accepts a context parameter of the
              appropriate type for the given formatting function (e.g. 
              an #System.IO.TextWriter)and which either outputs or returns 
              appropriate text.

 Basic integer types are:
    byte,sbyte,int16,uint16,int32,uint32,int64,uint64,nativeint,unativeint
 Basic floating point types are:
    float, float32

 
 The following format patterns are accepted but a warning is printed:

    %h(d|u|x|X|o)
    %l(d|u|x|X|o)

 The following format patterns are now deprecated:

    %Ld, %Li, %Lu, %Lx, %LX, %Lo: same, but an int64
    %nd, %ni, %nu, %nx, %nX, %no: same, but a nativeint
    %Ud, %Ui, %Uu, %Ux, %UX, %Uo: same, but an unsigned int32 (uint32)
    %ULd, %ULi, %ULu, %ULx, %ULX, %ULo: same, but an unsigned int64 (uint64)
    %Und, %Uni, %Unu, %Unx, %UnX, %Uno: same, but an unsigned nativeint 
                                        (unativeint)
 </pre>
 <p>Valid flags are: </p>
 <pre>
     0: add zeros instead of spaces to make up the required width
     '-': left justify the result within the width specified
     '+': add a '+' character if the number is positive (to match a '-' sign 
          for negatives)
     ' ': add an extra space if the number is positive (to match a '-' 
              sign for negatives)
 </pre>
 <p>The printf '#' flag is not supported in this release and a compile-time 
  error will be reported if it is used.</p>
 </remarks>
 <examples>
 <pre>
   Printf.printf "Hello %s, %d = %d * %d" "World" 6 2 3;
   Printf.sprintf "Hello %s" "World";
   Printf.printf "Hello %a" output_string "World";
 </pre>
 </examples>
</member>
<member name="M:Microsoft.FSharp.Text.PrintfImpl.DynCloMaker`2.Make(Microsoft.FSharp.Core.FastFunc`2{System.Object,System.Object})">

</member>
<member name="T:Microsoft.FSharp.Text.PrintfImpl.DynCloMaker`2">
<summary>
 Harmless internal implementation type, not for use from user code
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.PrintfImpl">

</member>
<member name="P:Microsoft.FSharp.Text.StructuredFormat.FormatOptions.Default">

</member>
<member name="T:Microsoft.FSharp.Text.StructuredFormat.FormatOptions">
<summary>
 A record of options to control structural formatting.
 For F# Interactive properties matching those of this value can be accessed via the 'fsi'
 value.
 
 Floating Point format given in the same format accepted by System.Double.ToString,
 e.g. f6 or g15.

 If ShowProperties is set the printing process will evaluate properties of the values being
 displayed.  This may cause additional computation.  

 The ShowIEnumerable is set the printing process will force the evalution of IEnumerable objects
 to a small, finite depth, as determined by the printing parameters.
 This may lead to additional computation being performed during printing.

 <example>
 From F# Interactive the default settings can be adjusted using, for example, 
 <pre>
   open Microsoft.FSharp.Compiler.Interactive.Settings;;
   setPrintWidth 120;;
 </pre>
 </example>
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.IEnvironment.GetLayout(System.Object)">
<summary>
 Return to the layout-generation 
 environment to layout any otherwise uninterpreted object
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.StructuredFormat.IEnvironment.MaxColumns">
<summary>
 The maximum number of elements for which to generate layout for 
 list-like structures, or columns in table-like 
 structures.  -1 if no maximum.
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.StructuredFormat.IEnvironment.MaxRows">
<summary>
 The maximum number of rows for which to generate layout for table-like 
 structures.  -1 if no maximum.
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.StructuredFormat.IEnvironment">

</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.IFormattable.GetLayout(Microsoft.FSharp.Text.StructuredFormat.IEnvironment)">
<summary>
 Generate an object representing a structured formatting of the
 term.
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.StructuredFormat.IFormattable">

</member>
<member name="T:Microsoft.FSharp.Text.StructuredFormat.Joint">
<summary>
 Data representing joints in structured layouts of terms.  The representation
 of this data type is only for the consumption of formatting engines.
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.StructuredFormat.Layout">
<summary>
 Data representing structured layouts of terms.  The representation
 of this data type is only for the consumption of formatting engines.
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.StructuredFormat.joint">
<summary>
 Data representing joints in structured layouts of terms.  The representation
 of this data type is only for the consumption of formatting engines.
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.StructuredFormat.layout">
<summary>
 Data representing structured layouts of terms.  The representation
 of this data type is only for the consumption of formatting engines.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.Display.any_to_layout``1(Microsoft.FSharp.Text.StructuredFormat.FormatOptions,``0)">
<summary>
 Convert any value to a layout using the given formatting options.  The
 layout can then be processed using formatting display engines such as
 those in the LayoutOps module.  any_to_string and output_any are
 built using any_to_layout with default format options.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.Display.any_to_string``1(``0)">
<summary>
 Convert any value to a string using a standard formatter
 Data is typically formatted in a structured format, e.g.
 lists are formatted using the "[1;2]" notation.
 The details of the format are not specified and may change
 from version to version and according to the flags given
 to the F# compiler.  The format is intended to be human-readable,
 not machine readable.  If alternative generic formats are required
 you should develop your own formatter, using the code in the
 implementation of this file as a starting point.

 Data from other .NET languages is formatted using a virtual
 call to Object.ToString() on the boxed version of the input.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.Display.layout_as_string``1(Microsoft.FSharp.Text.StructuredFormat.FormatOptions,``0)">

</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.Display.layout_to_string(Microsoft.FSharp.Text.StructuredFormat.FormatOptions,Microsoft.FSharp.Text.StructuredFormat.Layout)">

</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.Display.output_any``2(``0,``1)">
<summary>
 Ouput any value to a channel using the same set of formatting rules
 as any_to_string
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.Display.output_layout``1(Microsoft.FSharp.Text.StructuredFormat.FormatOptions,``0,Microsoft.FSharp.Text.StructuredFormat.Layout)">

</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.Display.squash_layout(Microsoft.FSharp.Text.StructuredFormat.FormatOptions,Microsoft.FSharp.Text.StructuredFormat.Layout)">

</member>
<member name="T:Microsoft.FSharp.Text.StructuredFormat.Display">

</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.aboveL(Microsoft.FSharp.Text.StructuredFormat.Layout,Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Layout two vertically.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.aboveListL(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Text.StructuredFormat.Layout})">
<summary>
 Layout list vertically.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.braceL(Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Wrap braces around layout.        
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.bracketL(Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Wrap round brackets around layout.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.commaListL(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Text.StructuredFormat.Layout})">
<summary>
 Join layouts into a comma separated list.
</summary>
</member>
<member name="P:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.emptyL">
<summary>
 The empty layout
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.isEmptyL(Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Is it the empty layout?
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.leftL(System.String)">
<summary>
 An string which is left  parenthesis (no space on the right).
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.listL``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Text.StructuredFormat.Layout},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Layout like an F# list.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.objL(System.Object)">
<summary>
 An uninterpreted leaf, to be interpreted into a string
 by the layout engine. This allows leaf layouts for numbers, strings and
 other atoms to be customized according to culture.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.op_AtAt(Microsoft.FSharp.Text.StructuredFormat.Layout,Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Join broken with ident=0
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.op_AtAtMinus(Microsoft.FSharp.Text.StructuredFormat.Layout,Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Join broken with ident=1 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.op_AtAtMinusMinus(Microsoft.FSharp.Text.StructuredFormat.Layout,Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Join broken with ident=2 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.op_Decrement(Microsoft.FSharp.Text.StructuredFormat.Layout,Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Join, possible break with indent=1
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.op_DollarDollar(Microsoft.FSharp.Text.StructuredFormat.Layout,Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Join, unbreakable. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.op_Increment(Microsoft.FSharp.Text.StructuredFormat.Layout,Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Join, possible break with indent=0
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.op_MinusMinusMinus(Microsoft.FSharp.Text.StructuredFormat.Layout,Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Join, possible break with indent=2 
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.optionL``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Text.StructuredFormat.Layout},Microsoft.FSharp.Core.Option`1{``0})">
<summary>
 Layout like an F# option.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.rightL(System.String)">
<summary>
 An string which is right parenthesis (no space on it's left).
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.semiListL(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Text.StructuredFormat.Layout})">
<summary>
 Join layouts into a semi-colon separated list.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.sepL(System.String)">
<summary>
 An string which requires no spaces either side.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.sepListL(Microsoft.FSharp.Text.StructuredFormat.Layout,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Text.StructuredFormat.Layout})">
<summary>
 Join layouts into a list separated using the given layout.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.spaceListL(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Text.StructuredFormat.Layout})">
<summary>
 Join layouts into a space separated list.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.squareBracketL(Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 Wrap square brackets around layout.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.tagAttrL(System.String,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Core.Tuple`2{System.String,System.String}},Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 See tagL
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.tagL(System.String,Microsoft.FSharp.Text.StructuredFormat.Layout)">
<summary>
 An tag is a name which can be wrapped around a layout.
 Tag names convey structure to renderers, e.g. for syntax coloring
 or hyperlinks.  Standard tag names are in the process
 of being finalized, though 'html:a' may be used for hyperlinks.
 tagAttrL provides settings for attributes associated with the
 tag, e.g. 'href' for 'html:a'.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.tupleL(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Text.StructuredFormat.Layout})">
<summary>
 Form tuple of layouts.            
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.unfoldL``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Text.StructuredFormat.Layout},Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Option`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}}},``1,System.Int32)">
<summary>
 For limitting layout of list-like sequences (lists,arrays,etc).
 unfold a list of items using (project and z) making layout list via itemL.
 If reach maxLength (before exhausting) then truncate.
</summary>
</member>
<member name="M:Microsoft.FSharp.Text.StructuredFormat.LayoutOps.wordL(System.String)">
<summary>
 An string leaf 
</summary>
</member>
<member name="T:Microsoft.FSharp.Text.StructuredFormat.LayoutOps">
<summary>
 A layout is a sequence of strings which have been joined together.
 The strings are classified as words, separators and left and right parenthesis.
 This classification determines where spaces are inserted.
 A joint is either unbreakable, breakable or broken.
 If a joint is broken the RHS layout occurs on the next line with optional indentation.
 A layout can be squashed to for given width which forces breaks as required.
</summary>
</member>
<member name="M:Microsoft.FSharp.Tools.FsLex.AsciiTables.Create(System.Byte[]`1[]`1,System.Byte[]`1)">

</member>
<member name="M:Microsoft.FSharp.Tools.FsLex.AsciiTables.Interpret``1(System.Int32,Microsoft.FSharp.Tools.FsLex.LexBuffer`2{``0,System.Byte})">
<summary>
 Interpret tables for an ascii lexer generated by fslex. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Tools.FsLex.AsciiTables">
<summary>
 The type of tables for an ascii lexer generated by fslex. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Tools.FsLex.LexBuffer`2.DiscardInput">
<summary>
 Remove all input, though don't discard the current lexeme 
</summary>
</member>
<member name="M:Microsoft.FSharp.Tools.FsLex.LexBuffer`2.FromByteFunction(``0,Microsoft.FSharp.Core.FastFunc`2{System.Byte[]`1,Microsoft.FSharp.Core.FastFunc`2{System.Int32,System.Int32}})">

</member>
<member name="M:Microsoft.FSharp.Tools.FsLex.LexBuffer`2.FromBytes(``0,System.Byte[]`1)">
<summary>
 Adjust the start position associated with the lexbuf
</summary>
</member>
<member name="M:Microsoft.FSharp.Tools.FsLex.LexBuffer`2.FromCharFunction(``0,Microsoft.FSharp.Core.FastFunc`2{System.Char[]`1,Microsoft.FSharp.Core.FastFunc`2{System.Int32,System.Int32}})">

</member>
<member name="M:Microsoft.FSharp.Tools.FsLex.LexBuffer`2.FromChars(``0,System.Char[]`1)">

</member>
<member name="M:Microsoft.FSharp.Tools.FsLex.LexBuffer`2.LexemeChar(System.Int32)">
<summary>
 Fetch a particular character in the matched string 
</summary>
</member>
<member name="P:Microsoft.FSharp.Tools.FsLex.LexBuffer`2.EndPos">
<summary>
 The end position for the lexeme
</summary>
</member>
<member name="P:Microsoft.FSharp.Tools.FsLex.LexBuffer`2.IsPastEndOfStream">
<summary>
 True if the refill of the buffer ever failed , or if explicitly set to true.
</summary>
</member>
<member name="P:Microsoft.FSharp.Tools.FsLex.LexBuffer`2.Lexeme">
<summary>
 The matched string 
</summary>
</member>
<member name="P:Microsoft.FSharp.Tools.FsLex.LexBuffer`2.LexemeLength">
<summary>
 The length of the matched string 
</summary>
</member>
<member name="P:Microsoft.FSharp.Tools.FsLex.LexBuffer`2.MatchEvent">
<summary>
 This event is fired each time a lexeme is matched by a client lexer
</summary>
</member>
<member name="P:Microsoft.FSharp.Tools.FsLex.LexBuffer`2.StartPos">
<summary>
 The start position for the lexeme
</summary>
</member>
<member name="P:Microsoft.FSharp.Tools.FsLex.LexBuffer`2.EndPos(``0)">
<summary>
 The end position for the lexeme
</summary>
</member>
<member name="P:Microsoft.FSharp.Tools.FsLex.LexBuffer`2.IsPastEndOfStream(System.Boolean)">
<summary>
 True if the refill of the buffer ever failed , or if explicitly set to true.
</summary>
</member>
<member name="P:Microsoft.FSharp.Tools.FsLex.LexBuffer`2.StartPos(``0)">
<summary>
 The start position for the lexeme
</summary>
</member>
<member name="T:Microsoft.FSharp.Tools.FsLex.LexBuffer`2">

</member>
<member name="M:Microsoft.FSharp.Tools.FsYacc.IParseState`1.EndOfRHS(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Tools.FsYacc.IParseState`1.GetData(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Tools.FsYacc.IParseState`1.RaiseError``1">

</member>
<member name="M:Microsoft.FSharp.Tools.FsYacc.IParseState`1.StartOfRHS(System.Int32)">

</member>
<member name="P:Microsoft.FSharp.Tools.FsYacc.IParseState`1.EndOfLHS">

</member>
<member name="P:Microsoft.FSharp.Tools.FsYacc.IParseState`1.StartOfLHS">

</member>
<member name="T:Microsoft.FSharp.Tools.FsYacc.IParseState`1">

</member>
<member name="M:Microsoft.FSharp.Tools.FsYacc.Tables`2.Interpret``1(Microsoft.FSharp.Core.FastFunc`2{Microsoft.FSharp.Tools.FsLex.LexBuffer`2{``1,``2},``0},Microsoft.FSharp.Tools.FsLex.LexBuffer`2{``1,``2},System.Int32)">

</member>
<member name="T:Microsoft.FSharp.Tools.FsYacc.Tables`2">

</member>
<member name="T:Microsoft.FSharp.Tools.FsYacc.AcceptExceptionException">

</member>
<member name="T:Microsoft.FSharp.Tools.FsYacc.RecoverableParseErrorExceptionException">

</member>
<member name="M:Microsoft.FSharp.Tools.FsYacc.ParseHelpers.parse_error(System.String)">

</member>
<member name="T:Microsoft.FSharp.Tools.FsYacc.ParseHelpers">

</member>
<member name="M:System.Action`2.Invoke(``0,``1)">

</member>
<member name="T:System.Action`2">

</member>
<member name="M:System.Action`3.Invoke(``0,``1,``2)">

</member>
<member name="T:System.Action`3">

</member>
<member name="M:System.Action`4.Invoke(``0,``1,``2,``3)">

</member>
<member name="T:System.Action`4">

</member>
<member name="M:System.Action`5.Invoke(``0,``1,``2,``3,``4)">

</member>
<member name="T:System.Action`5">

</member>
<member name="M:System.Converter`3.Invoke(``0,``1)">

</member>
<member name="T:System.Converter`3">

</member>
<member name="M:System.Converter`4.Invoke(``0,``1,``2)">

</member>
<member name="T:System.Converter`4">

</member>
<member name="M:System.Converter`5.Invoke(``0,``1,``2,``3)">

</member>
<member name="T:System.Converter`5">

</member>
<member name="M:System.Converter`6.Invoke(``0,``1,``2,``3,``4)">

</member>
<member name="T:System.Converter`6">

</member>
</members>
</doc>
