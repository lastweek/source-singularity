<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>mllib</name></assembly>
<members>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Arg.argspec">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Arg.spec">
<summary>
 The spec value describes the action of the argument,
 and whether it expects a following parameter.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Arg.parse(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Core.Tuple`3{System.String,Microsoft.FSharp.Compatibility.OCaml.Arg.spec,System.String}},Microsoft.FSharp.Core.FastFunc`2{System.String,Microsoft.FSharp.Core.Unit},System.String)">
<summary>
 "parse specs f use" parses the arguments given by Sys.argv
 according to the argument processing specifications "specs".
 Arguments begin with "-". Non-arguments are passed to "f" in
 order.  "use" is printed as part of the usage line if an error occurs.

 Permitted arguments are specified using triples: (arg, action, help).
 Actions are:
   Unit(f): call f, no subseq. arg
   Set(br): set ref to 'true', no subseq. arg.
   Clear(br): set ref to 'false, no subseq. arg.
   String(f): pass the subseq. arg to f
   Int(f): pass the subseq. arg to f
   Float(f): pass the subseq. arg to f
   Rest(f): pass all subseq. args to f in order
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Arg.parse_argv(Microsoft.FSharp.Core.Ref`1{System.Int32},System.String[]`1,Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Core.Tuple`3{System.String,Microsoft.FSharp.Compatibility.OCaml.Arg.spec,System.String}},Microsoft.FSharp.Core.FastFunc`2{System.String,Microsoft.FSharp.Core.Unit},System.String)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Arg.usage(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Core.Tuple`3{System.String,Microsoft.FSharp.Compatibility.OCaml.Arg.spec,System.String}},System.String)">
<summary>
 "usage specs use" prints the help for each argument.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Arg.BadException">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Arg.HelpException">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Arg">
<summary>
 A simple command-line argument processor.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Big_int.big_int">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Big_int.add_big_int(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Big_int.add_int_big_int(System.Int32,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Big_int.big_int_of_int(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Big_int.big_int_of_string(System.String)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Big_int.compare_big_int(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Big_int.div_big_int(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Big_int.eq_big_int(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Big_int.float_of_big_int(Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Big_int.gcd_big_int(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Big_int.ge_big_int(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Big_int.gt_big_int(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Big_int.int_of_big_int(Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Big_int.le_big_int(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Big_int.lt_big_int(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Big_int.max_big_int(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Big_int.min_big_int(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Big_int.minus_big_int(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Big_int.mod_big_int(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Big_int.mult_big_int(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Big_int.mult_int_big_int(System.Int32,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Big_int.power_big_int_positive_big_int(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Big_int.power_big_int_positive_int(Microsoft.FSharp.Math.BigInt,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Big_int.power_int_positive_big_int(System.Int32,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Big_int.power_int_positive_int(System.Int32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Big_int.pred_big_int(Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Big_int.quomod_big_int(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Big_int.sign_big_int(Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Big_int.square_big_int(Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Big_int.string_of_big_int(Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Big_int.sub_big_int(Microsoft.FSharp.Math.BigInt,Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Big_int.succ_big_int(Microsoft.FSharp.Math.BigInt)">

</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Big_int.unit_big_int">

</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Big_int.zero_big_int">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Big_int">
<summary>
 Big_int compatability module for arbitrary sized integers.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Buffer.t">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Buffer.add_buffer(System.Text.StringBuilder,System.Text.StringBuilder)">
<summary>
 Add second buffer to the first.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Buffer.add_channel(System.Text.StringBuilder,System.IO.TextReader,System.Int32)">
<summary>
 Read the given number of bytes as ASCII and add the resulting string 
 to the buffer.  Warning: this assumes an ASCII encoding for the I/O channel, i.e. it uses 
 Pervasives.really_input and then use ascii_to_string to produce the string 
 to add.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Buffer.add_char(System.Text.StringBuilder,System.Char)">
<summary>
 Add character to the buffer.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Buffer.add_string(System.Text.StringBuilder,System.String)">
<summary>
 Add string to the buffer.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Buffer.add_substring(System.Text.StringBuilder,System.String,System.Int32,System.Int32)">
<summary>
 Given a string, start position and length add that substring to the buffer.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Buffer.clear(System.Text.StringBuilder)">
<summary>
 Clears the buffer.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Buffer.contents(System.Text.StringBuilder)">
<summary>
 Gets the string built from the buffer.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Buffer.create(System.Int32)">
<summary>
 Create a buffer with suggested size.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Buffer.length(System.Text.StringBuilder)">
<summary>
 Number of characters in the buffer.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Buffer.output_buffer(System.IO.TextWriter,System.Text.StringBuilder)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Buffer.reset(System.Text.StringBuilder)">
<summary>
 Clears the buffer (same as Buffer.clear).
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Buffer">
<summary>
 Imperative buffers for building strings, a shallow interface to [[System.Text.StringBuilder]]
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Bytearray.bytearray">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Bytearray.encoding">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Bytearray.append(System.Byte[]`1,System.Byte[]`1)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Bytearray.ascii_to_string(System.Byte[]`1)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Bytearray.blit(System.Byte[]`1,System.Int32,System.Byte[]`1,System.Int32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Bytearray.compare(System.Byte[]`1,System.Byte[]`1)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Bytearray.concat(Microsoft.FSharp.Collections.List`1{System.Byte[]`1})">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Bytearray.copy(System.Byte[]`1)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Bytearray.create(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Bytearray.fill(System.Byte[]`1,System.Int32,System.Int32,System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Bytearray.fold_left``1(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{System.Byte,``0}},``0,System.Byte[]`1)">
<summary>
Apply a function to each element of the collection, threading an 'accumulator' argument
through the computation. If the elements are "i0...iN" then computes "f (... (f s i0)...) iN"
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Bytearray.fold_right``1(Microsoft.FSharp.Core.FastFunc`2{System.Byte,Microsoft.FSharp.Core.FastFunc`2{``0,``0}},System.Byte[]`1,``0)">
<summary>
Apply a function to each element of the collection, threading an 'accumulator' argument
through the computation. If the elements are "i0...iN" then computes "f i0 (...(f iN s))".
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Bytearray.get(System.Byte[]`1,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Bytearray.init(System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Int32,System.Byte})">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Bytearray.iter(Microsoft.FSharp.Core.FastFunc`2{System.Byte,Microsoft.FSharp.Core.Unit},System.Byte[]`1)">
<summary>
Apply the given function to each element of the collection. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Bytearray.iteri(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Byte,Microsoft.FSharp.Core.Unit}},System.Byte[]`1)">
<summary>
Apply the given function to each element of the collection. The integer passed to the
function indicates the index of element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Bytearray.length(System.Byte[]`1)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Bytearray.make(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Bytearray.map(Microsoft.FSharp.Core.FastFunc`2{System.Byte,System.Byte},System.Byte[]`1)">
<summary>
Build a new collection whose elements are the results of applying the given function
to each of the elements of the collection.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Bytearray.mapi(Microsoft.FSharp.Core.FastFunc`2{System.Int32,Microsoft.FSharp.Core.FastFunc`2{System.Byte,System.Byte}},System.Byte[]`1)">
<summary>
Build a new collection whose elements are the results of applying the given function
to each of the elements of the collection. The integer index passed to the
function indicates the index of element being transformed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Bytearray.of_list(Microsoft.FSharp.Collections.List`1{System.Byte})">
<summary>
Build a collection from the given list
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Bytearray.set(System.Byte[]`1,System.Int32,System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Bytearray.string_to_ascii(System.String)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Bytearray.sub(System.Byte[]`1,System.Int32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Bytearray.to_list(System.Byte[]`1)">
<summary>
Build a list from the given collection
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Bytearray.zero_create(System.Int32)">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Bytearray">
<summary>
 Byte arrays. Arrays of bytes are guaranteed to be type-compatible
 with the C# byte[] type, regardless of the version of .NET used.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Filename.basename(System.String)">
<summary>
 "dirname" and "basename" decompose a filename into a directory name
 and a filename, i.e. "concat (dirname s) (basename s) = s"
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Filename.check_suffix(System.String,System.String)">
<summary>
 "check_suffix f s" returns true if filename "f" ends in suffix "s",
 e.g. check_suffix "abc.ml" ".ml" returns true.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Filename.chop_extension(System.String)">
<summary>
 "chop_extension f" removes the extension, if any, from the given
 filename.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Filename.chop_suffix(System.String,System.String)">
<summary>
 Assuming "check_suffix f s" holds, "chop_suffix f s" returns the
 filename "f" with the suffix "s" removed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Filename.concat(System.String,System.String)">
<summary>
 "concat a b" returns System.IO.Path.Combine(a,b), i.e. the
 two names conjoined by the appropriate directory separator character
 for this architecture.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Filename.current_dir_name">
<summary>
 The name used for the current directory on this OS. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Filename.dirname(System.String)">
<summary>
 "dirname" and "basename" decompose a filename into a directory name
 and a filename, i.e. "concat (dirname s) (basename s) = s"
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Filename.has_extension(System.String)">
<summary>
 Return true if the filename has a "." extension
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Filename.is_implicit(System.String)">
<summary>
 Returns true if the path is relative to the current directory but does not begin with 
 an explicit "." or ".."
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Filename.is_relative(System.String)">
<summary>
 Is the path is relative to the current directory or absolute.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Filename.parent_dir_name">
<summary>
 "parent_dir_name" returns the name for the directory above the current directory on
 this OS.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Filename.quote(System.String)">
<summary>
 "quote s" is designed for use to quote a filename when using it
 for a system command.  It returns ("\'" ^ s ^ "\'").  
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Filename.temp_file(System.String,System.String)">
<summary>
 "temp_file f s" returns a hitherto unused new file name.  "f" and "s"
 are hints as to a suitable file name and suffix for the file.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Filename">
<summary>
 Common filename operations.  This module is included to make it possible to cross-compile 
 code with other ML compilers.  See also [[System.IO.Path]]
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.CHashOps`2">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.CHashTable`2">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.HashTable`2">
<summary>
 HashTable: Hash tables using structural "hash" and "equals" functions.  
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.ProviderUntagged`2">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.Provider`2">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.Provider`3">
<summary>
A collection of operations for creating and using hash tables based on particular type-tracked hash/equality functions.
Generated by the Hashtbl.Make and Hashtbl.MakeTagged functors. This type is for use when you wish to
specify a comparison function once and carry around an object that is a provider of (i.e. a factory for) hashtables 
that utilize that comparison function.

The 'tag' type parameter is used to track information about the comparison function, which helps ensure 
that you don't mixup maps created with different comparison functions
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.t`2">
<summary>
 For use when not opening module, e.g. Hashtbl.t
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.Make``2(Microsoft.FSharp.Core.FastFunc`2{``0,System.Int32},Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``0,System.Boolean}})">
<summary>
 Build a collection of operations for creating and using 
 hashtables based on the given hash/equality functions. This returns a record
 that contains the functions you use to create and manipulate tables of
 this kind.  The returned value is much like an ML module. You should call Make once for 
 each new pair of key/value types.  You may need to constrain the result 
 to be an instantiation of Provider.

 let MyStringHashProvider : Provider&lt;string,int&gt; = Hashtbl.Make(myStringHash,myStringEq)
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.MakeTagged``3(``0)">
<summary>
 Same as Make, except track the comparison function being used through an additional type parameter.

 To use this function accurately you need to define a new named class that implements IEqualityComparer and
 pass an instance of that class as the first argument. For example:
      type MyHasher = 
        class
          new() = { }
          interface IEqualityComparer&lt;string&gt; with 
            member self.GetHashCode(x) = ...
            member self.Equals(x,y) = ...
          end
        end

 let MyStringHashProvider : Hashtbl.Provider&lt;string,int&gt; = Hashtbl.MakeTagged(new MyStringHasher())
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.add``2(Microsoft.FSharp.Collections.HashMultiMap`2{``0,``1},``0,``1)">
<summary>
 Add key and data to the table.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.clear``2(Microsoft.FSharp.Collections.HashMultiMap`2{``0,``1})">
<summary>
 Empty the table.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.copy``2(Microsoft.FSharp.Collections.HashMultiMap`2{``0,``1})">
<summary>
 Create a copy of the table. Remember they are imperative and get mutated. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.create``2(System.Int32)">
<summary>
 Create a hash table with the suggested initial size.  

 Inlined to enable generation of efficient hash routines for the key type in the common case.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.find``2(Microsoft.FSharp.Collections.HashMultiMap`2{``0,``1},``0)">
<summary>
 Lookup key's data in the table.
 Raises exception is key not in table, if this could happen you should be using tryfind.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.find_all``2(Microsoft.FSharp.Collections.HashMultiMap`2{``0,``1},``0)">
<summary>
 Return all bindings for the given key
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.fold``3(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.FastFunc`2{``2,``2}}},Microsoft.FSharp.Collections.HashMultiMap`2{``0,``1},``2)">
<summary>
 Fold over all bindings
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.hash``1(``0)">
<summary>
 Hash on the structure of a value according to the F# structural hashing
 conventions.  See Pervasives.hash
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.hashq``1(``0)">
<summary>
 Hash on the identity of an object.   See Pervasives.hashq.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.iter``2(Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.FastFunc`2{``1,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.HashMultiMap`2{``0,``1})">
<summary>
Apply the given function to each binding in the hash table 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.mem``2(Microsoft.FSharp.Collections.HashMultiMap`2{``0,``1},``0)">
<summary>
 Test for the existence of any bindings for the given key
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.of_IEnumerable``3(``0)">
<summary>
 Create a hash table using the given data
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.of_list``2(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Core.Tuple`2{``0,``1}})">
<summary>
 Create a hash table using the given data
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.of_seq``3(``0)">
<summary>
 Create hash table using the given data

 Inlined to enable generation of efficient hash routines for the key type in the common case.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.remove``2(Microsoft.FSharp.Collections.HashMultiMap`2{``0,``1},``0)">
<summary>
 Remove the latest binding for the given key
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.replace``2(Microsoft.FSharp.Collections.HashMultiMap`2{``0,``1},``0,``1)">
<summary>
 Replace the latest binding for the given key
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.stats``2(System.String,Microsoft.FSharp.Core.FastFunc`2{System.IO.TextWriter,Microsoft.FSharp.Core.FastFunc`2{``0,Microsoft.FSharp.Core.Unit}},System.IO.TextWriter,Microsoft.FSharp.Collections.HashMultiMap`2{``0,``1})">
<summary>
 Print statistics on a given hash table to the given output channel
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Hashtbl.tryfind``2(Microsoft.FSharp.Collections.HashMultiMap`2{``0,``1},``0)">
<summary>
 Lookup the key's data in the table
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Hashtbl">
<summary>
 Imperative hash tables.  Shallow interface to [[Microsoft.FSharp.Collections]].

 HashTable: Hash tables using the structural "hash" and "equals" functions.  

These tables can be used with keys of any type, but you should check that
structural hashing and equality are correct for your key type.  
Structural hashing is efficient but not a suitable choice in all circumstances, 
e.g. may not hash efficiently on non-reference types and deeply-structured types.
Better efficiency is typically achieved if key types are F#-generated
types.

These hash tables may map items to multiple keys (see find_all).

The implementations are not safe for concurrent reading/writing,
and so users of these tables should take an appropriate lock
before reading/writing if used in a concurrent setting.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.Position.AsNewLinePos">

</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Lexing.Position.AbsoluteOffset">

</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Lexing.Position.Char">

</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Lexing.Position.Column">

</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Lexing.Position.FileName">

</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Lexing.Position.Line">

</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Lexing.Position.NextLine">

</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Lexing.Position.StartOfLine">

</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Lexing.Position.StartOfLineAbsoluteOffset">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Lexing.Position">
<summary>
 Position information stored for lexing tokens
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Lexing.lexbuf">
<summary>
 ASCII LexBuffers carrying OCaml-compatible position information.

 The type "lexbuf" is opaque, but has an internal position information field 
 that can be updated by setting "lexbuf.EndPos", for example if you wish 
 to update the other fields in that position data before or during 
 lexing.  You will need to do this if you wish to maintain accurate 
 line-count information.  If you do this and wish to maintain strict 
 cross-compiling compatibility with other langauges you may need code 
 to conditionally use lexbuf_set_curr_p when compiling F# code.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Lexing.position">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.flush_input(Microsoft.FSharp.Tools.FsLex.LexBuffer`2{Microsoft.FSharp.Compatibility.OCaml.Lexing.Position,System.Byte})">
<summary>
 Remove all input, though don't discard the  except the current lexeme 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.from_binary_reader``1(``0)">
<summary>
 Fuel a lexer using the given BinaryReader.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.from_bytearray(System.Byte[]`1)">
<summary>
 Fuel a lexer from an array of bytes
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.from_channel(System.IO.TextReader)">
<summary>
 Fuel a lexer using the given in_channel.  The bytes are read using Pervasives.input.
 If the in_channel is a textual channel the bytes are 
 presented to the lexer by decoding the characters using System.Text.Encoding.ASCII.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.from_function(Microsoft.FSharp.Core.FastFunc`2{System.Byte[]`1,Microsoft.FSharp.Core.FastFunc`2{System.Int32,System.Int32}})">
<summary>
 Fuel a lexer from function that fills an array of bytes up to the given length, returning the
 number of bytes filled.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.from_stream_reader(System.IO.StreamReader)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.from_string(System.String)">
<summary>
 Fuel a lexer from a string, converted to ascii using [[System.Text.Encoding.ASCII.GetBytes]]
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.from_text_reader``2(``0,``1)">
<summary>
 Fuel a lexer using the given TextReader or StreamReader.
 The characters read are decoded to bytes using the given encoding (e.g. System.Text.Encoding.ASCII)
 and the bytes presented to the lexer.  The encoding used to decode the characters
 is associated with the expectations of the lexer (e.g. a lexer may be constructed to accept only 
 ASCII or pseudo-UTF8 bytes) and will typically be different to 
 the encoding used to decode the file.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.lexbuf_curr_p(Microsoft.FSharp.Tools.FsLex.LexBuffer`2{Microsoft.FSharp.Compatibility.OCaml.Lexing.Position,System.Byte})">
<summary>
 same as lexeme_end_p 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.lexbuf_set_curr_p(Microsoft.FSharp.Tools.FsLex.LexBuffer`2{Microsoft.FSharp.Compatibility.OCaml.Lexing.Position,System.Byte},Microsoft.FSharp.Compatibility.OCaml.Lexing.Position)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.lexbuf_set_start_p(Microsoft.FSharp.Tools.FsLex.LexBuffer`2{Microsoft.FSharp.Compatibility.OCaml.Lexing.Position,System.Byte},Microsoft.FSharp.Compatibility.OCaml.Lexing.Position)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.lexeme(Microsoft.FSharp.Tools.FsLex.LexBuffer`2{Microsoft.FSharp.Compatibility.OCaml.Lexing.Position,System.Byte})">
<summary>
 Return the matched string 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.lexeme_bytes(Microsoft.FSharp.Tools.FsLex.LexBuffer`2{Microsoft.FSharp.Compatibility.OCaml.Lexing.Position,System.Byte})">
<summary>
 Return the bytes for the matched string 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.lexeme_char(Microsoft.FSharp.Tools.FsLex.LexBuffer`2{Microsoft.FSharp.Compatibility.OCaml.Lexing.Position,System.Byte},System.Int32)">
<summary>
 Return a character from the matched string, innterpreting the bytes using an ASCII encoding
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.lexeme_end(Microsoft.FSharp.Tools.FsLex.LexBuffer`2{Microsoft.FSharp.Compatibility.OCaml.Lexing.Position,System.Byte})">
<summary>
 Return absolute positions into the entire stream of characters
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.lexeme_end_p(Microsoft.FSharp.Tools.FsLex.LexBuffer`2{Microsoft.FSharp.Compatibility.OCaml.Lexing.Position,System.Byte})">
<summary>
 Return the positions stored in the lexbuf for the matched string 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.lexeme_start(Microsoft.FSharp.Tools.FsLex.LexBuffer`2{Microsoft.FSharp.Compatibility.OCaml.Lexing.Position,System.Byte})">
<summary>
 Return absolute positions into the entire stream of characters
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.lexeme_start_p(Microsoft.FSharp.Tools.FsLex.LexBuffer`2{Microsoft.FSharp.Compatibility.OCaml.Lexing.Position,System.Byte})">
<summary>
 Return the positions stored in the lexbuf for the matched string 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Lexing.lexeme_utf8(Microsoft.FSharp.Tools.FsLex.LexBuffer`2{Microsoft.FSharp.Compatibility.OCaml.Lexing.Position,System.Byte})">
<summary>
 Return the matched string interpreting the bytes using the given Unicode text encoding
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Lexing">
<summary>
 Lexing: ML-like lexing support

 This file maintains rough compatibility for lexbuffers used by some ML
 laxer generators.  The lexbuf carries an associated pair of positions.
 Beware that only the "cnum" (absolute character number) field is automatically 
 updated as each lexeme is matched.  Upon each successful match the prior end
 position is transferred to be the start position and a new start position
 is allocated with an updated pos_cnum field.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Num.num">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Num.Big_int(Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Num.Int(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Num.abs_num(Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Num.add_num(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Num.big_int_of_num(Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Num.compare_num(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Num.decr_num(Microsoft.FSharp.Core.Ref`1{Microsoft.FSharp.Math.BigNum})">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Num.div_num(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Num.float_of_num(Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Num.incr_num(Microsoft.FSharp.Core.Ref`1{Microsoft.FSharp.Math.BigNum})">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Num.int_of_num(Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Num.max_num(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Num.min_num(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Num.minus_num(Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Num.mult_num(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Num.num_of_big_int(Microsoft.FSharp.Math.BigInt)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Num.num_of_string(System.String)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Num.op_EqualsDivide(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Num.op_GreaterDivide(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Num.op_GreaterEqualsDivide(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Num.op_LessDivide(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Num.op_LessEqualsDivide(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Num.op_LessGreaterDivide(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Num.op_MinusDivide(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Num.op_MultiplyDivide(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Num.op_PlusDivide(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Num.pow_num(Microsoft.FSharp.Math.BigNum,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Num.pred_num(Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Num.sign_num(Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Num.string_of_num(Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Num.sub_num(Microsoft.FSharp.Math.BigNum,Microsoft.FSharp.Math.BigNum)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Num.succ_num(Microsoft.FSharp.Math.BigNum)">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Num">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Obj.t">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Obj.eq``1(``0,``0)">
<summary>
Reference/physical equality. 

True if boxed versions of the inputs are reference-equal, OR if
both are value types and the implementation of Object.Equals for the type
of the first argument returns true on the boxed versions of the inputs.  

In normal use on reference types or non-mutable value types this function 
has the following properties:
   - returns 'true' for two F# values where mutation of data
     in mutable fields of one affects mutation of data in the other
   - will return 'true' if (=) returns true
   - hashq will return equal hashes if (==) returns 'true'

The use on mutable value types is not recommended.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Obj.magic``2(``0)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Obj.not_eq``1(``0,``0)">
<summary>
 Negation of Obj.eq (i.e. reference/physical inequality)
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Obj.nullobj">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Obj.obj``1(System.Object)">
<summary>
 Same as Pervasives.unbox

 This function is included to make it possible to cross-compile
 code with other ML compilers.  It may be deprecated and/or removed in 
 a future release. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Obj.repr``1(``0)">
<summary>
 Same as Pervasives.box

 This function is included to make it possible to cross-compile
 code with other ML compilers.  It may be deprecated and/or removed in 
 a future release. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Obj">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Parsing.rhs_end(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Parsing.rhs_end_pos(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Parsing.rhs_start(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Parsing.rhs_start_pos(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Parsing.set_parse_state(Microsoft.FSharp.Tools.FsYacc.IParseState`1{Microsoft.FSharp.Compatibility.OCaml.Lexing.Position})">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Parsing.symbol_end">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Parsing.symbol_end_pos">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Parsing.symbol_start">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Parsing.symbol_start_pos">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Parsing.Parse_errorException">
<summary>
 You can initialize error recovery by raising the Parse_error exception. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Parsing">
<summary>
 Parsing: parser support for parsers produced by fsyacc.

 Parsers generated by fsyacc provide location information within parser
 actions.  However that information is not available globally, but
 rather is accessed via the functions available on the following local
 variable which is available in all parser actions:

    parseState : 'a Microsoft.FSharp.Tools.FsYacc.IParseState

 However, this is not compatible with the parser specifications used
 with ocamlyacc and similar tools, which make a single parser state available
 globally.  If you wish to use a global parser state (e.g. so your code will
 cross-compile with OCaml) then you can use the functions in this file.
 You will need to either generate the parser with '--ml-compatibility' option 
 or add the code

       Parsing.set_parse_state parseState;

 at the start of each action of your grammar.  The functions below
 simply report the results of corresponding calls to the latest object
 specified by a call to set_parse_state.

 Note that there could be unprotected multi-threaded concurrent access for the
 parser information, so you should not in general use these
 functions if there may be more than one parser active, and
 should instead use the functions directly available from the parseState
 object.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.big_int">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.channel_format`1">
<summary>
 Formatting specifications specialized to channel formats
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.format4`4">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.format`3">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.fpclass">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.in_channel">
<summary>
 A pseudo-abstraction over binary and textual input channels.
 OCaml-compatible channels conflate binary and text IO, and for this reasons their
 use from F# is somewhat deprecated (direct use of System.IO StreamReader, TextReader and 
 BinaryReader objects is preferred, e.g. see System.IO.File.OpenText).  
 Well-written OCaml-compatible code that simply opens either a channel in text or binary 
 mode and then does text or binary I/O using the OCaml-compatible functions below
 will work, though care must be taken with regard to end-of-line characters (see 
 input_char below).

 This library pretends that an in_channel is just a System.IO.TextReader.  Channel values
 created using open_in_bin maintain a private System.IO.BinaryReader, which will be used whenever
 you do I/O using this channel. 

 InChannel.of_BinaryReader and InChannel.of_StreamReader allow you to build input 
 channels out of the corresponding .NET abstractions.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.num">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.open_flag">
<summary>
 This type is present primarily for compatibility with other versions of ML. When
 not cross-compiling we recommend using the .NET I/O libraries
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.out_channel">
<summary>
 An pseudo-abstraction over binary and textual output channels.
 OCaml-compatible channels conflate binary and text IO, and for this reasons their
 use from F# is somewhat deprecated The direct use of System.IO StreamWriter, TextWriter and 
 BinaryWriter objects is preferred, e.g. see System.IO.File.CreateText).  Well-written OCaml code 
 that simply opens either a channel in text or binary mode and then does text 
 or binary I/O using the OCaml functions will work, though care must 
 be taken with regard to end-of-line characters (see output_char below).

 This library pretends that an out_channel is just a System.IO.TextWriter.  Channels
 created using open_out_bin maintain a private System.IO.BinaryWriter, which will be used whenever
 do I/O using this channel.  
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.string_format`1">
<summary>
 Formatting specifications specialized to string-producing formats
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Exit">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.abs_float(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.asr``1(``0,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.binary_reader_to_in_channel``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.binary_writer_to_out_channel``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.bool_of_string(System.String)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.byte_to_int(System.Byte)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.char_of_int(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.classify_float(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.close_in(System.IO.TextReader)">
<summary>
 Close the channel
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.close_out(System.IO.TextWriter)">
<summary>
 Close the given output channel
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Pervasives.epsilon_float">
<summary>
 This value is present primarily for compatibility with other versions of ML
 The smallest value that when added to 1.0 gives a different value to 1.0
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.float32_of_int(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.float32_of_string(System.String)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.float32_to_string(System.Single)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.float_of_int(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.float_of_string(System.String)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.float_to_string(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.flush(System.IO.TextWriter)">
<summary>
 Flush all pending output on the channel to the physical
 output device.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.in_channel_length(System.IO.TextReader)">
<summary>
 Return the length of the input channel
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.in_channel_to_binary_reader(System.IO.TextReader)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.in_channel_to_stream(System.IO.TextReader)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.in_channel_to_stream_reader(System.IO.TextReader)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.in_channel_to_text_reader(System.IO.TextReader)">

</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Pervasives.infinity">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.input(System.IO.TextReader,System.Byte[]`1,System.Int32,System.Int32)">
<summary>
 Attempt to input the given number of bytes from the channel, writing them into the
 buffer at the given start position. Does not block if the bytes are not available.

 The use of this function with a channel performing byte-to-character translation (e.g. one
 created with open_in, open_in_utf8 or open_in_encoded, or one 
 or built from a StreamReader or TextReader) is not recommended.
 Instead, open the channel using open_in_bin or InChannel.of_BinaryReader.

 If used with a StreamReader channel, i.e. one created using 
 open_in, open_in_utf8 or open_in_encoded, or one 
 or built from a StreamReader, this function reads bytes directly from the underlying
 BaseStream.  This may not be appropriate if any other input techniques are being
 used on the channel.

 If used with a TextReader channel (e.g. stdin), this function reads characters from the
 stream and then fills some of the byte array with the decoding of these into 
 bytes, where the decoding is performed using the System.Text.Encoding.Default encoding

 Raise End_of_file (= System.IO.EndOfStreamException) if end of file reached.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.input_binary_int(System.IO.TextReader)">
<summary>
 Input a binary integer from a binary channel.  Compatible with output_binary_int.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.input_byte(System.IO.TextReader)">
<summary>
 Input a single byte.  
 For text channels this only accepts characters with a UTF16 encoding that fits in a byte, e.g. ASCII.
 Raise End_of_file (= System.IO.EndOfStreamException) if end of file reached.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.input_char(System.IO.TextReader)">
<summary>
 Input a single character.  Raise End_of_file (= System.IO.EndOfStreamException) if end of file reached.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.input_chars(System.IO.TextReader,System.Char[]`1,System.Int32,System.Int32)">
<summary>
 Attempt to input characters from a channel. Does not block if inpout is not available.
 Raise End_of_file (= System.IO.EndOfStreamException) if end of file reached.

 No CRLF translation is done on input, even in text mode.  That is, if an input file
 has '\r\n' (CRLF) line terminators both characters will be seen in the input.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.input_line(System.IO.TextReader)">
<summary>
 Input a single line.  Raise End_of_file (= System.IO.EndOfStreamException) if end of file reached.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.input_value``1(System.IO.TextReader)">
<summary>
 Input a single serialized value from a binary stream.  Raise End_of_file (= System.IO.EndOfStreamException) if end of file reached.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.int64_to_int(System.Int64)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.int_neg(System.Int32)">
<summary>
 Negation on integers of the 'int' type
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.int_of_char(System.Char)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.int_of_float(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.int_of_float32(System.Single)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.int_of_string(System.String)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.int_to_byte(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.int_to_char(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.int_to_int64(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.int_to_string(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.land``1(``0,``0)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.ldexp(System.Double,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.lnot``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.lor``1(``0,``0)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.lsl``1(``0,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.lsr``1(``0,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.lxor``1(``0,``0)">

</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Pervasives.max_float">
<summary>
 This value is present primarily for compatibility with other versions of ML
 The highest representable positive value in the 'float' type
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Pervasives.max_int">
<summary>
 The highest representable value in the 'int' type
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Pervasives.min_float">
<summary>
 This value is present primarily for compatibility with other versions of ML
 The lowest non-denormalized positive IEEE64 float
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Pervasives.min_int">
<summary>
 The lowest representable value in the 'int' type
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.mod``3(``0,``1)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.mod_float(System.Double,System.Double)">
<summary>
 This value is present primarily for compatibility with other versions of ML
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.modf(System.Double)">
<summary>
 This value is present primarily for compatibility with other versions of ML
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Pervasives.nan">
<summary>
 This value is present primarily for compatibility with other versions of ML
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Pervasives.neg_infinity">
<summary>
 This value is present primarily for compatibility with other versions of ML
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.op_BangEquals``1(``0,``0)">
<summary>
 Negation of the '==' operator, see also Obj.eq
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.op_DivideDot(System.Double,System.Double)">
<summary>
 This value is present primarily for compatibility with other versions of ML. In F#
 the overloaded operators may be used.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.op_EqualsEquals``1(``0,``0)">
<summary>
Reference/physical equality. 
True if boxed versions of the inputs are reference-equal, OR if
both are value types and the implementation of Object.Equals for the type
of the first argument returns true on the boxed versions of the inputs.  

In normal use on reference types or non-mutable value types this function 
has the following properties:
   - returns 'true' for two F# values where mutation of data
     in mutable fields of one affects mutation of data in the other
   - will return 'true' if (=) returns true
   - hashq will return equal hashes if (==) returns 'true'

The use on mutable value types is not recommended.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.op_MinusDot(System.Double,System.Double)">
<summary>
 This value is present primarily for compatibility with other versions of ML. In F#
 the overloaded operators may be used.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.op_MultiplyDot(System.Double,System.Double)">
<summary>
 This value is present primarily for compatibility with other versions of ML
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.op_PlusDot(System.Double,System.Double)">
<summary>
 This value is present primarily for compatibility with other versions of ML. In F#
 the overloaded operators may be used.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.op_TwiddleMinusDot(System.Double)">
<summary>
 This value is present primarily for compatibility with other versions of ML. In F#
 the overloaded operators may be used.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.op_TwiddlePlusDot(System.Double)">
<summary>
 This value is present primarily for compatibility with other versions of ML. In F#
 the overloaded operators may be used.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.open_in(System.String)">
<summary>
 Open the given file to read.  

In the absence of an explicit encoding (e.g. using Open_encoding) open_in
uses the default text encoding (System.Text.Encoding.Default).  If you want to read a file
regardless of encoding then you should use binary modes. Note that .NET's 
"new StreamReader" function defaults to use a utf8 encoding, and also attempts
to determine an automatic encoding by looking for "byteorder-marks" at the head
of a text file.  This function does not do this.

 No CR-LF translation is done on input.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.open_in_bin(System.String)">
<summary>
 Open the given file to read in binary-mode 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.open_in_encoded``1(``0,System.String)">
<summary>
 Open the given file to read in text-mode using the given encoding
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.open_in_gen(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Compatibility.OCaml.Pervasives.open_flag},System.Int32,System.String)">
<summary>
 Open the given file in the mode specified by the given flags
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.open_in_utf8(System.String)">
<summary>
 Open the given file to read in text-mode using the UTF8 encoding
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.open_out(System.String)">
<summary>
 Open the given file to write in text-mode using the
 System.Text.Encoding.Default encoding

 See output_char for a description of CR-LF translation
 done on output.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.open_out_bin(System.String)">
<summary>
 Open the given file to write in binary-mode 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.open_out_encoded``1(``0,System.String)">
<summary>
 Open the given file to write in text-mode using the given encoding
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.open_out_gen(Microsoft.FSharp.Collections.List`1{Microsoft.FSharp.Compatibility.OCaml.Pervasives.open_flag},System.Int32,System.String)">
<summary>
 Open the given file to write in the mode according to the specified flags
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.open_out_utf8(System.String)">
<summary>
 Open the given file to write in text-mode using the UTF8 encoding
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.out_channel_length(System.IO.TextWriter)">
<summary>
 Return the length of the output channel.  
 Raise an exception if not an app
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.out_channel_to_binary_writer(System.IO.TextWriter)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.out_channel_to_stream(System.IO.TextWriter)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.out_channel_to_stream_writer(System.IO.TextWriter)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.out_channel_to_text_writer(System.IO.TextWriter)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.output(System.IO.TextWriter,System.Byte[]`1,System.Int32,System.Int32)">
<summary>
 Write the given range of bytes to the output channel. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.output_binary_int(System.IO.TextWriter,System.Int32)">
<summary>
 Write the given integer to the output channel in binary format.
 Only valid on binary channels.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.output_byte(System.IO.TextWriter,System.Int32)">
<summary>
 Write the given byte to the output channel. No CRLF translation is
 performed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.output_bytearray(System.IO.TextWriter,System.Byte[]`1)">
<summary>
 Write all the given bytes to the output channel. No CRLF translation is
 performed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.output_char(System.IO.TextWriter,System.Char)">
<summary>
 Write the given Unicode character to the output channel.  

 No CRLF translation is done on output.  That is, if the output character is
 '\n' (LF) characters they will not be written as '\r\n' (CRLF) characters, regardless
 of whether the underlying operating system or output stream uses CRLF as the default
 line-feed character.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.output_string(System.IO.TextWriter,System.String)">
<summary>
 Write the given Unicode string to the output channel. See output_char for the treatment of
 '\n' characters within the string.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.output_value``1(System.IO.TextWriter,``0)">
<summary>
 Serialize the given value to the output channel.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.pos_in(System.IO.TextReader)">
<summary>
 Report the current position in the input channel
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.pos_out(System.IO.TextWriter)">
<summary>
 Return the current position in the output channel, measured from the
 start of the channel.  Not valid on all channels.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.pred(System.Int32)">
<summary>
 n-1 (no overflow checking)
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.prerr_char(System.Char)">
<summary>
 Print a character to the stderr stream
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.prerr_endline(System.String)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.prerr_float(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.prerr_int(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.prerr_newline">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.prerr_string(System.String)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.print_char(System.Char)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.print_endline(System.String)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.print_float(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.print_int(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.print_newline">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.print_string(System.String)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.read_float">
<summary>
Read a floating point number from the console.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.read_int">
<summary>
Read an integer from the console.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.read_line">
<summary>
Read a line from the console, without the end-of-line character.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.really_input(System.IO.TextReader,System.Byte[]`1,System.Int32,System.Int32)">
<summary>
 Reads bytes from the channel. Blocks if the bytes are not available.
 For text channels this only accepts characters with a UTF16 encoding that fits in a byte, e.g. ASCII.
 Raise End_of_file (= System.IO.EndOfStreamException) if end of file reached.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.seek_in(System.IO.TextReader,System.Int32)">
<summary>
 Reads bytes from the channel. Blocks if the bytes are not available.
 For text channels this only accepts UTF-16 bytes with an encoding less than 256.
 Raise End_of_file (= System.IO.EndOfStreamException) if end of file reached.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.seek_out(System.IO.TextWriter,System.Int32)">
<summary>
 Set the current position in the output channel, measured from the
 start of the channel.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.set_binary_mode_in(System.IO.TextReader,System.Boolean)">
<summary>
 Set the binary mode to true or false.  If the binary mode is changed from "true" to 
 "false" then a StreamReader is created to read the binary stream.  The StreamReader uses 
 the default text encoding System.Text.Encoding.Default
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.set_binary_mode_out(System.IO.TextWriter,System.Boolean)">
<summary>
 Set the binary mode.  If the binary mode is changed from "true" to 
 "false" then a StreamWriter is created to write the binary stream.  The StreamWriter uses 
 the default text encoding System.Text.Encoding.Default.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Pervasives.stderr">
<summary>
 A channel based on System.Console.Error.  
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Pervasives.stdin">
<summary>
 A channel based on System.Console.In.  
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Pervasives.stdout">
<summary>
 A channel based on System.Console.Out.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.stream_reader_to_in_channel``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.stream_to_in_channel``2(``0,``1)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.stream_to_out_channel``2(``0,``1)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.stream_writer_to_out_channel``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.string_of_bool(System.Boolean)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.string_of_float(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.string_of_float32(System.Single)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.string_of_int(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.string_to_float(System.String)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.string_to_float32(System.String)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.succ(System.Int32)">
<summary>
 n+1 (no overflow checking)
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.text_reader_to_in_channel``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.text_writer_to_out_channel``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.unsafe_really_input(System.IO.TextReader,System.Byte[]`1,System.Int32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.|Exit|_|(System.Exception)">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Assert_failureException">
<summary>
 The exception thrown by 'assert' failures.
 A future release of F# may map this exception to a corresponding .NET exception.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Division_by_zeroException">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.End_of_fileException">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Invalid_argumentException">
<summary>
 The exception thrown by [[invalid_arg]] and misues of F# library functions
 A future release of F# may map this exception to a corresponding .NET exception.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Match_failureException">
<summary>
  Non-exhaustive match failures will raise Match failures
 A future release of F# may map this exception to a corresponding .NET exception.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Not_foundException">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Out_of_memoryException">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Stack_overflowException">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.InChannel.of_BinaryReader``1(``0)">
<summary>
Link .NET IO with the out_channel/in_channel model
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.InChannel.of_Stream``2(``0,``1)">
<summary>
 Wrap a stream by creating a StreamReader for the 
 stream and then wrapping is as an input channel.
 A text encoding must be given, e.g. System.Text.Encoding.UTF8
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.InChannel.of_StreamReader``1(``0)">
<summary>
Link .NET IO with the out_channel/in_channel model
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.InChannel.of_TextReader``1(``0)">
<summary>
Link .NET IO with the out_channel/in_channel model
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.InChannel.to_BinaryReader(System.IO.TextReader)">
<summary>
 Access the underlying stream-based objects for the channel
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.InChannel.to_Stream(System.IO.TextReader)">
<summary>
Link .NET IO with the out_channel/in_channel model
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.InChannel.to_StreamReader(System.IO.TextReader)">
<summary>
 Access the underlying stream-based objects for the channel
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.InChannel.to_TextReader(System.IO.TextReader)">
<summary>
 Access the underlying stream-based objects for the channel
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.InChannel">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.OutChannel.of_BinaryWriter``1(``0)">
<summary>
Link .NET IO with the out_channel/in_channel model
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.OutChannel.of_Stream``2(``0,``1)">
<summary>
 Wrap a stream by creating a StreamWriter for the 
 stream and then wrapping is as an output channel.
 A text encoding must be given, e.g. System.Text.Encoding.UTF8
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.OutChannel.of_StreamWriter``1(``0)">
<summary>
Link .NET IO with the out_channel/in_channel model
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.OutChannel.of_TextWriter``1(``0)">
<summary>
Link .NET IO with the out_channel/in_channel model
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.OutChannel.to_BinaryWriter(System.IO.TextWriter)">
<summary>
 Access the underlying stream-based objects for the channel
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.OutChannel.to_Stream(System.IO.TextWriter)">
<summary>
 Access the underlying stream-based objects for the channel
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.OutChannel.to_StreamWriter(System.IO.TextWriter)">
<summary>
 Access the underlying stream-based objects for the channel
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.OutChannel.to_TextWriter(System.IO.TextWriter)">
<summary>
 Access the underlying stream-based objects for the channel
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.OutChannel">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.exn">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.list`1">
<summary>
The type of simple immutable lists 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.option`1">
<summary>
The type of None/Some options
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.ref`1">
<summary>
The type of pointers to mutable reference cells
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.abs(System.Int32)">
<summary>
Absolute value of the given integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.acos(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.asin(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.atan(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.atan2(System.Double,System.Double)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.ceil(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.compare``1(``0,``0)">
<summary>
Structural comparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.cos(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.cosh(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.decr(Microsoft.FSharp.Core.Ref`1{System.Int32})">
<summary>
Decrement a mutable reference cell containing an integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.exit``1(System.Int32)">
<summary>
Exit the current hardware isolated process, if security settings permit,
otherwise raise an exception.  Calls System.Environment.Exit.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.exp(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.failwith``1(System.String)">
<summary>
 Throw a 'Failure' exception
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.float(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.float32(System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.floor(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.fst``2(Microsoft.FSharp.Core.Tuple`2{``0,``1})">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.hash``1(``0)">
<summary>
The "hash" function is a structural hash function.  It is 
designed to return equal hash values for items that are 
equal according to the polymorphic equality 
function Pervasives.(=) (i.e. the standard "=" operator). The exact
behaviour of the function can be adjusted on a type-by-type
basis by implementing the IStructuralHash interface for each type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.ignore``1(``0)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.incr(Microsoft.FSharp.Core.Ref`1{System.Int32})">
<summary>
Increment a mutable reference cell containing an integer
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.invalid_arg``1(System.String)">
<summary>
 Throw an Invalid_argument exception
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.log(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.log10(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.max``1(``0,``0)">
<summary>
Maximum based on structural comparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.min``1(``0,``0)">
<summary>
Minimum based on structural comparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.not(System.Boolean)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.op_Addition(System.Int32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.op_Append``1(Microsoft.FSharp.Collections.List`1{``0},Microsoft.FSharp.Collections.List`1{``0})">
<summary>
 Concatenate two lists.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.op_ColonEquals``1(Microsoft.FSharp.Core.Ref`1{``0},``0)">
<summary>
Assign to a mutable reference cell
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.op_Concatenate(System.String,System.String)">
<summary>
 Concatenate two strings.  The overlaoded operator '+' may also be used.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.op_Dereference``1(Microsoft.FSharp.Core.Ref`1{``0})">
<summary>
Dereference a mutable reference cell
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.op_Division(System.Int32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.op_Equals``1(``0,``0)">
<summary>
Structural equality
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.op_GreaterThan``1(``0,``0)">
<summary>
Structural greater-than
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.op_GreaterThanOrEqual``1(``0,``0)">
<summary>
Structural greater-than-or-equal
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.op_LessGreater``1(``0,``0)">
<summary>
Structural inequality
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.op_LessThan``1(``0,``0)">
<summary>
Structural less-than comparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.op_LessThanOrEqual``1(``0,``0)">
<summary>
Structural less-than-or-equal comparison
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.op_Multiply(System.Int32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.op_MultiplyMultiply(System.Double,System.Double)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.op_Subtraction(System.Int32,System.Int32)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.raise``1(System.Exception)">
<summary>
 Throw an exception
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.ref``1(``0)">
<summary>
Create a mutable reference cell
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.sin(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.sinh(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.snd``2(Microsoft.FSharp.Core.Tuple`2{``0,``1})">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.sqrt(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.tan(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.tanh(System.Double)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.truncate(System.Double)">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives.FailureException">
<summary>
 The exception thrown by [[failure]] and many other F# functions
 A future release of F# may map this exception to a corresponding .NET exception.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives.Pervasives">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Pervasives">
<summary>
Pervasives: Additional OCaml-compatible bindings 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Printexc.print``2(Microsoft.FSharp.Core.FastFunc`2{``0,``1},``0)">

</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Printexc.to_string(System.Exception)">

</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Printexc">
<summary>
 Compatibility module to display data about exceptions.
This module is only included to make it possible to cross-compile 
code with other ML compilers.  
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Sys.argv">
<summary>
 The usual argv command line array. Gives the command line arguments
 as returned by System.Environment.GetCommandLineArgs().
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Sys.chdir(System.String)">
<summary>
 Sets the current working directory for the process using [[System.IO.Directory.SetCurrentDirectory]] 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Sys.command(System.String)">
<summary>
 Run the command and return it's exit code.

 Warning: 'command' currently attempts to execute the string using 
 the 'cmd.exe' shell processor.  If it is not present on the system 
 then the operation will fail.  Use System.Diagnostics.Process 
 directly to run commands in a portable way, which involves specifying 
 the program to run and the arguments independently.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Sys.executable_name">
<summary>
 Path of the current executable, using
 <pre>
 System.IO.Path.Combine(System.AppDomain.CurrentDomain.BaseDirectory,
                           System.AppDomain.CurrentDomain.FriendlyName)  
 </pre>
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Sys.file_exists(System.String)">
<summary>
 Returns true if a file currently exists, using System.IO.File.Exists(s).
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Sys.getcwd">
<summary>
 Returns the current working directory for the process using [[System.IO.Directory.GetCurrentDirectory]]
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Sys.getenv(System.String)">
<summary>
 System.Environment.GetEnvironmentVariable, raising
 [[Not_found]] if the variable is not defined.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Sys.remove(System.String)">
<summary>
 Deletes a file using System.IO.File.Delete(s).
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Sys.rename(System.String,System.String)">
<summary>
 Eename a file on disk using System.IO.File.Move  
</summary>
</member>
<member name="M:Microsoft.FSharp.Compatibility.OCaml.Sys.time">
<summary>
 Time consumed by the main thread. (for approximate timings).
 Generally returns only the processor time used by the main 
 thread of the application.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compatibility.OCaml.Sys.word_size">
<summary>
 The number of bits in the "int" type.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compatibility.OCaml.Sys">
<summary>
 Sys: Basic system operations (for ML compatibility)

 This module is only included to make it possible to cross-compile 
 code with other ML compilers.  It may be deprecated and/or removed in 
 a future release. You may wish to use .NET functions directly instead. 
</summary>
</member>
</members>
</doc>
